/*
  Charles Gretton (2008) says: This is a modified version of the pddl
  parser presumably written by Simon Cresswell from the Strathclyde
  Planning Group.
  
  PDDL2.1 grammar file for bison.

  $Date: April 2006 $
  $Revision: 3.2 $

  s.n.cresswell@durham.ac.uk
  Derek Long

  Srathclyde Planning Group
  http://planning.cis.ac.uk

  
*/


%{

    /*Preamble for files generated by bison.

      - Because I have no use for
        the plan parser, I am going
        to remove that
        functionality.
	
     */
    
    /* Srathclyde PG says :: 
       --------------------------------------------------------
      - Error reporting:
      Intention is to provide error token on most bracket expressions,
      so synchronisation can occur on next CLOSE_BRAC.
      Hence error should be generated for innermost expression containing error.
      Expressions which cause errors return a NULL values, and parser
      always attempts to carry on.
      This won't behave so well if CLOSE_BRAC is missing.

      - Naming conventions:
      Generally, the names should be similar to the PDDL2.1 spec.
      During development, they have also been based on older PDDL specs,
      older PDDL+ and TIM parsers, and this shows in places.

      - All the names of fields in the semantic value type begin with t_
      Corresponding categories in the grammar begin with c_
      Corresponding classes have no prefix.

      PDDL grammar       yacc grammar      type of corresponding semantic val.  

-      thing+             c_things          thing_list
      (thing+)           c_thing_list      thing_list

    */

#include <cstdlib>
#include <cstdio>
#include <fstream>
#include <ctype.h>
    
    
    // This is now copied locally to avoid relying on installation 
    // of flex++.

    //#include "FlexLexer.h"
    //#include <FlexLexer.h>

    // #include "ptree.h"
    // #include "parse_error.h"

#define YYDEBUG 1 

    int yyerror(char *);


#include "global.hh"
#include "Problem.hh"    
#include "Action_templates.hh"
#include "PredicatesAndPropositions_templates.hh"

    
    extern int yylex();
    
    using namespace Planning;
    
    /*Problem associated with \global{domain} of \class{Domain}.*/
    Problem problem;

    /*Constant integer cost of an action.*/
    int totalCost = 0;

    /*Predicate that has to be evaluated to determine the cost of an action.*/
    SignedPredicate* costEvaluator = 0;
    %}

%union	{

    
    /* Simple type for storing numbers.*/
    IntAndDouble* intAndDouble;
    
    /* --------------------- Higher level components of a PDDL spec.  ------------------- */


    /*Types have type.*/
    TypeOfTypes* typeOfTypes;

    /*Objects and constants have type.*/
    TypeOfSymbols* typeOfSymbols;
    
    /*Sequence of variables.*/
    Variables* variables;

    /*Sequence of constants.*/
    Constants* constants;
    
    /*Sequence of types.*/
    Types* types;
    
    /*Specification of a symbol's arguments*/
    Arguments* arguments;

    /*A component of the specification of a symbol's arguments.*/
    ArgumentComponent* argumentComponent;

    /*Sequence of pointers to \class{Constant}s and \class{Variable}s*/
    Parameters* parameters;

    /*Sequence of pointers (each to a \class{string}).*/
    UntypedStrings* untypedStrings;

    /* --------------------- Things to do with state ---------------------------------------- */

    Proposition<>* proposition;

    SignedProposition* signedProposition;
    
    Predicate<>* predicate;
    
    SignedPredicate* signedPredicate;
    
    /* --------------------- Things to do with operators -------- --------------------------- */

    SignedPredicates* signedPredicates;
    
//     SignedPropositions* signedPropositions;
    
    /* --------------------- Various incarnations of \class{string} and \class{string}s.  --- */
    
    string* str;

    PredicateName* predicateName;
    
    Type* type;
    
    Variable* variable;

    Constant* constant;
    
    /* --------------------- CPU types.  ------------------- */
    int integer;
    
    double real;
    
    /* --------------------- FAKE IS USED FOR PDDL components we ignore.  ------------------- */
    void* fake;
};

/* Pointers to signed predicates. The goal descriptor may be a
 * proposition or predicate. Predicates in the case that the rule is
 * used to parse an action precondition, and otherwise, for the PDDL
 * problem goal, I am quite sure this will be propositions. I'm
 * setting this up so that a predicate can be turned into a
 * proposition provided all its arguments are of \type{Constant}
 * (\parent{string}).*/
%type<signedPredicates> c_goal_descriptor

/*I have decided to store the add and delete lists as a bunch of
 * signed \union{predicates} rather than as two separate lists. --
 * This ended up being a mistake because the organisers of 2008's
 * competition posted problems that add and delete the same
 * proposition. Anyway, the recovery happens in
 * \module{GroundAction}.*/
%type<signedPredicates> c_initial_state c_init_els c_conj_effect c_p_effects c_p_effect c_a_effect c_effects c_effect 

/*Done...*/
//%type <t_effect_lists> c_da_effect c_da_effects c_a_effect_da c_p_effect_da c_p_effects_da

/*DONE... Well, proc effects seem to have something to do with timing
 * as well. Given calls to "timed_effects" are being made. So this
 * stuff is out as well.*/
// %type <t_effect_lists> c_proc_effect c_proc_effects

/*DONE.. As far as I am concerned, the effects of actions don't have to
 * be propositions, but could be predicates. --- Used to be
 * \class{Proposition}*/
%type <signedPredicate> c_pos_simple_effect c_neg_simple_effect


/*DONE... */
%type <signedProposition> c_init_pos_simple_effect c_init_neg_simple_effect

/*DONE... We do not deal with conditional effects.*/
// %type <t_cond_effect> c_cond_effect

/*DONE... We do not deal with universal quantification.*/
// %type <t_forall_effect> c_forall_effect

/*DONE... We do not deal with time.*/
// %type <t_timed_effect> c_timed_effect c_timed_initial_literal


//%type <t_parameter_symbol> c_parameter_symbol


/*DONE... typed strings.*/
%type <type> /* c_type */  c_new_primitive_type c_primitive_type
%type <predicateName> c_pred_symbol c_new_pred_symbol c_init_pred_symbol


/*Done... untyped strings*/
%type <str> c_new_func_symbol

/*Done... */
%type <constant> c_const_symbol c_new_const_symbol

/*DONE... */
%type <variable> c_var_symbol c_declaration_var_symbol

/*DONE... */
%type <variables> c_var_symbol_list;

/*DONE... */
%type <arguments> c_typed_var_list

/*Done...*/
%type <types> c_primitive_types c_new_primitive_types c_either_type

/*Done...*/
%type <typeOfTypes> c_typed_types c_type_names


/*DONE... NOTE: I'm not convinced that these strings need to be untyped.*/
%type <untypedStrings> c_new_const_symbols

/*DONE...*/
%type <typeOfSymbols> c_typed_consts c_objects c_domain_constants


// /*DONE... only used when parsing plans; not domains or problems.*/
// %type <constants> c_const_symbols

/*Done... */
%type <parameters> c_parameter_symbols
//%type <t_var_symbol_list> c_var_symbol_list c_typed_var_list


// DONE... We do not support derived propositions.
// c_derived_proposition
//

/*DONE... */
%type <signedProposition> c_init_proposition

/*DONE... */
%type <signedPredicate> c_proposition


/*DONE... */
// %type <predicate> c_func_decl


// DONE. 
//%type <t_pred_decl> c_pred_decl
//%type <t_pred_decl_list> c_pred_decls c_predicates


//%type <t_func_decl> c_func_decl
//%type <t_func_decl_list> c_func_decls c_functions_def


/* The way the rule unwinds is as follows :: 
 *
 * c_goal_spec -> c_pre_goal_descriptor ->
 *
 *     c_pref_goal_descriptor -> c_goal_descriptor
 *
 *          (If this is the case, then we have that the goal consists
 *          of this, and only this.)
 *
 *     c_pre_goal_descriptor_list -> 
 *
 *          (In this case we build what they called a conjunctive goal.)
 *
 *  - It seems like the "pre_" part of "pre_goal_descriptor" is a
 * reference to preferences.
 */

/*Done.. We don't use types for the goal, but simply parse it straight
 * into the problem goal datastructure.*/

%type <signedPredicates> c_pre_goal_descriptor
%type <signedPredicates> c_pre_goal_descriptor_list
%type <signedPredicates> c_pref_goal_descriptor
%type <signedPredicates> c_goal_spec

//c_goal_spec c_pre_goal_descriptor_list
// %type <> c_goal_descriptor

/*Done.. we do not do duration constraints.*/
//c_duration_constraint


/*Done.. 
 * descriptor.*/
//c_da_gd

/*Done.. We do not need types for the following because we ignore them.*/
// c_pref_goal_descriptor
// c_constraint_goal

/*Done.. Similarly we do not require lists of the above types.*/
// c_pref_con_goal_list
// c_constraint_goal_list

//DONE... We do not support timed goals.
//c_timed_gd /* c_f_comp */

/*DONE... We do not support constrained goals. We also do not support
 * durative actions.*/
//%type <t_con_goal> c_constraints_def c_constraints_probdef c_pref_con_goal
//%type <t_goal_list> c_goal_list  c_duration_constraints c_da_gds  

/*DONE... We do not support any type of quantification.*/
// %type <t_quantifier> c_quantifier c_forall c_exists


/*DONE... We do not support reasoning about function symbols.*/
//%type <t_func_term> c_f_head /* c_new_f_head */  c_ground_f_head

/*DONE... We do not support reasoning about assignments.*/
//%type <t_assignment> c_assignment c_f_assign_da

/*DONE.. We really don't support function symbols at all -- Except as
 * mush as the 2008 competition organises required for incrementing
 * \pddl{total_cost}...*/
//%type <t_expression> c_f_exp c_ground_f_exp c_binary_ground_f_exp c_f_exp_da c_f_exp_t c_binary_expr_da c_d_value c_binary_ground_f_pexps c_binary_ground_f_mexps


/* Done.. A number is either an \type{int}eger or a \type{double}.*/
%type <intAndDouble> c_number

// %type <t_comparison_op> c_comparison_op c_d_op

// %type <t_structure_def> c_structure_def

/* DONE... We build the \global{domain} actions during the parse, via
 * calls to \global{domain} \member{addAction}.*/
//%type <t_action_def> c_action_def


//%type <t_event_def> c_event_def

//DONE... no support for processes.
// %type <t_process_def> c_process_def

// %type <t_durative_action_def> c_durative_action_def c_da_def_body
%type <t_derivation_rule> c_derivation_rule
%type <t_structure_store> c_structure_defs


// Bit vectors for global properties
// of the domain... I have replaced
// this idea with specific booleans for
// each property. These are stored in
// the \module{Domain} 
// 
//%type <t_pddl_req_flag> c_domain_require_def c_require_key c_reqs


/*Done... This is just a single global problem from now on.*/
//%type <t_problem> c_problem c_problem_body


/*Done.. There was no reason to give these guys a type. In the end,
 * \rule{c_length_spec} triggered \rule{c_length_field} which was a
 * rule made specifically for parsing constraints about "serial" and
 * parallel plan lengths.*/
// %type <t_length_spec> c_length_spec c_length_field


/*Done.. Application can only handle one domain at a time for the moment.*/
//%type <t_domain> c_domain c_preamble

//Done... there is no use having a dummy type..
//%type <t_dummy> /*c_action_kind*/ c_args_head c_rule_head 

//%type <t_optimization> c_optimization
//%type <t_metric> c_metric_spec

%type <str> c_domain_name
%type <real> c_float

//%type <vtab> c_goals;

// Strathclyde :: Punctuation tokens -- lisp-style.
%token <punct> OPEN_BRAC CLOSE_BRAC 

%token OPEN_SQ
%token CLOSE_SQ
%token DEFINE
%token PDDLDOMAIN
%token REQS
%token EQUALITY
%token STRIPS
%token ADL
%token NEGATIVE_PRECONDITIONS
%token TYPING
%token DISJUNCTIVE_PRECONDS

%token EXT_PRECS
%token UNIV_PRECS
%token QUANT_PRECS
%token COND_EFFS

%token FLUENTS
%token TIME
%token DURATIVE_ACTIONS
%token DURATION_INEQUALITIES
%token CONTINUOUS_EFFECTS

%token DERIVED_PREDICATES
%token TIMED_INITIAL_LITERALS
%token PREFERENCES
%token CONSTRAINTS

%token ACTION_COSTS
%token ACTION
%token NUMBER
%token PROCESS
%token EVENT
%token DURATIVE_ACTION
%token DERIVED

%token CONSTANTS
%token PREDS
%token FUNCTIONS
%token TYPES
%token ARGS
%token PRE
%token CONDITION
%token PREFERENCE

%token START_PRE
%token END_PRE /* Strathclyde :: Redundant */

%token EFFECTS

%token INITIAL_EFFECT
%token FINAL_EFFECT
%token INVARIANT
%token DURATION /* Strathclyde :: Redundant */

%token AT_START
%token AT_END
%token OVER_ALL

%token AND
%token OR
%token EXISTS
%token FORALL
%token IMPLY
%token NOT
%token WHEN
%token EITHER

%token PROBLEM
%token FORDOMAIN
%token INITIALLY

%token OBJECTS
%token GOALS
%token EQ LENGTH
%token SERIAL
%token PARALLEL
%token METRIC

%token MINIMIZE
%token MAXIMIZE

%token HASHT
%token DURATION_VAR
%token TOTAL_TIME

%token INCREASE
%token DECREASE
%token SCALE_UP
%token SCALE_DOWN
%token ASSIGN

%token GREATER
%token GREATEQ
%token LESS
%token LESSEQ /* Strathclyde :: EQUALS */
%token Q
%token COLON

%token ALWAYS
%token SOMETIME
%token WITHIN
%token ATMOSTONCE
%token SOMETIMEAFTER
%token SOMETIMEBEFORE

%token ALWAYSWITHIN
%token HOLDDURING
%token HOLDAFTER
%token ISVIOLATED

// Strathclyde :: This never appears in the BCNF.
//%token BOGUS

%token <str> NAME FUNCTION_SYMBOL
%token <integer> INTVAL
%token <real> FLOATVAL
%token <real> AT_TIME

%left HYPHEN PLUS	
%left MUL DIV
%left UMINUS

%%
input : 
c_domain  {
    VERBOSE("Parsed domain definition.");
}
|   c_problem {
    VERBOSE("Parsed problem.");
    }
/* |   c_plan    { */
/*     VERBOSE("Parsed plan."); */
/*     } */
;

c_domain : 
OPEN_BRAC DEFINE c_domain_name c_preamble CLOSE_BRAC 
{
//     $$= $4;
//     $$->name= $3;
//     delete [] $3;
}
|   OPEN_BRAC DEFINE c_domain_name error 
{
    yyerrok;
    //$$=static_cast<domain*>(NULL);

    UNRECOVERABLE_ERROR("Syntax error in domain specification.");
    
    //log_error(E_FATAL,"Syntax error in domain");
}  // Helpful?
;

// Assumes operators defns are last, and at least one of them present.
c_preamble :
c_domain_require_def c_preamble  {
    //$$= $2; $$->req= $1;
} 
| c_type_names c_preamble          {

    problem.domain.setTypes($1);
    
}
| c_domain_constants c_preamble    {
    problem.domain.setConstants($1);
}
| c_predicates c_preamble          {
    //$$= $2; 
    //$$->predicates= $1;
}
| c_functions_def c_preamble       {
    //$$= $2; 
    //$$->functions= $1;
}
| c_constraints_def c_preamble     {
    //$$= $2;
    //$$->constraints = $1;
}
| c_structure_defs                 {
    //$$= new SuperType($1);
  }//new domain($1);
;                    

/* START -- DONE*/
c_domain_name : OPEN_BRAC PDDLDOMAIN NAME CLOSE_BRAC {
    $$ = $3;
}
;
/* END -- DONE*/

/* START -- DONE -- All requirements are now stored in the
 * \class{Domain} \global{domain} object.*/
c_domain_require_def : 
OPEN_BRAC REQS c_reqs CLOSE_BRAC
{
/*     // Stash in analysis object --- we need to refer to it during parse */
/*     //   but domain object is not created yet, */
/*     current_analysis->req |= $3; */
/*     $$=$3; */
}
|  OPEN_BRAC REQS error CLOSE_BRAC
{
    yyerrok; 
    UNRECOVERABLE_ERROR("Syntax error in requirements declaration.");
/*     log_error(E_FATAL,"Syntax error in requirements declaration."); */
/*     $$= 0; */
}
;
/* END -- DONE*/

/* START -- DONE*/
/*Read off all the features that we are allowed to use in the
 * specification of the domain. */
c_reqs : 
c_reqs c_require_key { }
|   /* empty */          { }
;
/* END -- DONE*/


c_pred_decls :
c_pred_decl c_pred_decls 
{
}
|   c_pred_decl 
{
};

/* START -- DONE*/
c_pred_decl :
OPEN_BRAC c_new_pred_symbol c_typed_var_list CLOSE_BRAC
{
    problem.domain.predicateSpecifications[*$2] = *$3;
    FAKE_DELETE($3);
    FAKE_DELETE($2);
}
|   OPEN_BRAC error CLOSE_BRAC
{
    yyerrok;
    UNRECOVERABLE_ERROR("Syntax error in predicate declaration.");
    // hope someone makes this error someday
/*     log_error(E_FATAL,"Syntax error in predicate declaration."); */
/*     $$= NULL; */
}
;
/* END -- DONE*/

/* START -- DONE*/
c_new_pred_symbol :
NAME 
{
    VERBOSER(1, "New predicate symbol"<<NAME<<endl);

    $$ = new PredicateName(*$1);
    
    problem.domain.predicates.insert(*$$);
    
    FAKE_DELETE($1);
    
/*     $$=current_analysis->pred_tab.symbol_put($1); */
/*     current_analysis->var_tab_stack.push( */
/* 	current_analysis->buildPredTab()); */
/*     delete [] $1; */
}
;
/* END -- DONE*/


/* START -- DONE*/
c_pred_symbol : 
EQ   {
    //$$=current_analysis->pred_tab.symbol_ref("=");

    $$ = new PredicateName("=");
    
    problem.domain.requires.equality = true;
    //requires(E_EQUALITY);
}
|   NAME {

    $$ = new PredicateName(*$1);
    FAKE_DELETE($1);
    }
;
/* END -- DONE*/


/* START -- DONE*/
c_init_pred_symbol : 
// We have a different pred_symbol rule for the initial state
// so as to exclude EQ,
// which must be parsed as assignment in initial state.
NAME {
    $$ = new PredicateName(*$1);
    FAKE_DELETE($1);
    //$$=current_analysis->pred_tab.symbol_get($1); delete [] $1;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_func_decls :
c_func_decls c_func_decl
{
    WARNING("We do not support functor (c_func_decls) declarations.");

    //$$ = NULL;//new SuperType($2);
    
}// $$->push_back($2);}
|   /* empty */  {
    WARNING("We do not support functor (c_func_decls) declarations.");
    //$$ = NULL;//new SuperType();
}//$$=new func_decl_list; }
;
/* END -- DONE*/

/* START -- DONE*/
c_func_decl :
OPEN_BRAC c_new_func_symbol c_typed_var_list CLOSE_BRAC
{
    WARNING("We do not support functor (c_func_decl) declarations."<<endl
	    <<"The symbol involved is :: "<<*$2<<" and a typed variable list :: "<<endl
	    <<*$3<<endl);
    
    FAKE_DELETE($2);
    
    //$$ = NULL;//new SuperType();//($2, $3);
    //$$= new func_decl($2,$3,current_analysis->var_tab_stack.pop());
}
| OPEN_BRAC c_new_func_symbol c_typed_var_list CLOSE_BRAC HYPHEN NUMBER
{
    WARNING("We do not support functor (c_func_decl) declarations."<<endl
	    <<"The symbol involved is :: "<<*$2<<" and a typed variable list :: "<<endl
	    <<*$3<<endl);
    
    FAKE_DELETE($2);
    
    //$$ = NULL;//new SuperType();//($2, $3);
    //$$= new func_decl($2,$3,current_analysis->var_tab_stack.pop());
}
| OPEN_BRAC c_new_func_symbol CLOSE_BRAC HYPHEN NUMBER
{
    string* functionName = $2;
    VERBOSER(19, "Adding new function with name :: "<<*functionName<<endl);

    assert(*functionName == string("total-cost"));

    problem.domain.addFunction<uint>(*functionName, Parameters());
    
    //$$ = new PositiverIntegerFunction(*functionName, Parameters());
    
    //$$ = new Function(*functionName, );

    FAKE_DELETE(functionName);
}
|   OPEN_BRAC error CLOSE_BRAC
{
    //$$ = NULL;
    yyerrok;
    WARNING("Syntax error in functor (c_func_decl) declaration.");
/*     log_error(E_FATAL,"Syntax error in functor declaration."); */
/*     $$= NULL; */ }
;
/* END -- DONE*/

/* START -- DONE*/
c_new_func_symbol :
NAME 
{
    $$ = $1;
    WARNING("We do not support functor (c_new_func_symbol) declarations."<<endl
			<<"The symbol involved is :: "<<*$1<<"."<<endl);

    
//     $$ = new String($1);
    
//     domain.functionSymbols.insert(string($1));
//     FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
// variables, possibly with types
c_typed_var_list :        /* Type specified */
c_var_symbol_list HYPHEN c_primitive_type c_typed_var_list 
{
    
    /*Our objective is to concatenate the "typed variable list"
     * \union{arguments} \at{c_typed_var_list} with a new
     * list of variables \union{variables}
     * \at{c_var_symbol_list} which have the type \union{variable}
     * \at{c_primitive_type}.*/

    /*We must have already passed some of a typed variables list
     * \at{c_typed_var_list }*/
    $$ = $4;

    Types tmp;
    tmp.push_back(*$3);//Type($3));
    ArgumentComponent argumentComponent(tmp, *$1);//Variables($1->begin(), $1->end()));
    $$->push_back(argumentComponent);
    FAKE_DELETE($1);
    FAKE_DELETE($3);
    
    /*At this point we know that the domain requires typed variables.*/
    problem.domain.requires.typing = true;
}
|  c_var_symbol_list HYPHEN c_either_type c_typed_var_list 
{
    
    
    /*Our objective is to concatenate the "typed variable list"
     * \union{arguments} \at{c_typed_var_list} with a new
     * list of variables \union{variables}
     * \at{c_var_symbol_list} which have of or more of the types in
     * \union{types} \at{c_primitive_type}.*/
    
    
    $$ = $4;

    ArgumentComponent argumentComponent(*$3, *$1);//Variables($1->begin(), $1->end()));
    $$->push_back(argumentComponent);
    FAKE_DELETE($1);
    FAKE_DELETE($3);

    
    /*At this point we know that the domain requires typed variables.*/
    problem.domain.requires.typing = true;
}
|  c_var_symbol_list                /* No type specified */
{
    /*A, possibly empty, list of untyped variables.*/
    $$ = new Arguments;

    if($1->size() > 0){
	ArgumentComponent argumentComponent(Types(), *$1);
	$$->push_back(argumentComponent);
    }
    
    
    FAKE_DELETE($1);
}
| /* empty */   
{
    $$ = new Arguments;
}
;
/* END -- DONE*/


/* START -- DONE*/
// a list of variables (excluding type declaration)
// Semantic value is a list of symbols
c_var_symbol_list :
Q c_declaration_var_symbol c_var_symbol_list
{
    /*Add the \union{variable} \at{c_declaration_var_symbol} to the
     * \union{variables} \at{c_var_symbol_list}*/
    
    $$=$3;
    $3->push_back(*$2);
    FAKE_DELETE($2);
}
| /* Empty */ {
    $$ = new Variables();//var_symbol_list;
}
;
/* END -- DONE*/

/* START -- DONE*/
// A list of constants (object names or types), possibly with parent types
c_typed_consts :        
/* Type specified */
c_new_const_symbols HYPHEN c_primitive_type c_typed_consts {

    /*We have that \union{untypedStrings} \at{c_new_const_symbols} are
     * untyped \class{string}s that should cast to either
     * \class{Constant} or \class{Type}. \at{c_primitive_type} we have
     * a \union{type}.*/
    
    $$ = $4;
    
    Types tmp;
    tmp.push_back(*$3);
    TypeOfSymbol typeOfSymbol(tmp, *$1);//Variables($1->begin(), $1->end()));
    $$->push_back(typeOfSymbol);
    FAKE_DELETE($1);
    FAKE_DELETE($3);
    
    problem.domain.requires.typing = true;
    
}
|  c_new_const_symbols HYPHEN c_either_type c_typed_consts 
{
    $$ = $4;
    
    TypeOfSymbol typeOfSymbol(*$3, *$1);//Variables($1->begin(), $1->end()));
    $$->push_back(typeOfSymbol);
    FAKE_DELETE($1);
    FAKE_DELETE($3);
    
    problem.domain.requires.typing = true;
}
| /* No type specified */
c_new_const_symbols {
    /*A, possibly empty, list of untyped type-or-constant symbols.*/
    $$ = new TypeOfSymbols;

    if($1->size() > 0){
	TypeOfSymbol typeOfSymbol(Types(), *$1);
	$$->push_back(typeOfSymbol);
    }
    
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* Charles Gretton :: Tue Oct 30 14:59:17 EST 2007 :: This rule was
 * only ever used to parse plans for validation purposes, never to
 * parse a domain or problem specification. As far as I can tell, this
 * rule is not needed for my planner.*/
// /* START -- DONE*/
// // A list of object names without parent types
// c_const_symbols :
// c_const_symbol c_const_symbols {

//     $$ = $2;
//     $$->push_back(*$1);
//     problem.constants.insert(*$1);
//     FAKE_DELETE($1);
    
// //     $$=$2; $2->push_front($1);
// }
// | /* Empty */ {
//     $$= new Constants();
// }
// ;
// /* END -- DONE*/

/* START -- DONE*/
c_new_const_symbols :
c_new_const_symbol c_new_const_symbols {
    $$ = $2;
    $$->push_back($1);
    //problem.constants.insert(*$1);
    //FAKE_DELETE($1);
//     $$=$2; $2->push_front($1);
}
| /* Empty */ {
    $$= new UntypedStrings();
}
;
/* END -- DONE*/



/* START -- DONE*/
// Strathclyde :: As above , but for PDDL types possibly with parent types
c_typed_types :        
// Type specified
c_new_primitive_types HYPHEN c_primitive_type c_typed_types
{
    $$ = $4;
    
    Types tmp;
    tmp.push_back(*$3);
    TypeOfType typeOfType(tmp, *$1);
    $$->push_back(typeOfType);
    
    FAKE_DELETE($1);
    FAKE_DELETE($3);
}
|  c_new_primitive_types HYPHEN c_either_type c_typed_types 
{
    $$ = $4;

    TypeOfType typeOfType(*$3, *$1);
    $$->push_back(typeOfType);
    
    FAKE_DELETE($1);
    FAKE_DELETE($3);
}
|  // No parent type specified
c_new_primitive_types                
{
    $$ = new TypeOfTypes();

    if($1->size() > 0){
	TypeOfType typeOfType(Types(), *$1);
	$$->push_back(typeOfType);
    }
    
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
// constants or variables (excluding type declaration)
c_parameter_symbols : 
c_parameter_symbols c_const_symbol 
{
    $$=$1;
    $$->push_back($2);
}
|   c_parameter_symbols Q c_var_symbol
{
    $$=$1;
    $$->push_back($3); }
|   /* Empty */ {
    $$= new Parameters();
    }
;
/* END -- DONE*/

/* START -- DONE*/
// Used in declaration of variable
//  - var symbol is added to var table at top of stack 
c_declaration_var_symbol :
NAME {
    $$ = new Variable(*$1);
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
// Used when variable is expected to have already been declared.
// The lookup is an operation on the whole stack of variable tables.
c_var_symbol :
NAME { 
    $$ = new Variable(*$1);
    FAKE_DELETE($1);
}//$$= current_analysis->var_tab_stack.symbol_get($1); delete [] $1; }
;
/* END -- DONE*/


/* START -- DONE*/
c_const_symbol : 
NAME { 
    $$ = new Constant(*$1);
    //problem.constants.insert(*$$);
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_new_const_symbol : 
NAME {
    $$ = new Constant(*$1);
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_either_type :
OPEN_BRAC EITHER c_primitive_types CLOSE_BRAC
{ $$ = $3; }
;
/* END -- DONE*/

/* START -- DONE*/
c_new_primitive_type :
NAME 
{
    $$ = new Type(*$1);
    FAKE_DELETE($1);
}
// We use symbol ref here in order to support multiple declarations of
// a type symbol - this is required for multiple inheritance.
;
/* END -- DONE*/

/* START -- DONE*/
c_primitive_type :
NAME 
{ 
    $$ = new Type(*$1);
    FAKE_DELETE($1);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_new_primitive_types :
c_new_primitive_types c_new_primitive_type 
{
    $$= $1;
    $$->push_back(*$2);
    FAKE_DELETE($2);
}
|   /* empty */ {

    
    $$ = new Types();
    
}
;
/* END -- DONE*/


/* START -- DONE*/
c_primitive_types :
c_primitive_types c_primitive_type 
{
    $$ = $1;
    $$->push_back(*$2);
    FAKE_DELETE($2);
    //$$= $1; $$->push_back($2);
}
|   /* empty */ {
    $$ = new Types();//new pddl_type_list;
}
;
/* END -- DONE*/

/* START -- DONE -- Determines what is true in the initial state.*/
c_init_els :
c_init_els OPEN_BRAC EQ c_pos_simple_effect /*c_f_head*/ c_number CLOSE_BRAC
{
    VERBOSER(25, "Function occurs in starting state description (c_init_els).\n");

    SignedPredicate* groundFunctionSymbol = $4;
    
    assert(groundFunctionSymbol->isPositive());
    
    /*At this point we assert that all the arguments to
     * \local{groundFunctionSymbol} are of type \type{Constant} (see
     * \module{PredicatesAndPropositions}). */
    Proposition<> proposition(*groundFunctionSymbol);
    
    problem.startingStateFunctionEvaluation[proposition]
	= $5->getVal(0);
    
    /*c_number*/
    FAKE_DELETE($5);

    /*c_pos_simple_effect*/
    FAKE_DELETE($4);
    
//     $$=$1;
//     $$->assign_effects.push_back(new assignment($4,E_ASSIGN,$5));  
//     requires(E_FLUENTS); 
}
|   c_init_els c_init_pos_simple_effect
{
    VERBOSER(1, "Parsing a initialisation add effect (c_init_els).\n");

    $$->push_back($2);
}
|   c_init_els c_init_neg_simple_effect 
{
    VERBOSER(1, "Parsing a initialisation delete effect (c_init_els).\n");

    $$->push_back($2);
    
    WARNING("Delete effect in starting state :: "<<*$2);
}
|   c_init_els c_timed_initial_literal 
{
    WARNING("We do not deal with timed literals (c_init_els).\n");
    
    // $$=$1; $$->timed_effects.push_back($2);
}
|   /* empty */
{
    VERBOSER(1, "Starting to parse the starting state (c_init_els).\n");

    $$ = new SignedPredicates();
}
;
/* END -- DONE*/

/* START -- DONE*/
c_timed_initial_literal :
OPEN_BRAC AT_TIME c_init_els CLOSE_BRAC
{
    WARNING("We do not deal with timed literals (c_timed_initial_literal).\n");
//     requires(E_TIMED_INITIAL_LITERALS); 
//     $$=new timed_initial_literal($3,$2);
}
;
/* END -- DONE*/


c_effects :
c_a_effect    c_effects
{
    /*\at{c_a_effect} is a conjunction of effects.*/
    
    $$ = $2; //$$->append_effects($1); delete $1;

    $$->insert($$->begin(), $1->begin(), $1->end());
    FAKE_DELETE($1);
}
|   c_cond_effect c_effects       {
    
    $$ = 0;
    WARNING("We do not support conditional effects (c_effects).");
}
|   c_forall_effect c_effects     {
    
    $$ =0;
    WARNING("We do not support universal quantification (c_effects).");
}
|   /* nothing */ {
    //$$=new effect_lists();
    VERBOSER(1, "Make a new effects list.");
    $$ = new SignedPredicates();//AddAndDeleteList();
    }
;

// Parse a single effect as effect_lists
// Wasteful, but we get the benefit of categorising effect, and
// we will often need the lists when normalising the contained effects.
// e.g. conjunctive effects will immediately collapse into this structure.


/*START -- DONE*/
c_effect :
c_conj_effect       {
    $$ = $1;
}
|   c_pos_simple_effect {
    VERBOSER(1, "Parsing simple negative effect (c_effect)."<<endl);
    $$ = new SignedPredicates(1);//AddAndDeleteList;
    (*$$)[0] = $1;//->push_back($1);
    //FAKE_DELETE($1);
//     $$=new effect_lists;
//     $$->add_effects.push_front($1);
    }
|   c_neg_simple_effect {
    VERBOSER(1, "Parsing simple negative effect (c_effect)."<<endl);
    
    $$ = new SignedPredicates(1);//AddAndDeleteList;
    (*$$)[0] = $1;//->second.push_back(*$1);
    //FAKE_DELETE($1);
//     $$=new effect_lists;
//     $$->del_effects.push_front($1);
    }
|   c_cond_effect       {
    $$ = NULL;
    
    WARNING("We do not deal with conditional effects (c_effect)."<<endl);
    //$$=new effect_lists; $$->cond_effects.push_front($1);
    }
|   c_forall_effect     {
    $$ = NULL;
    
    WARNING("We do not deal with universally quantified effects (c_effect)."<<endl);
    //$$=new effect_lists; $$->forall_effects.push_front($1);
    }
;
/*END -- DONE*/

/*START -- DONE*/
c_a_effect :
OPEN_BRAC AND c_p_effects CLOSE_BRAC {
    $$= $3;
}
|   c_p_effect        {
    VERBOSER(19, "Parsing (c_p_effect) from (c_a_effect)."<<endl);
    $$= $1;
    }
;
/*END -- DONE*/

/*START -- DONE*/
c_p_effect :
c_neg_simple_effect 
{
    VERBOSER(1, "Parsing simple negative effect (c_p_effect).");
    $$ = new SignedPredicates(1);//addAndDeleteList;
    (*$$)[0] = $1;//->second.push_back(*$1);
    //FAKE_DELETE($1);
    
    //$$=new effect_lists; $$->del_effects.push_front($1);
}
|   c_pos_simple_effect 
{
    VERBOSER(1, "Parsing simple positive effect (c_p_effect).");
    $$ = new SignedPredicates(1);//addAndDeleteList;
    (*$$)[0] = $1;//->first.push_back(*$1);
    //FAKE_DELETE($1);
    //$$=new effect_lists; $$->add_effects.push_front($1);
}
| c_action_cost_effect
{
    VERBOSER(19, "Parsing action cost effect."<<endl);
    $$ = new SignedPredicates();
    //$$ = NULL;
}
|   c_assignment        
{
    $$ = NULL;
    WARNING("We do not support assignments (c_p_effect).");
//     $$=new effect_lists; $$->assign_effects.push_front($1);
//     requires(E_FLUENTS);
}
;
/*END -- DONE*/


/*START -- DONE*/
c_p_effects :
c_p_effects c_neg_simple_effect {
    $$= $1;
    $$->push_back($2);
    //FAKE_DELETE($2);
}
|   c_p_effects c_pos_simple_effect {
    $$= $1;
    $$->push_back($2);
    //FAKE_DELETE($2);
}
|   c_p_effects c_assignment        {

    $$ = NULL;
    WARNING("We do not support assignments (c_p_effects).");
//     $$= $1; $$->assign_effects.push_back($2);
//     requires(E_FLUENTS);
}
| c_p_effects c_action_cost_effect
{
    $$ = $1;/*HERE*/
    
}
|   /* empty */  {
    $$= new SignedPredicates;//addAndDeleteList();//new effect_lists;
    }
;
/*END -- DONE*/

c_action_cost_effect :
OPEN_BRAC INCREASE OPEN_BRAC c_new_func_symbol CLOSE_BRAC INTVAL CLOSE_BRAC
{
    /*HERE*/
    
    string* functionName = $4;

    totalCost = $6;
    
    assert(*functionName == string("total-cost"));
    FAKE_DELETE(functionName);
}
| OPEN_BRAC INCREASE OPEN_BRAC c_new_func_symbol CLOSE_BRAC c_pos_simple_effect CLOSE_BRAC
{
    /*HERE*/
    
    string* functionName = $4;
    
    costEvaluator = $6;
    
    assert(*functionName == string("total-cost"));
    FAKE_DELETE(functionName);
}
;


/*START -- DONE*/
c_conj_effect : 
OPEN_BRAC AND c_effects CLOSE_BRAC 
{
    $$=$3;
}
|   OPEN_BRAC AND error CLOSE_BRAC
{
    yyerrok;
    $$=NULL;
    UNRECOVERABLE_ERROR("Broken conjunctive effect (c_conj_effect).");
    
    //log_error(E_FATAL,"Syntax error in (and ...)");
}
;
/*END -- DONE*/


/*START -- DONE.. Can't get no bus to Pomona: I don't do durative actions. */
c_da_effect :
OPEN_BRAC AND c_da_effects CLOSE_BRAC
{ }//$$=$3; }        
|   OPEN_BRAC c_forall 
OPEN_BRAC c_typed_var_list CLOSE_BRAC 
c_da_effect
CLOSE_BRAC
{ // $$= new effect_lists; 
//     $$->forall_effects.push_back(
// 	new forall_effect($6, $4, current_analysis->var_tab_stack.pop())); 
//     requires(E_COND_EFFS);
}
|   OPEN_BRAC WHEN c_da_gd c_da_effect CLOSE_BRAC
{ // $$= new effect_lists;
//     $$->cond_effects.push_back(
// 	new cond_effect($3,$4));
//     requires(E_COND_EFFS);
}
|   c_timed_effect 
{ // $$=new effect_lists;
//     $$->timed_effects.push_back($1);
}
|   c_assignment
{ // $$= new effect_lists;
//     $$->assign_effects.push_front($1);
//     requires(E_FLUENTS);
}
;
/*END -- DONE*/

/* START -- DONE*/
c_da_effects :
c_da_effects c_da_effect {

    
    //$$=$1; $1->append_effects($2); delete $2;
}
|   /* empty */ {
    //$$= new effect_lists;
}
;
/*END -- DONE*/

/* START -- DONE*/
c_timed_effect :
OPEN_BRAC AT_START c_a_effect_da CLOSE_BRAC
{
    WARNING("We do not support timed effects (c_timed_effect).");
    //$$=new timed_effect($3,E_AT_START);
}
|   OPEN_BRAC AT_END c_a_effect_da CLOSE_BRAC
{
    WARNING("We do not support timed effects (c_timed_effect).");
    //$$=new timed_effect($3,E_AT_END);
}
|   OPEN_BRAC INCREASE c_f_head c_f_exp_t CLOSE_BRAC
{
    WARNING("We do not support timed effects (c_timed_effect).");
//     $$=new timed_effect(new effect_lists,E_CONTINUOUS);
//     $$->effs->assign_effects.push_front(
// 	new assignment($3,E_INCREASE,$4));
}
|   OPEN_BRAC DECREASE c_f_head c_f_exp_t CLOSE_BRAC
{
    WARNING("We do not support timed effects (c_timed_effect).");
//     $$=new timed_effect(new effect_lists,E_CONTINUOUS);
//     $$->effs->assign_effects.push_front(
// 	new assignment($3,E_DECREASE,$4));
}
|   OPEN_BRAC error CLOSE_BRAC
{
    yyerrok;
    WARNING("We do not support timed effects (c_timed_effect).");
//     log_error(E_FATAL,"Syntax error in timed effect");
}
;
/* END -- DONE*/

/* START -- DONE*/
c_a_effect_da :
OPEN_BRAC AND c_p_effects_da CLOSE_BRAC {
    //$$= $3;
}
|   c_p_effect_da        {
    //$$= $1;
    }
;
/* END -- DONE*/


/* START -- DONE*/
c_p_effect_da :
c_neg_simple_effect 
{
    //$$=new effect_lists; $$->del_effects.push_front($1);
}
|   c_pos_simple_effect 
{
    //$$=new effect_lists; $$->add_effects.push_front($1);
}
|   c_f_assign_da
{
//     $$=new effect_lists; $$->assign_effects.push_front($1);
//     requires(E_FLUENTS);
}
;
/* END -- DONE*/


/* START -- DONE*/
c_p_effects_da :
c_p_effects_da c_neg_simple_effect {
    //$$= $1; $$->del_effects.push_back($2);
}
|   c_p_effects_da c_pos_simple_effect {
    //$$= $1; $$->add_effects.push_back($2);
}
|   c_p_effects_da c_f_assign_da       {
    //$$= $1; $$->assign_effects.push_back($2);
    //requires(E_FLUENTS);
}
|   /* empty */  {
    //$$= new effect_lists;
    }
;
/* END -- DONE*/


/* START -- DONE*/
c_f_assign_da :
OPEN_BRAC ASSIGN c_f_head c_f_exp_da CLOSE_BRAC
{
    //$$= new assignment($3,E_ASSIGN,$4);
}
|  OPEN_BRAC INCREASE c_f_head c_f_exp_da CLOSE_BRAC
{
    //$$= new assignment($3,E_INCREASE,$4);
}
|  OPEN_BRAC DECREASE c_f_head c_f_exp_da CLOSE_BRAC
{
    //$$= new assignment($3,E_DECREASE,$4);
}
|  OPEN_BRAC SCALE_UP c_f_head c_f_exp_da CLOSE_BRAC
{
    //$$= new assignment($3,E_SCALE_UP,$4);
}
|  OPEN_BRAC SCALE_DOWN c_f_head c_f_exp_da CLOSE_BRAC
{
    //$$= new assignment($3,E_SCALE_DOWN,$4);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_proc_effect :
OPEN_BRAC INCREASE c_f_head c_f_exp_t CLOSE_BRAC
{// $$=new effect_lists; 
//     timed_effect * te = new timed_effect(new effect_lists,E_CONTINUOUS);
//     $$->timed_effects.push_front(te);
//     te->effs->assign_effects.push_front(
// 	new assignment($3,E_INCREASE,$4));
}
|   OPEN_BRAC DECREASE c_f_head c_f_exp_t CLOSE_BRAC
{// $$=new effect_lists; 
//     timed_effect * te = new timed_effect(new effect_lists,E_CONTINUOUS);
//     $$->timed_effects.push_front(te);
//     te->effs->assign_effects.push_front(
// 	new assignment($3,E_DECREASE,$4));
}
| OPEN_BRAC AND c_proc_effects CLOSE_BRAC 
{// $$ = $3;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_proc_effects :
c_proc_effects c_proc_effect { // $$=$1; $1->append_effects($2); delete $2;
}
|   /* empty */ { // $$= new effect_lists;
}
;
/* END -- DONE*/	

/* START -- DONE*/
c_f_exp_da :
c_binary_expr_da {// $$= $1;
}
|   Q DURATION_VAR {// $$= new special_val_expr(E_DURATION_VAR);
//     requires( E_DURATION_INEQUALITIES );
}
|   c_number { // $$=$1;
    FAKE_DELETE($1);
    }
|   c_f_head  { // $$= $1;
    }
;
/* END -- DONE*/	

/* START -- DONE*/
c_binary_expr_da :
OPEN_BRAC PLUS c_f_exp_da c_f_exp_da CLOSE_BRAC
{ // $$= new plus_expression($3,$4);
}
|   OPEN_BRAC HYPHEN c_f_exp_da c_f_exp_da  CLOSE_BRAC
{ // $$= new minus_expression($3,$4);
}
|   OPEN_BRAC MUL c_f_exp_da c_f_exp_da CLOSE_BRAC
{ // $$= new mul_expression($3,$4);
}
|   OPEN_BRAC DIV c_f_exp_da c_f_exp_da	CLOSE_BRAC
{ // $$= new div_expression($3,$4);
}
;
/* END -- DONE*/	

/* START -- DONE*/
c_duration_constraint :
OPEN_BRAC AND c_duration_constraints CLOSE_BRAC
{ // $$= new conj_goal($3);
}
|   OPEN_BRAC c_d_op Q DURATION_VAR c_d_value CLOSE_BRAC
{ // $$= new timed_goal(new comparison($2,
// 				    new special_val_expr(E_DURATION_VAR),$5),E_AT_START);
}
|   OPEN_BRAC AT_START OPEN_BRAC c_d_op Q DURATION_VAR c_d_value CLOSE_BRAC CLOSE_BRAC
{ // $$ = new timed_goal(new comparison($4,
// 				     new special_val_expr(E_DURATION_VAR),$7),E_AT_START);
}
|   OPEN_BRAC AT_END OPEN_BRAC c_d_op Q DURATION_VAR c_d_value CLOSE_BRAC CLOSE_BRAC
{ // $$ = new timed_goal(new comparison($4,
// 				     new special_val_expr(E_DURATION_VAR),$7),E_AT_END);
}
;
/* END -- DONE*/	


/* START -- DONE*/
c_d_op :
LESSEQ   {// $$= E_LESSEQ; requires(E_DURATION_INEQUALITIES);
}
|   GREATEQ  {// $$= E_GREATEQ; requires(E_DURATION_INEQUALITIES);
    }
|   EQ       {// $$= E_EQUALS;
    }
;
/* END -- DONE*/	


/* START -- DONE */
c_d_value :
//    Fix: c_number doesn't apparently require E_FLUENTS
//         some needs to be included as separate item.
//    c_number {$$= $1;}
//|   
c_f_exp  {// $$= $1;
};
/* END -- DONE */

/* START -- DONE*/
c_duration_constraints :
c_duration_constraints c_duration_constraint
{
    WARNING("We do not support durational constraints.\n");
    //$$=$1; $$->push_back($2);
}
|   /* empty */ 
{
    WARNING("We do not support durational constraints.\n");
    //$$= new goal_list;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_neg_simple_effect :
OPEN_BRAC NOT c_proposition CLOSE_BRAC 
{
    $$ = new SignedPredicate(*$3);
    $$->makeNegative();
    FAKE_DELETE($3);
}//new simple_effect($3); }
;
/* END -- DONE*/

/* START -- DONE*/
c_pos_simple_effect :
c_proposition
{
    $$ = new SignedPredicate(*$1);
    $$->makePositive();
    FAKE_DELETE($1);
}//new simple_effect($1); }
;
/* END -- DONE*/

/* init versions disallow equality as a predicate */

/*START -- DONE*/
c_init_neg_simple_effect :
OPEN_BRAC NOT c_init_proposition CLOSE_BRAC 
{
    assert($3);
    $$ = $3;
    $$->makeNegative();
    
}//new simple_effect($3); }
;
/*END -- DONE*/

/*START -- DONE*/
c_init_pos_simple_effect :
c_init_proposition
{
    assert($$);
    $$ = $1;
    $$->makePositive();
    
}//new simple_effect($1); }
;
/*END -- DONE*/

/*START -- DONE*/
c_forall_effect :
OPEN_BRAC c_forall OPEN_BRAC c_typed_var_list CLOSE_BRAC c_effect CLOSE_BRAC
{ 
    WARNING("We do not deal with universally quantified effects (c_forall_effect).");
    //$$= new forall_effect($6, $4, current_analysis->var_tab_stack.pop());
}
;
/*END -- DONE*/

/*START -- DONE*/
c_cond_effect :
OPEN_BRAC WHEN c_goal_descriptor c_effects CLOSE_BRAC
{
    WARNING("We do not deal with conditional effects (c_cond_effect).");
    //$$= new cond_effect($3,$4);
}
;
/*END -- DONE*/

/* START -- DONE */
/*We do not support equality, or numerical reasoning of any kind.*/
c_assignment : 
OPEN_BRAC ASSIGN c_f_head c_f_exp CLOSE_BRAC
{
    WARNING("We do not support assignments (c_assignment).");
    //$$= new assignment($3,E_ASSIGN,$4);
}
|  OPEN_BRAC INCREASE c_f_head c_f_exp CLOSE_BRAC
{
    
    WARNING("We do not support assignments (c_assignment).");
    //$$= new assignment($3,E_INCREASE,$4);
}
|  OPEN_BRAC DECREASE c_f_head c_f_exp CLOSE_BRAC
{
    WARNING("We do not support assignments (c_assignment).");
    //$$= new assignment($3,E_DECREASE,$4);
}
|  OPEN_BRAC SCALE_UP c_f_head c_f_exp CLOSE_BRAC
{
    WARNING("We do not support assignments (c_assignment).");
    //$$= new assignment($3,E_SCALE_UP,$4);
}
|  OPEN_BRAC SCALE_DOWN c_f_head c_f_exp CLOSE_BRAC
{
    WARNING("We do not support assignments (c_assignment).");
    //$$= new assignment($3,E_SCALE_DOWN,$4);
}
;
/* END -- DONE */

/* START -- DONE */
c_f_exp : 
OPEN_BRAC HYPHEN c_f_exp CLOSE_BRAC %prec UMINUS  
{ // $$= new uminus_expression($3); requires(E_FLUENTS);
}
|   OPEN_BRAC PLUS c_f_exp c_f_exp CLOSE_BRAC   
{ // $$= new plus_expression($3,$4); requires(E_FLUENTS);
}
|   OPEN_BRAC HYPHEN c_f_exp c_f_exp CLOSE_BRAC
{ // $$= new minus_expression($3,$4); requires(E_FLUENTS);
}
|   OPEN_BRAC MUL c_f_exp c_f_exp CLOSE_BRAC
{ // $$= new mul_expression($3,$4); requires(E_FLUENTS);
}
|   OPEN_BRAC DIV c_f_exp c_f_exp CLOSE_BRAC
{ // $$= new div_expression($3,$4); requires(E_FLUENTS);
}
|   c_number { // $$=$1;
    FAKE_DELETE($1);
    }
|   c_f_head  { // $$= $1; requires(E_FLUENTS);
    }
;
/* END -- DONE */

/* START -- DONE */
c_f_exp_t : 
OPEN_BRAC MUL HASHT c_f_exp CLOSE_BRAC
{ // $$= new mul_expression(new special_val_expr(E_HASHT),$4);
}
|   OPEN_BRAC MUL c_f_exp HASHT CLOSE_BRAC
{ // $$= new mul_expression($3, new special_val_expr(E_HASHT));
}
|   HASHT
{ // $$= new special_val_expr(E_HASHT);
};
/* END -- DONE */

/* START -- DONE */
c_number : 
INTVAL   {
    $$ = new IntAndDouble($1);
    // $$=new int_expression($1);
}
| FLOATVAL { 
    $$ = new IntAndDouble($1);
    // $$=new float_expression($1);
  };
/* END -- DONE */

/* START -- DONE */
c_f_head :
OPEN_BRAC FUNCTION_SYMBOL c_parameter_symbols CLOSE_BRAC
{ // $$=new func_term( current_analysis->func_tab.symbol_get($2), $3); delete [] $2;
}
// "Undeclared function symbol" case
|   OPEN_BRAC NAME c_parameter_symbols CLOSE_BRAC
{ // $$=new func_term( current_analysis->func_tab.symbol_get($2), $3); delete [] $2;
}
|   FUNCTION_SYMBOL
{ // $$=new func_term( current_analysis->func_tab.symbol_get($1),
// 		    new parameter_symbol_list); delete [] $1;
}   
;
/* END -- DONE */

// c_new_f_head :
//     OPEN_BRAC NAME c_parameter_symbol_list CLOSE_BRAC
//         { $$=new func_term( current_analysis->func_tab.symbol_put($2), $3); }
// |   NAME
//         { $$=new func_term( current_analysis->func_tab.symbol_put($1),
//                             new parameter_symbol_list); }   
// ;

/* START -- DONE */
c_ground_f_head :
/* Fix: Should restrict to constants, as in: */
/* NAME c_const_symbols */
/* ... but don't want to return a thing of type const list */

OPEN_BRAC FUNCTION_SYMBOL c_parameter_symbols CLOSE_BRAC 
{ // $$=new func_term( current_analysis->func_tab.symbol_get($2), $3); delete [] $2;
}
|   OPEN_BRAC NAME c_parameter_symbols CLOSE_BRAC
{ // $$=new func_term( current_analysis->func_tab.symbol_get($2), $3); delete [] $2;
}
|   FUNCTION_SYMBOL
{ // $$=new func_term( current_analysis->func_tab.symbol_get($1),
// 		    new parameter_symbol_list); delete [] $1;
}   
;
/* END -- DONE */

/* START -- DONE */
c_comparison_op : 
GREATER   { // $$= E_GREATER;
}
|  GREATEQ   { // $$= E_GREATEQ;
   }
|  LESS      { // $$= E_LESS;
   }
|  LESSEQ    { // $$= E_LESSEQ;
   }
|  EQ        { // $$= E_EQUALS;
   }
;
/* END -- DONE */

//c_f_comp :
//    OPEN_BRAC c_comparison_op c_f_exp c_f_exp CLOSE_BRAC

// Goals

// FIX: PDDL BNF distinguishes between -ve literals and general -ve goals.
//         (different reqs)



/* The following is what actually gets triggered when we start reading
 * the \rule{c_goal_spec} (goal specification) component of a
 * \rule{problem_body} (problem). This rule is also triggered when
 * parsing an action precondition.*/
/* START -- DONE */
c_pre_goal_descriptor :
c_pref_goal_descriptor
{
    assert($1);
    
    $$ = $1;
 //    /*Make sure that our application supports whatever type of was
//      * parsed (i.e. null test).*/
//     if($1 != 0){
// // 	$$ = new SignedPredicates();
// // 	$$->push_back($1);
// // 	FAKE_DELETE($1);
// 	//$$ = $1;
//     }
    
    VERBOSER(1, "We do not accommodate preferences in goals... However any goal can be\n"
	     <<"parsed as a preference goal.\n");
    
    //$$= $1;
}
|   OPEN_BRAC AND c_pre_goal_descriptor_list CLOSE_BRAC
{
    /*As far as I can tell, we must parse a conjunctive goal in the
      propositional planning case.*/
    
    VERBOSER(1, "Parse propositional goal -- Might also be a precondition."<<endl);

    assert($3);
    
    /*Because we have no choice but to parse a conjunctive goal, I
     * figure we may as-well parse that at the lower level, knowing
     * full well it is going to be a conjunction.*/
    $$ = $3;
    
    //$$ = $3;
    
    //$$ = new conj_goal($3);
}
|   OPEN_BRAC c_forall OPEN_BRAC c_typed_var_list CLOSE_BRAC
c_pre_goal_descriptor CLOSE_BRAC
{
    $$ = 0;
    WARNING("We do not support universal quantification.\n");
    
    //$$= new qfied_goal(E_FORALL,$4,$6,current_analysis->var_tab_stack.pop());
    //requires(E_UNIV_PRECS);
}
| OPEN_BRAC /*empty*/ CLOSE_BRAC  /*No preconditions.*/
{
    $$ = new SignedPredicates();
}
;
/* END -- DONE */

/* START -- DONE*/
c_pref_con_goal :
OPEN_BRAC PREFERENCE c_constraint_goal CLOSE_BRAC 
{
    //$$ = new preference($3);requires(E_PREFERENCES);
}
|   OPEN_BRAC PREFERENCE NAME c_constraint_goal CLOSE_BRAC
{
    //$$ = new preference($3,$4);requires(E_PREFERENCES);
}
|   OPEN_BRAC AND c_pref_con_goal_list CLOSE_BRAC
{
    //$$ = new conj_goal($3);
}
|   OPEN_BRAC c_forall OPEN_BRAC c_typed_var_list CLOSE_BRAC
c_pref_con_goal CLOSE_BRAC
{
    //$$= new qfied_goal(E_FORALL,$4,$6,current_analysis->var_tab_stack.pop());
    //requires(E_UNIV_PRECS);

    VERBOSER(1, "Domain requires UNIVERSAL-PRECONDITIONS (c_pref_con_goal).");  
    problem.domain.requires.universallyQuantifiedPreconditions = true;
}
|   c_constraint_goal
{
    //$$ = $1;
};
/* END -- DONE */

/* START -- DONE*/
c_pref_con_goal_list :
c_pref_con_goal_list c_pref_con_goal
{
    VERBOSER(1, "We don't deal with preferences (c_pref_con_goal_list).\n");
    //$$=$1; $1->push_back($2);
}
|	/* empty */
{
    VERBOSER(1, "We don't deal with preferences (c_pref_con_goal_list).\n");
    //$$= new goal_list;
}
;
/* END -- DONE*/

/* START -- DONE (don't let the "pref" in the name fool you, preferences are ignored...)*/	
c_pref_goal_descriptor :
OPEN_BRAC PREFERENCE c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with preferences (c_pref_goal_descriptor).\n");
    //$$= new preference($3); requires(E_PREFERENCES);
    $$ = NULL;
}
|   OPEN_BRAC PREFERENCE NAME c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with preferences (c_pref_goal_descriptor).\n");
    //$$= new preference($3,$4); requires(E_PREFERENCES);
    $$ = NULL;
}
|	c_goal_descriptor
{
    VERBOSER(1, "Using rule for goal with preferences (\rule{c_pref_goal_descriptor})"<<endl
	    <<"to parse ordinary \rule{c_goal_descriptor}.");
    //VERBOSE("We don't deal with preferences (c_pref_goal_descriptor).\n");

    assert($1);
    
    $$ = $1;
    
    //$$=$1;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_constraint_goal_list :
c_constraint_goal_list c_constraint_goal
{
    VERBOSE("We don't deal with constraints as part of the goal (c_pref_goal_descriptor).\n");
    //$$ = $1; $$->push_back($2);
}
|   /* Empty */
{
    VERBOSE("We don't deal with constraints as part of the goal (c_pref_goal_descriptor).\n");
    //$$ = new goal_list;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_constraint_goal :
OPEN_BRAC AND c_constraint_goal_list CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$= new conj_goal($3);
}
|	OPEN_BRAC c_forall OPEN_BRAC c_typed_var_list CLOSE_BRAC c_constraint_goal CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    VERBOSER(1, "Domain requires UNIVERSAL-PRECONDITIONS (c_constraint_goal).");  
    problem.domain.requires.universallyQuantifiedPreconditions;
    // $$ = new qfied_goal(E_FORALL,$4,$6,current_analysis->var_tab_stack.pop());
    // requires(E_UNIV_PRECS);
}
|	OPEN_BRAC AT_END c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_ATEND,$3);
}
|   OPEN_BRAC ALWAYS c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_ALWAYS,$3);
}
| 	OPEN_BRAC SOMETIME c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_SOMETIME,$3);
}
|	OPEN_BRAC WITHIN c_number c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    FAKE_DELETE($3);
    // $$ = new constraint_goal(E_WITHIN,$4,NULL,$3->double_value(),0.0);delete $3;
}
|	OPEN_BRAC ATMOSTONCE c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_ATMOSTONCE,$3);
}
|	OPEN_BRAC SOMETIMEAFTER c_goal_descriptor c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_SOMETIMEAFTER,$4,$3);
}
|	OPEN_BRAC SOMETIMEBEFORE c_goal_descriptor c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    // $$ = new constraint_goal(E_SOMETIMEBEFORE,$4,$3);
}
|   OPEN_BRAC ALWAYSWITHIN c_number c_goal_descriptor c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    FAKE_DELETE($3);
    // $$ = new constraint_goal(E_ALWAYSWITHIN,$5,$4,$3->double_value(),0.0);delete $3;
}
| 	OPEN_BRAC HOLDDURING c_number c_number c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    FAKE_DELETE($3);
    FAKE_DELETE($4);
    // $$ = new constraint_goal(E_HOLDDURING,$5,NULL,$4->double_value(),$3->double_value());delete $3;delete $4;
}
|   OPEN_BRAC HOLDAFTER c_number c_goal_descriptor CLOSE_BRAC
{
    WARNING("We don't deal with constraints as part of the goal (c_constraint_goal).\n");
    FAKE_DELETE($3);
    // $$ = new constraint_goal(E_HOLDAFTER,$4,NULL,0.0,$3->double_value());delete $3;
}
;
/* END -- DONE*/

/* ACTION PRECONDITIONS and GOAL ---- Originally I would have thought
 * that a "goal_descriptor" rule would be used to parse things to do
 * with the PDDL goal. Turns out that an action precondition is parsed
 * as a goal. */
/* START -- DONE*/
c_goal_descriptor : 
c_proposition 
{

    $$ = new SignedPredicates();
    $$->push_back($1);
    //FAKE_DELETE($1);
}
|  OPEN_BRAC NOT c_goal_descriptor CLOSE_BRAC 
{
    /*Because we eventually have to support negative preconditions for
     * an action, we are going to have to support this rule. That
     * means that we are going to have that the
     * \rule{c_goal_descriptor} has a more elaborate type than simply
     * \type{Proposition}.*/

    $$ = $3;
    
    for(SignedPredicates::iterator p = $$->begin()
	    ; p != $$->end()
	    ; p++){
	(*p)->changeSign();
	
	if((*p)->getName() == "="){
	    problem.domain.requires.equality = true;
	} else {
	    problem.domain.requires.negativePreconditions = true;
	}
    }
    
    WARNING("We do not support negative preconditions, or equality"<<endl
	    <<" reasoning. So get the \"NOT\" out of the goal.");
}
|  OPEN_BRAC AND c_goal_list CLOSE_BRAC 
{
    WARNING("We only support one conjunction in the goal.\n");
    $$ = 0;
    //$$= new conj_goal($3);
}
|  OPEN_BRAC OR c_goal_list CLOSE_BRAC  
{
    $$ = 0;
    WARNING("We do not support disjunction in goals (c_goal_descriptor).\n");
//     $$= new disj_goal($3);
//     requires(E_DISJUNCTIVE_PRECONDS);
    problem.domain.requires.disjunctivePreconditions = true;
}
|  OPEN_BRAC IMPLY c_goal_descriptor c_goal_descriptor CLOSE_BRAC 
{
    $$ = 0;
    WARNING("We do not support implications in goals (c_goal_descriptor).\n");

    
    problem.domain.requires.disjunctivePreconditions = true;
//     $$= new imply_goal($3,$4);
//     requires(E_DISJUNCTIVE_PRECONDS);
}
|  OPEN_BRAC c_quantifier OPEN_BRAC c_typed_var_list CLOSE_BRAC 
c_goal_descriptor CLOSE_BRAC 
{
    $$ = 0;
    WARNING("We do not support quantification in goals (c_goal_descriptor).\n");
    
    //$$= new qfied_goal($2,$4,$6,current_analysis->var_tab_stack.pop());
}
|  OPEN_BRAC c_comparison_op c_f_exp c_f_exp CLOSE_BRAC 
{
    //$$= new comparison($2,$3,$4);

    WARNING("We do not support fluents (c_goal_descriptor).\n");
    $$ = 0;
    problem.domain.requires.fluents = true;
    
    //requires(E_FLUENTS);
}
;
/* END -- DONE*/


/*The following is what actually gets triggered (transitively via
 * \rule{c_pre_goal_descriptor}) when we start reading the
 * \rule{c_goal_spec} (goal specification) component of a
 * \rule{problem_body} (problem). Also gets triggered for action
 * preconditions.*/ 

/* START -- DONE */
c_pre_goal_descriptor_list :
c_pre_goal_descriptor_list c_pre_goal_descriptor
{
    /*I have decided to parse the goal directly.*/
//     problem.goal.push_back();
//     $$=$1;
//     $1->push_back($2);
    assert($1);
    
    $$ = $1;
    $$->insert($$->begin(), $2->begin(), $2->end());
    FAKE_DELETE($2);
}
|	/* empty */
{
    /*New list of facts.*/
    $$ = new SignedPredicates();
}
;
/* END -- DONE */

/* START -- DONE */
c_goal_list :
c_goal_list c_goal_descriptor
{}
|   /* empty */
{}
;
/* END -- DONE */

/* START -- DONE */
c_quantifier : 
c_forall {
    //$$=$1;
}
|   c_exists {
    //$$=$1;
    }
;
/* END -- DONE */

/* START -- DONE */
c_forall :
FORALL 
{// $$=E_FORALL; 
//     current_analysis->var_tab_stack.push(
// 	current_analysis->buildForallTab());
}
;
/* END -- DONE */

/* START -- DONE */
c_exists :
EXISTS 
{// $$=E_EXISTS;
//     current_analysis->var_tab_stack.push(
// 	current_analysis->buildExistsTab());
}
;
/* END -- DONE */

/* START -- DONE*/
c_proposition : 
OPEN_BRAC c_pred_symbol c_parameter_symbols CLOSE_BRAC
{
    /*It may indeed no longer be the case that
     * \at{c_parameter_symbols} (\union{parameters}) we have all
     * constants.*/

    $$ = NULL;

    /*Are all the parameters to the predicate symbol \type{Constant}?*/
    bool allConstant = true;
    for(Parameters::iterator p = $3->begin(); allConstant && p != $3->end(); p++){
	if(!dynamic_cast<Constant*>(*p)){
	    allConstant = false;
	}
    }

    /*If all the arguments are constant make a predicate. Otherwise
     * make a proposition. */
    if(allConstant){
	$$ = new SignedProposition(*$2, *$3);
    } else {
	$$ = new SignedPredicate(*$2, *$3);
    }

    $$->makePositive();
    
    FAKE_DELETE($2);
    FAKE_DELETE($3);

    assert($$);
};
/* END -- DONE*/




/* START -- DONE*/
c_derived_proposition :
OPEN_BRAC c_pred_symbol c_typed_var_list CLOSE_BRAC
{
    WARNING("We do not support derived propositions or predicates (c_derived_proposition).\n");

    //$$ = NULL;
    // $$ = new proposition($2,$3);
}
;
/* END -- DONE*/

/* START -- DONE -- Copy and paste from \rule{c_proposition}.*/
c_init_proposition : 
OPEN_BRAC c_init_pred_symbol c_parameter_symbols CLOSE_BRAC 
{
    Constants constants;
    for(Parameters::iterator p = $3->begin(); p != $3->end(); p++){
	assert(dynamic_cast<Constant*>(*p));

	constants.push_back(*dynamic_cast<Constant*>(*p));

	/*It is up to the signed proposition to delete the constant symbol.*/
	//FAKE_DELETE(*p);
    }
    
    
    $$ = new SignedProposition(*$2,constants);
    
    FAKE_DELETE($3);
    FAKE_DELETE($2);

    //$$=new proposition($2,$3);
}
;
/* END -- DONE*/


/* START -- DONE */
c_predicates : 
OPEN_BRAC PREDS c_pred_decls CLOSE_BRAC 
{}
|   OPEN_BRAC PREDS error CLOSE_BRAC
{
    yyerrok;
    //$$=NULL;
    UNRECOVERABLE_ERROR("Empty predicate declaration (c_predicates).");
    //log_error(E_FATAL,"Syntax error in (:predicates ...)");
}
;
/* END -- DONE */

/* START -- DONE */
c_functions_def : 
OPEN_BRAC FUNCTIONS c_func_decls CLOSE_BRAC 
{
    WARNING("Don't support functions (c_functions_def).\n");
    //$$= $3;
}
|   OPEN_BRAC FUNCTIONS error CLOSE_BRAC
{
    WARNING("Don't support functions (c_functions_def).\n");
    yyerrok;
    //$$=NULL;
    WARNING("Syntax error in (:functions ...).");
//     log_error(E_FATAL,"Syntax error in (:functions ...)");
}
;
/* END -- DONE */

/* START -- DONE */
c_constraints_def :
OPEN_BRAC CONSTRAINTS c_constraint_goal CLOSE_BRAC
{
    WARNING("Don't support constraints (c_constraints_def).\n");
    //$$ = $3;
}
| OPEN_BRAC CONSTRAINTS error CLOSE_BRAC
{
    yyerrok;
    
    WARNING("Don't support constraints (c_constraints_def).\n");
    //$$=NULL;
    WARNING("Syntax error in (:constraints ...).");
    
    //log_error(E_FATAL,"Syntax error in (:constraints ...)");
}
;
/* END -- DONE */

/* START -- DONE */
c_constraints_probdef :
OPEN_BRAC CONSTRAINTS c_pref_con_goal CLOSE_BRAC
{
    WARNING("Don't support constraints (c_constraints_def).\n");
    //$$ = $3;
}
| OPEN_BRAC CONSTRAINTS error CLOSE_BRAC
{
    WARNING("Don't support constraints (c_constraints_def).\n");
    yyerrok;
    
    WARNING("Syntax error in (:constraints ...).");
    //$$=NULL;
    //log_error(E_FATAL,"Syntax error in (:constraints ...)");
}
;
/* END -- DONE */

/*Events, actions, processes, durative actions, and derivation rules
 * (probably for derived predicates) all come into their own
 * here. This rules just unwinds the list of such things.*/
/* START -- DONE */
c_structure_defs : 
c_structure_defs c_structure_def {
    //$$=$1; $$->push_back($2);
}
|   c_structure_def  {
    //$$= new structure_store; $$->push_back($1);
    }
;
/* END -- DONE */

/* START -- DONE */
c_structure_def :
c_action_def          {
    VERBOSER(1, "Parsed action definition (c_structure_def).\n");
}
|   c_event_def           {
    WARNING("We do not support domain events (c_structure_def).");
    // $$= $1; requires(E_TIME);
    }
|   c_process_def         {
    WARNING("We do not support domain processes (c_structure_def).");
    // $$= $1; requires(E_TIME);
    }
|   c_durative_action_def {
    WARNING("We do not support durative actions (c_structure_def).");
    // $$= $1; requires(E_DURATIVE_ACTIONS);
    }
|   c_derivation_rule     {
    WARNING("We do not support durative rules (c_structure_def).");
    // $$= $1; requires(E_DERIVED_PREDICATES);
    }
;
/* END -- DONE */

/* START -- DONE */
c_rule_head :
DERIVED {

    WARNING("We do not support derived predicates.\n");
//     $$= 0; 
//     current_analysis->var_tab_stack.push(
// 	current_analysis->buildRuleTab());
}
;
/* END -- DONE */

/* START -- DONE */
c_derivation_rule :
OPEN_BRAC
c_rule_head
c_derived_proposition
c_goal_descriptor
CLOSE_BRAC
{
    WARNING("We do not support derived predicates.\n");
    //$$ = new derivation_rule($3,$4,current_analysis->var_tab_stack.pop());
}
;
/* END -- DONE */


/* START -- DONE */
c_action_def :
OPEN_BRAC 
ACTION
NAME
c_args_head OPEN_BRAC c_typed_var_list CLOSE_BRAC
PRE c_pre_goal_descriptor 
EFFECTS c_effect
CLOSE_BRAC
{
    /*Parses a string that looks somewhat like this :: */
    /*( :action STRING
        :parameters ( c_typed_var_list )
	:precondition (c_pre_goal_descriptor)
	:effect (c_effect)) */

    /*In the case that the action cost is determined by grounding a predicate symbol.*/
    if(costEvaluator != 0){
	VERBOSER(26, "Parsed action with variable total cost ::"<<*costEvaluator<<endl);
	
	problem.domain.addAction(*$3, *$6, *$9, *$11, costEvaluator);
    }
    /*The default cost of an action is 1.*/
    else if(totalCost == 0 ){
	VERBOSER(26, "Parsed action with total cost ::"<<totalCost<<endl);
	
	problem.domain.addAction(*$3, *$6, *$9, *$11);
    } else {
	VERBOSER(26, "Parsed action with total cost ::"<<totalCost<<endl);
	
	problem.domain.addAction(*$3, *$6, *$9, *$11, totalCost);
    }
    

    totalCost = 0;
    costEvaluator = 0;
    
    FAKE_DELETE($3);
    FAKE_DELETE($6);
    FAKE_DELETE($9);
    FAKE_DELETE($11);
    
//     $$= current_analysis->buildAction(current_analysis->op_tab.symbol_put($3),
// 				    $6,$9,$11,
// 				    current_analysis->var_tab_stack.pop()); delete [] $3;
}
|   OPEN_BRAC ACTION error CLOSE_BRAC
{
    yyerrok;
    //$$= NULL;
    WARNING("Buggered action description (c_action_def).\n");
    // log_error(E_FATAL,"Syntax error in action declaration.");
}
;
/* END -- DONE */


/* START -- DONE*/
c_event_def :
OPEN_BRAC 
EVENT
NAME /* $3 */
c_args_head OPEN_BRAC c_typed_var_list CLOSE_BRAC
PRE c_goal_descriptor /* $9 */
EFFECTS c_effect /* $11 */
CLOSE_BRAC
{
    WARNING("We do not support event definitions (c_event_def).\n");
//     $$= current_analysis->buildEvent(current_analysis->op_tab.symbol_put($3),
// 				  $6,$9,$11,
// 				  current_analysis->var_tab_stack.pop()); delete [] $3;
}

|   OPEN_BRAC EVENT error CLOSE_BRAC
{
    yyerrok; 
    //log_error(E_FATAL,"Syntax error in event declaration.");
    //$$= NULL;
    WARNING("Syntax error in event declaration.\n");
};
/* END -- DONE*/


/* START -- DONE -- We do not support processes.*/
c_process_def :
OPEN_BRAC 
PROCESS
NAME
c_args_head OPEN_BRAC c_typed_var_list CLOSE_BRAC
PRE c_goal_descriptor 
EFFECTS c_proc_effect
CLOSE_BRAC
{
/*     $$= current_analysis->buildProcess(current_analysis->op_tab.symbol_put($3), */
/* 				    $6,$9,$11, */
/* 				    current_analysis->var_tab_stack.pop()); delete [] $3; */
}
|   OPEN_BRAC PROCESS error CLOSE_BRAC
{
    yyerrok;
    //$$= NULL;
    WARNING("No support for processes.\n");
    
    //log_error(E_FATAL,"Syntax error in process declaration.");
};
/* END -- DONE*/


/* START -- DONE -- We do not support durative actions.*/
c_durative_action_def :
OPEN_BRAC 
DURATIVE_ACTION
NAME /* $3 */
c_args_head OPEN_BRAC c_typed_var_list CLOSE_BRAC
DURATION c_duration_constraint /* $9 */
c_da_def_body
CLOSE_BRAC
{
/*     $$= $10; */
/*     $$->name= current_analysis->op_tab.symbol_put($3); */
/*     $$->symtab= current_analysis->var_tab_stack.pop(); */
/*     $$->parameters= $6; */
/*     $$->dur_constraint= $9;  */
/*     delete [] $3; */
} 
   
|   OPEN_BRAC DURATIVE_ACTION error CLOSE_BRAC
{
    yyerrok;
    WARNING("Empty durative action.\n");
    //log_error(E_FATAL,"Syntax error in durative-action declaration.");
    //$$= NULL;
}
;
/* END -- DONE*/

/* START -- DONE -- We do not support durative actions.*/
c_da_def_body :
c_da_def_body EFFECTS c_da_effect
{// $$=$1; $$->effects=$3;
}
|   c_da_def_body CONDITION c_da_gd
{// $$=$1; $$->precondition=$3;
}
|   /* empty */  {
    // $$= current_analysis->buildDurativeAction();
    }
;  
/* END -- DONE*/  

/*Right the following two rules are for durative actions (I think),
 * and as I don't support those....*/


/* START -- DONE -- We do not support durative actions.*/
c_da_gd :
c_timed_gd 
{ // $$=$1;
    WARNING("We do not support durative actions (c_da_gd).\n");
}
|  OPEN_BRAC AND c_da_gds CLOSE_BRAC
{
    WARNING("We do not support durative actions (c_da_gd).\n");
    // $$= new conj_goal($3);
}
;
/* END -- DONE*/ 

/* START -- DONE -- We do not support durative actions.*/
c_da_gds :
c_da_gds c_da_gd 
{
    WARNING("We do not support durative actions (c_da_gds).\n");
    // $$=$1; $$->push_back($2);
}
|  /* empty */   
{
    WARNING("We do not support durative actions. (c_da_gds)\n");
    // $$= new goal_list;
}
;
/* END -- DONE*/ 

/* START -- DONE -- We do not support timed goals.*/
c_timed_gd :
OPEN_BRAC AT_START c_goal_descriptor CLOSE_BRAC
{// $$= new timed_goal($3,E_AT_START);
}
|   OPEN_BRAC AT_END   c_goal_descriptor CLOSE_BRAC
{// $$= new timed_goal($3,E_AT_END);
}
|   OPEN_BRAC OVER_ALL c_goal_descriptor CLOSE_BRAC
{// $$= new timed_goal($3,E_OVER_ALL);
}
|   OPEN_BRAC PREFERENCE NAME c_timed_gd CLOSE_BRAC
{// timed_goal * tg = dynamic_cast<timed_goal *>($4);
//     $$ = new timed_goal(new preference($3,tg->clearGoal()),tg->getTime());
//     delete tg;
//     requires(E_PREFERENCES);
}
|   OPEN_BRAC PREFERENCE c_timed_gd CLOSE_BRAC
{// $$ = new preference($3);requires(E_PREFERENCES);
}
;
/* END -- DONE*/

/* START -- DONE -- Just reads \string{:parameters} from lexer.*/
c_args_head :
ARGS {
//     $$= 0; current_analysis->var_tab_stack.push(
// 	current_analysis->buildOpTab());
}
;
/* END -- DONE*/

/* START -- DONE */
c_domain_constants : OPEN_BRAC CONSTANTS c_typed_consts CLOSE_BRAC
{

    $$ = $3;
    //problem.domain.addConstants(*$3);
    //FAKE_DELETE($3);
    
    //$$=$3;
}
;
/* END -- DONE*/


/* START -- DONE */
c_type_names : OPEN_BRAC TYPES c_typed_types CLOSE_BRAC
{
    $$=$3;
    problem.domain.requires.typing = true;
    //requires(E_TYPING);
}
;
/* END -- DONE*/


/* START -- DONE */
c_problem : OPEN_BRAC 
DEFINE 
OPEN_BRAC PROBLEM NAME CLOSE_BRAC
OPEN_BRAC FORDOMAIN NAME CLOSE_BRAC
c_problem_body
CLOSE_BRAC {
    
    problem.name = *$5;
    problem.domainName = *$9;

    FAKE_DELETE($5);
    FAKE_DELETE($9);
}
|   OPEN_BRAC DEFINE OPEN_BRAC PROBLEM error {
    yyerrok;
    WARNING("syntax error in _problem_ definition (c_problem).\n");
}
;
/* END -- DONE*/

/* START -- DONE */
c_problem_body : 
c_domain_require_def c_problem_body {

    VERBOSER(1, "Problem requirement parsed.\n");
}
|    c_objects c_problem_body       {
    problem.setObjects($1);
}
|    c_initial_state c_problem_body {

    VERBOSER(1, "Parsed starting state :: "<<*$1<<endl);
    
    problem.setStartingState(*$1);
    
    for_each($1->begin(), $1->end(), delete_pointers<SignedPredicate>());
    FAKE_DELETE($1);
}
|    c_goal_spec c_problem_body     {
    
    problem.setGoal(*$1);

    /*Clean up.*/
    for_each($1->begin(), $1->end(), delete_pointers<SignedPredicate>());
    FAKE_DELETE($1);
    
}
| c_constraints_probdef c_problem_body 
{
    WARNING("We do not accept constraints (c_constraints_probdef).\n");
}
|    c_metric_spec c_problem_body   {
    
    WARNING("We do not accept constraints (c_constraints_probdef).\n");
    //$$=$2;
    //$$->metric= $1;
}
|    c_length_spec c_problem_body   {
    //$$=$2;
    //$$->length= $1;
}
|   /* Empty */                     {

    VERBOSER(1, "Currently we are only able to handle one problem at a time.");
    //problem = Problem();
    
    //$$=new problem;
     }
;
/* END -- DONE*/



/* START -- DONE*/
c_objects : OPEN_BRAC OBJECTS c_typed_consts CLOSE_BRAC {
    $$ = $3;
};
/* END -- DONE*/

/* START -- DONE*/
c_initial_state : OPEN_BRAC INITIALLY c_init_els CLOSE_BRAC {
    //$$=$3;

    $$ = $3;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_goals : GOALS {
    VERBOSER(1, "We parsed \":goals\" keyword.\n");
    //$$ = current_analysis->buildOpTab();
    
}
;
/* END -- DONE*/


/* START -- DONE*/
c_goal_spec : OPEN_BRAC c_goals c_pre_goal_descriptor CLOSE_BRAC {
    /*We have at \at{c_goals} a placeholder for \":goals\" keyword.*/
    
    $$=$3;
    
    //delete $2;
}
;
/* END -- DONE*/


/* START -- DONE*/
c_metric_spec : 
OPEN_BRAC METRIC c_optimization c_ground_f_exp CLOSE_BRAC
{
    WARNING("We do not support metric specifications.\n");
    //$$= new metric_spec($3,$4);
}
|  OPEN_BRAC METRIC error CLOSE_BRAC
{
    yyerrok;
    WARNING("We do not support metric specifications.\n");
    WARNING("Syntax error in metric declaration.");
    
    //log_error(E_FATAL,"Syntax error in metric declaration.");
    //$$= NULL;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_length_spec :
OPEN_BRAC LENGTH c_length_field CLOSE_BRAC
{
    /* Just calls \rule{c_length_field} which is specific to
     * \global{problem}'s \member{serialPlanLength} and
     * \member{parallelPlanLength}*/
    
    //$$= $3;
}
;
/* END -- DONE*/

/* START -- DONE*/
c_length_field :
SERIAL   INTVAL {
    problem.serialPlanLength = $2;
    //$$= new length_spec(E_SERIAL,$2);
}
PARALLEL INTVAL {
    problem.parallelPlanLength = $2;
    //$$= new length_spec(E_PARALLEL,$2);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_optimization :
MINIMIZE {
    
    WARNING("We do not support optimisation conditions (c_optimization).\n");
    //$$= E_MINIMIZE;
}
|  MAXIMIZE {
    
    WARNING("We do not support optimisation conditions (c_optimization).\n");
    //$$= E_MAXIMIZE;
   }
;
/* END -- DONE*/


/* START -- DONE*/
c_ground_f_exp :
OPEN_BRAC c_binary_ground_f_exp CLOSE_BRAC {
    // $$= $2;
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
}
|   c_ground_f_head {
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
    // $$= $1;
    }
|   c_number {
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
    FAKE_DELETE($1);
    // $$= $1;
    }
|   TOTAL_TIME {
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
    // $$= new special_val_expr(E_TOTAL_TIME);
    }
|   OPEN_BRAC ISVIOLATED NAME CLOSE_BRAC
{
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
    // $$ = new violation_term($3);
}
|  OPEN_BRAC TOTAL_TIME CLOSE_BRAC {
    WARNING("We do not support function expressions (c_ground_f_exp).\n");
    // $$= new special_val_expr(E_TOTAL_TIME);
}
;
/* END -- DONE*/

/* START -- DONE*/
c_binary_ground_f_exp :
PLUS c_ground_f_exp c_binary_ground_f_pexps   {
    WARNING("We do not support function expressions (c_binary_ground_f_exp).\n");
    // $$= new plus_expression($2,$3);
}
|   HYPHEN c_ground_f_exp c_ground_f_exp {
    WARNING("We do not support function expressions (c_binary_ground_f_exp).\n");
    // $$= new minus_expression($2,$3);
}
|   MUL c_ground_f_exp c_binary_ground_f_mexps    {
    WARNING("We do not support function expressions (c_binary_ground_f_exp).\n");
    // $$= new mul_expression($2,$3);
}
|   DIV c_ground_f_exp c_ground_f_exp    {
    WARNING("We do not support function expressions (c_binary_ground_f_exp).\n");
    // $$= new div_expression($2,$3);
}
;
/* END -- DONE*/


/* BEGIN -- DONE*/
c_binary_ground_f_pexps :
c_ground_f_exp {
    // $$ = $1;
    WARNING("We do not support function expressions (c_binary_ground_f_pexps).\n");
}
|	c_ground_f_exp c_binary_ground_f_pexps 
{
    // $$ = new plus_expression($1,$2);
    WARNING("We do not support function expressions (c_binary_ground_f_pexps).\n");
}
;
/* END -- DONE*/

/* BEGIN -- DONE*/
c_binary_ground_f_mexps :
c_ground_f_exp {
    WARNING("We do not support function expressions (c_binary_ground_f_mexps).\n");
    //$$ = $1;
}
|	c_ground_f_exp c_binary_ground_f_mexps 
{
    WARNING("We do not support function expressions (c_binary_ground_f_mexps).\n");
    // $$ = new mul_expression($1,$2);
}
;
/* END -- DONE*/



// Charles Gretton :: Wed Oct 31 11:24:41 EST 2007 :: Plans -- there
// used to be a bunch of rules ('n'stuff) here for parsing plans which
// I have deleted.



/*START -- DONE -- A float is a double.*/
c_float :
FLOATVAL {$$= $1;}
|   INTVAL   {$$= (float) $1;}
;
/*END -- DONE*/


/*START -- DONE*/
c_require_key: 
EQUALITY {
    VERBOSER(1, "Domain requires EQUALITY (c_require_key).");
    problem.domain.requires.equality = true;
}
| ACTION_COSTS
{
    VERBOSER(18, "Domain requires ACTION_COSTS (c_require_key).")
    problem.domain.requires.actionCosts = true;
}
| STRIPS {
    VERBOSER(1, "Domain requires STRIPS (c_require_key).");
    problem.domain.requires.strips = true;
  }
| TYPING {
    VERBOSER(1, "Domain requires TYPES (c_require_key).");
    problem.domain.requires.typing = true;
  }
| NEGATIVE_PRECONDITIONS {
    VERBOSER(1, "Domain requires NEGATIVE-PRECONDITIONS (c_require_key).");
    problem.domain.requires.negativePreconditions = true;
}
| DISJUNCTIVE_PRECONDS {
    VERBOSER(1, "Domain requires DISJUNCTIVE-PRECONDITIONS (c_require_key).");  
    problem.domain.requires.disjunctivePreconditions = true;
}
| EXT_PRECS {
    VERBOSER(1, "Domain requires EXISTENTIAL-PRECONDITIONS (c_require_key).");  
    problem.domain.requires.existentiallyQuantifiedPreconditions = true;
  }
| UNIV_PRECS {
    VERBOSER(1, "Domain requires UNIVERSAL-PRECONDITIONS (c_require_key).");  
    problem.domain.requires.universallyQuantifiedPreconditions = true;
  }
| COND_EFFS {
    VERBOSER(1, "Domain requires CONDITIONAL-EFFECTS (c_require_key).");  
    problem.domain.requires.conditionalEffects = true;
  }
| FLUENTS {
    VERBOSER(1, "Domain requires FLUENTS (c_require_key).");  
    problem.domain.requires.fluents = true;
  }
| DURATIVE_ACTIONS { 
    VERBOSER(1, "Domain requires DURATIVE-ACTIONS (c_require_key).");  
    problem.domain.requires.durativeActions = true;
}
| TIME {
    VERBOSER(1, "Domain requires TIM, FLUENTS, DURATIVE-ACTIONS (c_require_key).");  
    problem.domain.requires.time = true;
    problem.domain.requires.fluents = true;
    problem.domain.requires.durativeActions = true;
  }
| ADL { 
    VERBOSER(1, "Domain requires STRIPS, TYPING, NEGATIVE-PRECONDITIONS,"<<endl
	     <<"DISJUNCTIVE-PRECONDITIONS, EQUALITY, EXISTENTIAL-QUANTIFICATION"<<endl
	     <<"UNIVERSAL-QUANTIFICATION, CONDITIONAL-EFFECTS (c_require_key).");  
    problem.domain.requires.strips = true;
    problem.domain.requires.typing = true;
    problem.domain.requires.negativePreconditions = true;
    problem.domain.requires.disjunctivePreconditions = true;
    problem.domain.requires.equality = true;
    problem.domain.requires.existentiallyQuantifiedPreconditions = true;
    problem.domain.requires.universallyQuantifiedPreconditions = true;
    problem.domain.requires.conditionalEffects = true;
}
| QUANT_PRECS {
    VERBOSER(1, "Domain requires existential quantification (c_require_key).");
    problem.domain.requires.existentiallyQuantifiedPreconditions = true;
    problem.domain.requires.universallyQuantifiedPreconditions = true;
  }
| DURATION_INEQUALITIES{
    VERBOSER(1, "Domain requires duration inequalities (c_require_key).");
    problem.domain.requires.durationInequalities = true;
}
| CONTINUOUS_EFFECTS{
    VERBOSER(1, "Domain requires continuous effects (c_require_key).");
    problem.domain.requires.continuousEffects = true;
  }
| DERIVED_PREDICATES {
    VERBOSER(1, "Domain requires derived predicates (c_require_key).");
    problem.domain.requires.derivedPredicates = true;
  }
| TIMED_INITIAL_LITERALS{
    VERBOSER(1, "Domain requires timed literals (c_require_key).");
    problem.domain.requires.timedInitialLiterals = true;
  }
| PREFERENCES {
    VERBOSER(1, "Domain requires preferences (c_require_key).");
    problem.domain.requires.preferences = true;
  }
| CONSTRAINTS {
    VERBOSER(1, "Domain requires constants (c_require_key).");
    problem.domain.requires.constraints = true;
  }
| NAME {
    WARNING("Unrecognised requirements key in domain specification (c_require_key).");
}
;
/*END -- DONE*/

%%

    /*Postfix for files generated by bison.*/


#include <cstdio>
#include <iostream>
int line_no= 1;
using std::istream;
#include "lex.yy.cc"

namespace VAL
{
    yyFlexLexer* yfl;
}


void initialiseLexer(istream* arg_yyin, ostream* arg_yyout)
{
    VAL::yfl = new yyFlexLexer(arg_yyin, arg_yyout);
}

void deleteLexer()
{
    FAKE_DELETE(VAL::yfl);
}

int yyerror(char * s)
{
    return 0;
}

int yylex()
{
    return VAL::yfl->yylex();
}
