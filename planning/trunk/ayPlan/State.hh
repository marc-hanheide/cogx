// Copyright (c) 2008 National ICT Australia Limited (NICTA)
//
// Author: Charles Gretton (charles.gretton@nicta.com.au)
//
// Redistribution and use in source and binary forms, with or without
// modification and only for non-commercial research and educational
// purposes are permitted provided that the conditions in the
// accompanying file "licence.txt" are met.

#ifndef STATE_HH
#define STATE_HH

#include "GroundAction.hh"


/*The type of the elements in the bit vector of a \class{State} --
 *Should be an unsigned integer.*/
#define ELEM_TYPE unsigned int //unsigned char
//#define ELEM_TYPE unsigned int

/*Number of bits in each element of the bitvector*/
#define SIZE_ELEM (sizeof(ELEM_TYPE) * 8)

#define CEIL(X) ( X % SIZE_ELEM )?( ( X / SIZE_ELEM ) + 1):(X / SIZE_ELEM)
#define FLOOR(X) X / SIZE_ELEM
#define REMAINDER(X) X % SIZE_ELEM

namespace Planning
{
    /* For the purposes of propositional planning, a state is uniquely
     * identified by the set of propositions that characterise it
     * \member{data}. Hashing and comparison members are based solely
     * on \member{data}.
     * 
     * This datastructure also implements the graph underlying a forward
     * search state-based planner. In deterministic planning, each
     * state is achieved via a single parent state
     * \member{parent}. \member{successorToAction} describe how every
     * state that is a successor of \member{*this} is achieved by the
     * available actions \member{plannerActions}.*/
    template<typename GroundActionType = GroundAction>
    class State
    {
    public:
	/* Virtual destructor required because a \class{State} has
	 * virtual member functions.*/
	virtual ~State(){};

	/* When an action is executed, it yields a successor
	 * state. When a successor state has been discovered or
	 * identified, then we can inform this state via a call to
	 * this member function. \argument{uint} is the action index,
	 * \argument{State} is the successor. Call modifies
	 * \member{successorToAction}.*/
	virtual void actionYields(uint, State<GroundActionType>*);

	/* A state needs to know who its parent is so that we can
	 * extract the plan once a goal is found. This pointer is to a
	 * states preferred parent, according to whatever metric the
	 * planner is using to "prefer" a parent. (see \member{getParent()})*/
	void setParent(State<GroundActionType>*);

	/* A parent is a \class{State} that the planner has deemed to
	 * be the best way of getting to \member{*this}. (see
	 * \member{setParent()})*/
	const State* getParent() const{return parent;};

	/* A hash_set (hashing on \member{data}) of state pointers for
	 * this type will have the following type. */
	typedef tr1::unordered_set<State<GroundActionType>*,
				   deref_hash<State<GroundActionType> >,
				   deref_equal_to<State<GroundActionType> > > SetOfStatePointers;
	
	/* Remove any references to the \argument{setOfStatePointers}
	 * from \member{successorToAction}.*/
	void removeStateReferences(const SetOfStatePointers& setOfStatePointers);


	/* Type to map a state pointer to an index (i.e., the index of
	 * an action for example).*/
	typedef tr1::unordered_map<State<GroundActionType>*,
				   uint,
				   tr1::hash<State<GroundActionType>*> > MapStatePointerToUint;

    

	/* All states that we have discovered to be reachable from
	 *  \member{*this} occur in the domain of this map. The range
	 *  is indices into \member{plannerActions}.
	 * 
	 * Interface: Elements are added by calls to
	 * \member{actionYields()}. Elements are removed by calls to
	 * \member{removeStateReferences()}.*/
	MapStatePointerToUint successorToAction;

	/* Pointer to the (best) state from which this was
	 * generated. This points to the predecessor in a plan.*/
	State<GroundActionType>* parent;

	/* DEPRECATED AND PROBABLY BROKEN : Accessors for the number
	 * of plan-steps that are believed to be necessary to get to
	 * this state.*/
	uint getTime()const;
	void setTime(uint);
	
	/* For every action (\argument{vector<GroundActionType>}),
	 * test if the action is executable in this state. Results
	 * stored in \member{actions}.*/
	void ComputePossibleActions(const vector<GroundActionType>&);

	/* Given the \member{actions} that are purported to be
	 * executable in this state, and the propositions that have
	 * changed (\member{changed}), validate (and remove if
	 * invalid) the set of \member{actions} that are executable in
	 * this state.*/
	void UpdatePossibleActions();

	/* Typically a state is generated by executing an action in a
	 * predecessor state. Here we store the list of propositions
	 * that are added and deleted from the predecessor in this
	 * state.*/
	vector<uint> propositionsChanged;

	/* Is the \argument{GroundActionType} executable in this state?*/
	bool possible(const GroundActionType&) const;
	
	/* Generate the state that is achived when we execute
	 * \argument{GroundActionType} in this state. NOTE: This
	 * function asserts that its argument is executable.*/
	State<GroundActionType> execute(const GroundActionType&) const;
	
	/* (as above). The result is passed as an argument.*/
	State<GroundActionType>& execute(const GroundActionType& groundAction,
					 State<GroundActionType>& result) const;
	
	/* (as for \member{execute(const GroundActionType&) const})
	 * only the delete effects of actions are ignored. Useful for
	 * pruning propositions which we can cheaply decides are
	 * irrelevant.*/
	State<GroundActionType> execute_noDeleteEffects(const GroundActionType& groundAction) const;
	
	/* (as above). The result is passed as an argument.*/
	State<GroundActionType>& execute_noDeleteEffects(const GroundActionType& groundAction,
							 State<GroundActionType>& result) const;
	
	/* Indices of actions (in \module{Planner} see
	 * \member{Planner::actions} or equivalently
	 * \member{plannerActions}) that are executable in this
	 * state.*/
	SetOfUnsignedInts actions;
	
	/* Initially nothing is true (all bits in \member{data} are
	 * false). \argument{size} is the number of propositions that
	 * this state is required to keep the truth value of. If this
	 * constructor is called the state will have no
	 * \member{parent} (initialised to NULL). Also,
	 * \memeber{isGoalState} is \false.*/
	State(uint size = 0);

	/* Copy construction clones \member{numPropositions},
	 *  \member{data}, \member{time} and
	 * \member{actions}. NOTE: We DO NOT copy
	 * \member{propositionsChanged}.*/
	State(const State&);

	/* This clones the same elements as the copy constructor.*/
	State<GroundActionType>& operator=(const State<GroundActionType>&);
	
	/* Comparison is based on the size of \member{data} first, and
	 * then on the actual elements in \memeber{data}.*/
	bool operator==(const State<GroundActionType>& state) const;
	bool operator<(const State<GroundActionType>& state) const;
	
	/* Change individual (at index \argument{uint}) bits of the
	 * state representation (\member{data}).*/
	inline void flipOn(uint);/*to \true*/
	inline void flipOff(uint);/*to \false*/
	inline void flip(uint);/*to \opposite*/

	/* Is proposition \argument{uint} \true?*/
	inline bool isTrue(uint) const;
	
	/* Is proposition \argument{uint} \false?*/
	inline bool isFalse(uint in) const {return !isTrue(in);};
	
	/* Are we in the goal state? Argument reflects the goal. There
	 * is a 1 in the argument bitvector for every proposition that
	 * is supposed to be true in the goal.*/
	bool isGoal_positive(const vector<ELEM_TYPE>&) const;
	
	/* Are we in the goal state? Argument reflects the goal. There
	 * is a 1 in the argument bitvector for every proposition that
	 * is supposed to be false in the goal.*/
	bool isGoal_negative(const vector<ELEM_TYPE>&) const;

	/*Is this state a goal state? A planner can choose to mark
	 * states as being goals or otherwise.*/
	bool isGoalState;

	/*DEPRECATED: This class is derived from a state class that I
	 * used in a local search procedure for SAT I wrote a while
	 * back (2006). At that time it was useful to be able to
	 * generate semi-randomised states. I doubt this procedure
	 * will be useful for planning. */
	void randomize();

	/*Hashing is either via \library{boost} or \library{TR1}. The
	 * hash is generated from \member{data}.*/
	size_t hash_value() const;

	/*(see \member{numPropositions}).*/
	uint getNumPropositions() const {return numPropositions;};

	/* Causes the argument bitvector to be equal to
	 * \member{data}. This is a way of making a bitvector
	 * representation of the state without all the baggage
	 * associated with a \class{State}.*/
	void mimick(vector<ELEM_TYPE>& input) const {input = data;};	
	
	/* Static elements from the planner (see
	 * \class{Planner}). These are initialised during the
	 * construction of a \class{Planner}. */
	static vector<Proposition<> >* fluentPropositions;
	static vector<GroundActionType>* plannerActions;
	static MapStringToPairInt* propositionIndices;
	static Problem* problem;
	static vector<Proposition<> >* propositions;

	/* All bits are 1.*/
	static const ELEM_TYPE big = -1;
	
	/* See \module{Planner::make_setActionPossibilities}. Maps the
	 * index-to-a-proposition, to the indices-of-actions that
	 * mention that proposition in their precondition.*/
	static MapIntToInts propositionsAllowsActions;

	/* Vector length of the bitvector. Returns the number of
	 * \macro{ELEM_TYPE} entries in private \member{data}.*/
	uint size() const {return data.size();}

	/* Bit vector characterising the truth values of propositions
	 * at this state. 1 is true, 0 is false*/
	const vector<ELEM_TYPE>& getData() const {return data;};

        /*Compress the representation of this state.*/
        void compress();

        /*Uncompress the representation of this state.*/
        void decompress();
        
    protected:
        /*Is this state currently stored in a compressed representation?*/
        bool compressed;/*A state is never initially (i.e., by
                         *  construction) compressed.*/

        /*Compressed representation of the state. Only valid if
         * \member{compressed} is TRUE.*/
        unsigned char* compressed_representation;

        /*How many elements are in the \member{compressed_representation} array?*/
        uint compressed_representation_size;
        
        
	/* Number of timesteps (upper bound during local search) from
	 * the start state this state occurs.*/
	uint time;
	
	/*Number of propositions in the state description.*/
	uint numPropositions;
	
	/*\macro{SIZE_ELEM} (typically 64 on the right machine) bits
	 * per element in this vector, each bit represents the truth
	 * value of a proposition.*/
	vector<ELEM_TYPE> data;
    };
    
    /*Function for STL and boost to access \member{hash_value} of
     * \argument{GroundActionType}.*/
    template<typename GroundActionType>
    std::size_t hash_value(const State<GroundActionType>& );

    template<typename GroundActionType>
    ostream& operator<<(ostream&, const State<GroundActionType>&);
}


#endif

/*

  
  \begin{quote}
  
  The contemporary proliferation of bullshit also has deeper sources, in
  various forms of skepticism which deny that we can have any reliable
  access to an objective reality, and which therefore reject the
  possibility of knowing how things truly are. These ``antirealist''
  doctrines undermine confidence in the value of disinterested efforts
  to determine what is true and what is false, and even in the
  intelligibility of the notion of objective inquiry. One response to
  this loss of confidence has been a retreat from the discipline
  required by dedication to the ideal of {\em correctness} to a quite
  different sort of discipline, which is imposed by pursuit of an
  alternative ideal of {\em sincerity}. Rather than seeking primarily to
  arrive at accurate representations of a common world, the individual
  turns toward trying to provide honest representations of
  himself. Convinced that reality has no inherent nature, which he might
  hope to identify as the truth about things, he devotes himself to
  being true to his own nature. It is as though he decides that since
  it makes no sense to try and be true to the facts, he must therefore
  try instead to be true to himself.
  
  \end{quote}  

  -- Harry G. Frankfurt, On Bullshit, Princeton university Press, 2005.

 */
