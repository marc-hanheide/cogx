///////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2003-5 Jason Baldridge, Gann Bierner and 
//                      University of Edinburgh (Michael White)
// 
// This library is free software; you can redistribute it and/or
// modify it under the terms of the GNU Lesser General Public
// License as published by the Free Software Foundation; either
// version 2.1 of the License, or (at your option) any later version.
// 
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//////////////////////////////////////////////////////////////////////////////
package opennlp.ccg.parse;

import opennlp.ccg.synsem.*;
import opennlp.ccg.grammar.*;

/**
 * Record the steps taken in a derivation.
 *
 * @author      Jason Baldridge
 * @author      Michael White
 * @version     $Revision: 1.8 $, $Date: 2005/09/22 16:42:54 $
 */
public class DerivationHistory {

    private Sign[] _inputs;
    private Sign _output;
    private Rule _rule;
    private boolean _noHistory = false;
    
    public int NbLexicalCorrectionRulesApplied = 0;
    public int NbTypeShiftingRulesApplied = 0;
    public int NbDiscLevelCompositionRulesApplied = 0;
    
    
    /** Constructor for a sign with no prior history. */
    public DerivationHistory(Sign output) {
        _noHistory = true;
        _output = output;
    }
    
    /** Constructor for a sign created by rule. */
    public DerivationHistory(Sign[] inputs, Sign output, Rule rule) {
        _inputs = new Sign[inputs.length];
        for (int i=0; i < inputs.length; i++) {
            _inputs[i] = inputs[i];
        }
        _output = output;
        _rule = rule;
    }

    
    /** Returns the inputs (or null if none). */
    public Sign[] getInputs() { return _inputs; }
    
    /** Returns the output. */
    public Sign getOutput() { return _output; }
    
    /** Returns the rule. */
    public Rule getRule() { return _rule; }
    
    
    /** Returns the derivation history in vertical list form. */
    public String toString() {
        return toString(maxRuleLen());
    }
    
    // returns the derivation history given the max rule len, for alignment
    private String toString(int maxRuleLen) {
        StringBuffer sb = new StringBuffer();
        // lex item
        if (_noHistory) {
            sb.append("(lex) ");
            for (int i = 5; i < maxRuleLen; i++) { sb.append(' '); }
            sb.append(_output.toString()).append('\n');
            return sb.toString();
        }
        // inputs
        for (int i=0; i < _inputs.length; i++) {
            sb.append(_inputs[i].getDerivationHistory().toString(maxRuleLen));
        }
        // type-changing rule (possibly)
        String ruleName = _rule.name();
        TypeChangingRule tcr = Grammar.theGrammar.rules.getTypeChangingRule(ruleName);
        if (tcr != null) {
            sb.append("(gram) ");
            for (int i = 6; i < maxRuleLen; i++) { sb.append(' '); }
            sb.append(tcr.toString()).append('\n');
        }
        // this rule and result
        sb.append('(').append(ruleName).append(") ");
        for (int i = (ruleName.length() + 2); i < maxRuleLen; i++) { sb.append(' '); }
        sb.append(_output.toString()).append('\n');
        // done
        return sb.toString();
    }
    
    // returns the max length of rule names (including parens)
    private int maxRuleLen() {
        if (_noHistory) { return 6; }
        int max = 0;
        for (int i=0; i < _inputs.length; i++) {
            max = Math.max(max, _inputs[i].getDerivationHistory().maxRuleLen());
        }
        max = Math.max(max, _rule.name().length() + 2);
        return max;
    }
    
    /** Returns the complexity of the derivation, as the sum of 
        the number of steps, plus the number of composition or 
        substitution steps, plus the number of crossing steps. */
    public int complexity() {
        if (_noHistory) return 0;
        int retval = 1;
        String ruleName = _rule.name();
        if (ruleName.length() > 1 && (ruleName.charAt(0) == '>' || ruleName.charAt(0) == '<')) {
            if (ruleName.charAt(1) == 'B' || ruleName.charAt(1) == 'S') {
                retval++;
                if (ruleName.length() == 3 && ruleName.charAt(2) == 'x') retval++;
            }
        }
        for (int i=0; i < _inputs.length; i++) {
            retval += _inputs[i].getDerivationHistory().complexity();
        }
        return retval;
    }
}

