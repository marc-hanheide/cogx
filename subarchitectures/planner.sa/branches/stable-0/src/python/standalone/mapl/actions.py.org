#! /usr/bin/env python
# -*- coding: latin-1 -*-

import copy
import sets

import conditions
import effects
import types

tmp_vars = 0
def invent_parameters(lit, predicates):
  """invent missing parameters for values of this literal"""
  pname = lit.predicate
  declaration = predicates[pname]
  ts = [p.type for p in declaration.value]
  global tmp_vars
  params = []
  for t in ts:
    params.append(types.TypedObject("?_v%d" % tmp_vars, t))
    tmp_vars += 1
  return params


class Action(object):
  def __init__(self, name, parameters, precondition, effects):
    self.name = name
    self.parameters = parameters
    self.precondition = precondition
    self.effects = effects
    self.uniquify_variables()
    
  def add_delete_effects(self, predicates):
    """looks for non-boolean effects and extends parameters, (pre-)conditions,
       and delete effects such that the action works in PDDL, too."""
    #print "\n\nchecking action", self.name
    new_effects = list()
    for effect in self.effects:
      #print "checking effect", effect.literal
      if effect.condition == conditions.Truth():
        parameters = self.parameters
        condition = self.precondition
      else:
        parameters = effect.parameters
        condition = effect.condition
      svar = (effect.literal.predicate, effect.literal.args)
      #print "pred", svar[0]
      eff_val = effect.literal.value
      if eff_val not in (conditions.TRUE_TUP, conditions.FALSE_TUP): 
        parts = condition.parts
        if not parts:
          parts = [condition]
        found = False
        #print "parts:", parts
        for part in parts:
          #print "   comparing to", part
          if isinstance(part, conditions.Literal) and svar == (part.predicate, part.args):
            found = True
            params = part.value
            pnames = part.value
            #print "found correspondence:", part
        if not found:
          params = invent_parameters(effect.literal, predicates)
          #print "found no correspondence, inventining parameters:", params
          parameters.extend(params)
          pnames = [p.name for p in params]
          new_condition = conditions.Atom(svar[0], list(svar[1]) + pnames)
          condition.parts = list(condition.parts)
          condition.parts.append(new_condition)
          #print "adding condition", new_condition.predicate, new_condition.args, new_condition.value
          #print "adding condition", new_condition
        new_effect_literal = conditions.Atom(svar[0], list(svar[1])+list(pnames), conditions.FALSE_TUP)
        if condition == self.precondition:
          new_effect = effects.Effect([], conditions.Truth(), new_effect_literal)
        else:
          new_effect = effects.Effect(parameters, condition, new_effect_literal)
        #print "adding effect", new_effect.literal.predicate, new_effect.literal.args, new_effect.literal.value
        #print "adding effect", new_effect_literal
        new_effects.append(new_effect)
    #print "new effects found:", new_effects
    self.effects.extend(new_effects)
    #self.dump()
      
  def add_knowledge_preconditions_and_effects(self):
    pass
  
  def parse(alist):
    iterator = iter(alist)
    assert iterator.next() == ":action"
    name = iterator.next()
    assert iterator.next() == ":parameters", "oops. %s seems ill-formed" % name
    parameters = types.parse_typed_list(iterator.next(), only_variables=True)
    precondition_tag_opt = iterator.next()
    if precondition_tag_opt == ":precondition":
      precondition = conditions.parse_condition(iterator.next())
      effect_tag = iterator.next()
    else:
      precondition = conditions.Conjunction([])
      effect_tag = precondition_tag_opt
    assert effect_tag == ":effect"
    effect_list = iterator.next()
    if effect_list[0] == "and":
      effect_list = effect_list[1:]
    else:
      effect_list = [effect_list]
    eff = []
    for item in effect_list:
      effects.parse_effects(item, eff)
    for rest in iterator:
      assert False, rest
    a = Action(name, parameters, precondition, eff)
    #a.dump()
    return a
  parse = staticmethod(parse)
  def dump(self):
    print "\n%s(%s)" % (self.name, ", ".join(map(str, self.parameters)))
    print "Precondition:"
    self.precondition.dump()
    print "Effects:"
    for eff in self.effects:
      eff.dump()
  def dump_pddl(self, stream):
    print >> stream, "\n(:action %s" % self.name
    print >> stream, " :parameters (%s)" % " ".join(map(types.pddl_str, self.parameters))
    print >> stream, " :precondition"
    self.precondition.dump_pddl(stream, indent="    ")
    print >> stream, " :effect (and"
    for effect in self.effects:
      effect.dump_pddl(stream, indent="    ")    
    print >> stream, "))"
  def uniquify_variables(self):
    self.type_map = dict([(par.name, par.type) for par in self.parameters])
    self.precondition = self.precondition.uniquify_variables(self.type_map)
    for effect in self.effects:
      effect.uniquify_variables(self.type_map)
  def unary_actions(self):
    # TODO: An neue Effect-Repräsentation anpassen.
    result = []
    for i, effect in enumerate(self.effects):
      unary_action = copy.copy(self)
      unary_action.name += "@%d" % i
      if isinstance(effect, effects.UniversalEffect):
        # Careful: Create a new parameter list, the old one might be shared.
        unary_action.parameters = unary_action.parameters + effect.parameters
        effect = effect.effect
      if isinstance(effect, effects.ConditionalEffect):
        unary_action.precondition = conditions.Conjunction([unary_action.precondition,
                                                            effect.condition]).simplified()
        effect = effect.effect
      unary_action.effects = [effect]
      result.append(unary_action)
    return result
  def relaxed(self):
    new_effects = []
    for eff in self.effects:
      relaxed_eff = eff.relaxed()
      if relaxed_eff:
        new_effects.append(relaxed_eff)
    return Action(self.name, self.parameters,
                  self.precondition.relaxed().simplified(),
                  new_effects)
  def untyped(self):
    # We do not actually remove the types from the parameter lists,
    # just additionally incorporate them into the conditions.
    # Maybe not very nice.
    result = copy.copy(self)
    parameter_atoms = [par.to_untyped_strips() for par in self.parameters]
    new_precondition = self.precondition.untyped()
    result.precondition = conditions.Conjunction(parameter_atoms + [new_precondition])
    result.effects = [eff.untyped() for eff in self.effects]
    return result
  def untyped_strips_preconditions(self):
    # Used in instantiator for converting unary actions into prolog rules.
    return [par.to_untyped_strips() for par in self.parameters] + \
           self.precondition.to_untyped_strips()

  def instantiate(self, var_mapping, init_facts, fluent_facts, objects_by_type):
    """Return a PropositionalAction which corresponds to the instantiation of
    this action with the arguments in var_mapping. Only fluent parts of the
    conditions (those in fluent_facts) are included. init_facts are evaluated
    whilte instantiating.
    Precondition and effect conditions must be normalized for this to work.
    Returns None if var_mapping does not correspond to a valid instantiation
    (because it has impossible preconditions or an empty effect list.)"""
    arg_list = [var_mapping[par.name] for par in self.parameters]
    name = "(%s %s)" % (self.name, " ".join(arg_list))

    precondition = []
    try:
      self.precondition.instantiate(var_mapping, init_facts,
                                    fluent_facts, precondition)
    except conditions.Impossible:
      return None
    effects = []
    for eff in self.effects:
      eff.instantiate(var_mapping, init_facts, fluent_facts,
                      objects_by_type, effects)
    if effects:
      return PropositionalAction(name, precondition, effects)
    else:
      return None
    

class PropositionalAction:
  def __init__(self, name, precondition, effects):
    self.name = name
    self.precondition = precondition
    self.add_effects = []
    self.del_effects = []
    for (condition, effect) in effects:
      if effect.negated:
        self.del_effects.append((condition, effect.negate()))
      else:
        self.add_effects.append((condition, effect))
  def dump(self):
    print self.name
    for fact in self.precondition:
      print "PRE: %s" % fact
    for cond, fact in self.add_effects:
      print "ADD: %s -> %s" % (", ".join(map(str, cond)), fact)
    for cond, fact in self.del_effects:
      print "DEL: %s -> %s" % (", ".join(map(str, cond)), fact)
