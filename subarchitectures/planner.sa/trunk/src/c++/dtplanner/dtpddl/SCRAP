

//         /* For each \LHS{action}, we have the \RHS{probability} that
//          * that action leads to a particular successor. */
//         typedef std::tr1::tuple<uint, double> Successor_Index;

//         /* Description of state transition function from *this
//          * state. */
//         typedef std::map<Successor_Index
//                          , Markov_Decision_Process_State> Successors;

//         /* Probability of getting a particular successor state. */
//         typedef std::map<Markov_Decision_Process_State
//                          , Successor_Index> Successor_Probability;

//         /* (see \typedef{Successors}) */
//         Successors successors;

//         /* (see \typedef{Successor_Probability}) */
//         Successor_Probability successor_Probability;



//     std::ostringstream __new_action_name;
//     Planning::Action_Name old__action_name = action_Proposition.get__name();
//     Planning::Constant_Arguments arguments = action_Proposition.get__arguments();
//     __new_action_name<<old__action_name
//                      <<":numeric:+"
//                      <<count_of_actions_posted++;
            
//     auto _new_action_name = __new_action_name.str();
//     NEW_referenced_WRAPPED(runtime_Thread
//                            , Planning::Action_Name
//                            , new__action_name
//                            , _new_action_name);
            
//     NEW_referenced_WRAPPED(runtime_Thread
//                            , Formula::Action_Proposition
//                            , new__action_proposition
//                            , new__action_name
//                            , arguments);



//         if(!processing_negative){
//             INTERACTIVE_VERBOSER(true, 3101, " -- Needed to be TRUE :: "<<fact);

            
//             statically_false__starting_always_false(fact);
//         } else if (processing_negative) {
//             INTERACTIVE_VERBOSER(true, 3101, " -- Needed to be FALSE :: "<<fact);

            
            
            
//         }
        
        
//         auto predicate_index = fact->get__name().get__id();
//         auto _arguments = fact->get__arguments();

//         Argument_List arguments(_arguments.size());
        
//         for(auto i = 0; i < arguments.size(); i++){
//             if(_arguments[i].test_cast<Planning::Variable>()){
//                 arguments[i] = X_constant;
//             } else {
//                 arguments[i] = _arguments[i];
//             }
//         }
        
        
//         INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Ground form of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
        
//         auto cached_Partial_Assignment_Satisfiability = cached_satisfiable.find(predicate_index);
        
        
//     }

//     if(!domain_Data.in_delete_effect(fact->get__name())){
        
//     }
    
    
    
//     if(!processing_negative && ){

//         INTERACTIVE_VERBOSER(true, 3101, "Got static FALSE first-order fact :: "<<fact);
        
//         auto predicate_index = fact->get__name().get__id();
//         auto _arguments = fact->get__arguments();

//         Argument_List arguments(_arguments.size());
        
//         for(auto i = 0; i < arguments.size(); i++){
//             if(_arguments[i].test_cast<Planning::Variable>()){
//                 arguments[i] = X_constant;
//             } else {
//                 arguments[i] = _arguments[i];
//             }
//         }
        
//         INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Ground form of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
        
        
//         auto cached_Partial_Assignment_Satisfiability = cached_satisfiable.find(predicate_index);
        
//         if(cached_Partial_Assignment_Satisfiability == cached_satisfiable.end()){
//             INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Had not cached ground form of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
            
//             cached_satisfiable[predicate_index] = std::tr1::tuple<Cached_Partial_Assignment_Satisfiability
//                 , Cached_Partial_Assignment_Unsatisfiability>();
//             cached_Partial_Assignment_Satisfiability = cached_satisfiable.find(predicate_index);
//         }
        
//         Cached_Partial_Assignment_Satisfiability& satisfiable__cached =
//             std::tr1::get<0>(cached_Partial_Assignment_Satisfiability->second);
//         Cached_Partial_Assignment_Unsatisfiability& unsatisfiable__cached =
//             std::tr1::get<1>(cached_Partial_Assignment_Satisfiability->second);
        
//         if(satisfiable__cached.find(arguments) == satisfiable__cached.end()){
//             assert(!(unsatisfiable__cached.find(arguments) == unsatisfiable__cached.end()));
            
//             INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Cached GROUNDABLE ::  of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
            
            
//             return Result(Subformula(fact), true);
//         } else if (unsatisfiable__cached.find(arguments) == unsatisfiable__cached.end()) {
//             INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Cached UN-GROUNDABLE ::  of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
            
//             return Result(formula__false, false);
//         }
           
//         if(problem_Data.statically_satisfiable(*fact)){
//             INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Cache-ING POSSIBLY GROUNDABLE ::  of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
            
            
//             satisfiable__cached.insert(arguments);
//             return Result(Subformula(fact), true);
//         } else {
//             INTERACTIVE_VERBOSER(true, 3101, "FALSE CASE :: Cache-ING UN-GROUNDABLE ::  of first-order fact :: "<<fact->get__name()<<" "<<arguments<<std::endl);
            
//             unsatisfiable__cached.insert(arguments);
//             return Result(formula__false, false);
//         }
//     }


//     if(processing_negative && !domain_Data.in_add_effect(fact->get__name())){
        
//         INTERACTIVE_VERBOSER(true, 3101, "Got static FALSE first-order fact :: "<<fact);
        
        
//         auto predicate_index = fact->get__name().get__id();
//         auto _arguments = fact->get__arguments();

//         Argument_List arguments(_arguments.size());
//         for(auto i = 0; i < arguments.size(); i++){
//             if(_arguments[i].test_cast<Planning::Variable>()){
//                 arguments[i] = X_constant;
//             } else {
//                 arguments[i] = _arguments[i];
//             }
//         }
           
//         INTERACTIVE_VERBOSER(true, 3101, "TRUE CASE :: Ground form of first-order fact :: "
//                              <<fact->get__name()<<" "<<arguments<<std::endl);
        
//         auto cached_Partial_Assignment_Satisfiability = cached_unsatisfiable.find(predicate_index);

//         if(cached_Partial_Assignment_Satisfiability == cached_unsatisfiable.end()){
//             INTERACTIVE_VERBOSER(true, 3101, "TRUE CASE :: Had not cached TRUE first-order fact :: "<<fact);
            
//             cached_unsatisfiable[predicate_index] = std::tr1::tuple<Cached_Partial_Assignment_Satisfiability
//                 , Cached_Partial_Assignment_Unsatisfiability>();
//             cached_Partial_Assignment_Satisfiability = cached_unsatisfiable.find(predicate_index);
//         }
           
//         Cached_Partial_Assignment_Satisfiability& satisfiable__cached =
//             std::tr1::get<0>(cached_Partial_Assignment_Satisfiability->second);
//         Cached_Partial_Assignment_Unsatisfiability& unsatisfiable__cached =
//             std::tr1::get<1>(cached_Partial_Assignment_Satisfiability->second);

//         if(satisfiable__cached.find(arguments) != satisfiable__cached.end()){
//             return Result(formula__true, true);
//         } else if (unsatisfiable__cached.find(arguments) != unsatisfiable__cached.end()) {
//             return Result(Subformula(fact), true);
//         }
           
//         if(problem_Data.statically_unsatisfiable(*fact)){
//             satisfiable__cached.insert(arguments);
//             INTERACTIVE_VERBOSER(true, 3101, "TRUE CASE :: Cache-ING ALWAYS GROUNDABLE ::  of first-order fact :: "
//                                  <<fact->get__name()<<" "<<arguments<<std::endl);
            
//             return Result(formula__true, true);
//         } else {
//             INTERACTIVE_VERBOSER(true, 3101, "TRUE CASE :: Cache-ING POSSIBLY GROUNDABLE ::  of first-order fact :: "
//                                  <<fact->get__name()<<" "<<arguments<<std::endl);
//             unsatisfiable__cached.insert(arguments);
//             return Result(Subformula(fact), true);
//         }
//     }
    
//     INTERACTIVE_VERBOSER(true, 3101, "Got dynamic first-order fact :: "<<fact);
    
    
//     return Result(Subformula(fact), true);

State_Transformation::State_Transformation(bool compulsory)
    :compulsory(compulsory)
{
}

        
void State_Transformation::report__newly_satisfied(State& state)
{
    if(compulsory){
        state.add__compulsory_transformation(this); 
    } else {
        state.add__optional_transformation(this);
    }
}

void State_Transformation::report__newly_unsatisfied(State& state)
{
    if(compulsory){
        state.retract__compulsory_transformation(this); 
    } else {
        state.retract__optional_transformation(this);
    }   
}
        
bool State_Transformation::is__compulsory() const
{
    return compulsory;
}

void State_Transformation::set__compulsory(bool in)
{
   compulsory = in; 
}



// State& STRIPS_Action::operator()(const State&)
// {
//     UNRECOVERABLE_ERROR("unimplemented");
// }

// void STRIPS_Action::add__add(uint)
// {
//     UNRECOVERABLE_ERROR("unimplemented");
// }

// void STRIPS_Action::add__delete(uint)
// {
//     UNRECOVERABLE_ERROR("unimplemented");
// }








// void  Domain_Data::address___derived_Predicates__types_pending()
// {
//     if(!derived_Predicates__types_pending.size()) return;
    
//     Planning::Formula::Derived_Predicates to_delete;
//     Planning::Formula::Derived_Predicates to_include;

//     /* Some new variables were just now quantified. */
//     auto variable_symbols = get__symbols(typed_Arguments);
//     auto type_symbols = get__types(typed_Arguments);
        
//     for(auto dp = derived_Predicates__types_pending.begin()
//             ; dp != derived_Predicates__types_pending.end()
//             ; dp++){
        
//         Planning::Variables pending_variables = dp->get__pending_arguments();
//         Planning::Typed_Arguments argument_spec = dp->get__arguments();

//         bool changed = false;

//         /*For newely acquired variable descriptions (from \member{typed_Arguments})*/
//         for(auto i = 0
//                 ; i < variable_symbols.size()
//                 ; i++){

//             assert(variable_symbols[i].test_cast<Variable>());
            
//             auto var = variable_symbols[i].do_cast_and_copy<Variable>();
//             auto types = type_symbols[i];
            
//             if(pending_variables.find(var) != pending_variables.end()){
//                 pending_variables.erase(var);
//                 get__symbols(argument_spec).push_back(variable_symbols[i]);
//                 get__types(argument_spec).push_back(types);
//                 changed = true;
//             }
//         }

//         if(changed){
//             to_delete.insert(*dp);
            
//             NEW_object_referenced_WRAPPED(Planning::Formula::Derived_Predicate
//                                           , tmp
//                                           , dp->get__name()
//                                           , argument_spec
//                                           , pending_variables
//                                           , dp->get__formula()
//                                           , dp->get__type()
//                                           , dp->get__variable()
//                                           , ((dp->get__genesis() > -1)
//                                              ?(dp->get__genesis())
//                                              :(dp->get__id())));
            
//             if(!pending_variables.size()){
//                 derived_Predicates__artificial.insert(tmp);
//             } else {
//                 to_include.insert(tmp);
//             }
//         }
//     }


//     for(auto p = to_delete.begin()
//             ; p != to_delete.end()
//             ; p++){
//         auto old_size = derived_Predicates__types_pending.size();
//         derived_Predicates__types_pending.erase(*p);
//         QUERY_UNRECOVERABLE_ERROR(old_size >= derived_Predicates__types_pending.size(),
//                                   "Attempt to remove predicate :: "<<*p<<std::endl
//                                   <<"with out of scope variables :: "<<std::tr1::get<0>(p->contents())<<std::endl
//                                   <<"has failed.");
//     }
    
//     for(auto p = to_include.begin()
//             ; p != to_include.end()
//             ; p++){
//         derived_Predicates__types_pending.insert(*p);
//     }
// }



// CXX__deref__shared_ptr<basic_type>
// Domain_Data::complete__forall_formula()
// {
//     VERBOSER(31, "Universal quantification.");

//     QUERY_UNRECOVERABLE_ERROR(get__symbols(typed_Arguments).size() != 1,
//                               "Expecting one quantified variable, but got :: "<<typed_Arguments<<std::endl);
    
//     assert(get__symbols(typed_Arguments).size() == 1);
//     assert(get__symbols(typed_Arguments).back().test_cast<Variable>());
//     Planning::Variable quantified_variable
//         = get__symbols(typed_Arguments).back().do_cast_and_copy<Variable>();
    
//     QUERY_WARNING(variables.find(quantified_variable) == variables.end()
//                   , "Pointless quantifier :: (forall (?"<<quantified_variable<<") ("
//                   <<subformulae[parsing_level + 1].back()<<")"<<std::endl
//                   <<"Because variable "<<quantified_variable
//                   <<" does not appear in formula. Recovering by skipping quantifier."<<std::endl);
    
//     if(variables.find(quantified_variable) == variables.end()){
//         variables.erase(quantified_variable);
//         typed_Arguments = Typed_Arguments();
//         return subformulae[parsing_level + 1].back();
//     }
//     variables.erase(quantified_variable);
    
//     assert(subformulae.find(parsing_level + 1) != subformulae.end());
//     assert(subformulae[parsing_level + 1].size());
//     std::ostringstream oss;
//     oss<<subformulae[parsing_level + 1][0];

//     NEW_object_referenced_WRAPPED(Planning::Predicate_Name,
//                                   name,
//                                   oss.str());

    
    
//     Variables _variables = variables;
    
//     auto typed_variables = std::tr1::get<0>(std::tr1::get<1>(action_Header.contents()));
//     auto variablex_types = std::tr1::get<1>(std::tr1::get<1>(action_Header.contents()));
    
//     for(auto variable = variables.begin()
//             ; variable != variables.end()
//             ; variable++){

            
//         for(auto i = 0; i < typed_variables.size(); i++){
            
            
//             assert(typed_variables[i].test_cast<Variable>());
//             auto actual_variable = typed_variables[i].do_cast<Variable>();
            
//             if(*variable == *actual_variable){
//                 VERBOSER(31, "NOT MISSING "<<*variable<<std::endl);
//                 std::tr1::get<0>(typed_Arguments).push_back(typed_variables[i]);
//                 std::tr1::get<1>(typed_Arguments).push_back(variablex_types[i]);
//                 _variables.erase(*variable);
//             }
//         }
//     }
    

//     QUERY_UNRECOVERABLE_ERROR(
//         subformulae[parsing_level + 1].size() != 1,
//         "Got a quantified variable without a formula.");
    
//     NEW_object_referenced_WRAPPED_deref_POINTER
//         (Planning::Formula::Derived_Predicate
//          , tmp
//          , name
//          , typed_Arguments
//          , _variables
//          , subformulae[parsing_level + 1].back()
//          , Planning::enum_types::forall
//          , quantified_variable
//          , -1
//          );
    
//     VERBOSER(26, "GOT :: "<<name<<std::endl<<std::endl
//              <<typed_Arguments<<std::endl<<std::endl
//              <<_variables<<std::endl<<std::endl
//              <<subformulae[parsing_level + 1].back()<<std::endl<<std::endl
//              <<Planning::enum_types::forall<<std::endl<<std::endl
//              <<quantified_variable<<std::endl<<std::endl);

    
//     VERBOSER(31, "GOT :: "<<tmp<<std::endl);
    
//     if(!_variables.size()){
//         VERBOSER(31, "CONFIRMED :: "<<tmp<<std::endl);
//         derived_Predicates__artificial
//             .insert(*dynamic_cast<Planning::Formula::Derived_Predicate*>(tmp.get().get()));
//     } else {
//         VERBOSER(31, "PENDING :: "<<tmp<<std::endl);
//         derived_Predicates__types_pending
//             .insert(*dynamic_cast<Planning::Formula::Derived_Predicate*>(tmp.get().get()));
//     }

//     address___derived_Predicates__types_pending();
    
//     typed_Arguments = Typed_Arguments();

//     return tmp;
// }

//     using namespace Planning;
    
//     Argument_List argument_List;
//     Argument_Types argument_Types;
//     Typed_Arguments typed_Arguments;
//     Predicate predicate;
//     Predicates predicates;
//     Types types;
//     NEW_WRAPPED(Predicate_Name, predicate_Name, "name");
//     NEW_WRAPPED(Type, t, "S");
//     types.insert(t);
//     NEW_WRAPPED_deref_POINTER(Variable, v, "x");
//     argument_List.push_back(v);
//     argument_Types.push_back(types);
//     std::tr1::get<0>(typed_Arguments) = argument_List;
//     std::tr1::get<1>(typed_Arguments) = argument_Types;
//     NEW_WRAPPED(Predicate, p, predicate_Name, typed_Arguments);
//     NEW_WRAPPED(Predicate, pp, predicate_Name, typed_Arguments);

//     predicates.insert(p);
//     auto size1 = predicates.size();
//     predicates.insert(pp);
//     auto size2 = predicates.size();

//     assert(size1 == size2);
    
//     NEW_WRAPPED_deref_POINTER(Variable, vv, "x1");
//     argument_List.push_back(vv);
    
//     Argument_Types argument_Types2;
//     argument_Types2.push_back(types);
//     argument_Types2.push_back(types);
//     assert(argument_Types2 != argument_Types);
//     assert(argument_Types < argument_Types2 || argument_Types2 < argument_Types);
    
//     Typed_Arguments typed_Arguments2;
//     std::tr1::get<0>(typed_Arguments2) = argument_List;
//     std::tr1::get<1>(typed_Arguments2) = argument_Types2;
    
//     NEW_WRAPPED(Predicate, ppp, predicate_Name, typed_Arguments2);
//     predicates.insert(ppp);
//     std::cerr<<predicates.size()<<std::endl;
//     std::cerr<<ppp<<" "<<ppp.hash_value()<<std::endl;
//     std::cerr<<p<<" "<<p.hash_value()<<std::endl;
        
//     exit(0);