//predicate declarations
feature(perc,feat)
// resolved(perc)
percept(perc)
attribute(attr)
resolution(perc)

// temporary solution for the 'openworldness' of number of percepts
// the predicate percept makes sure that only the (non-unit) rules of perceived
// objects are grounded
// this keeps the size of the network managable even if the number of possible
// percepts (|perc|) is significantly larger than 3
perc={P1,P2,P3}

// -1.87115  feature(p,VRed)
-1.87115  feature(a1,VRed)

// -1.87115  feature(p,VBlue)
-1.87115  feature(a1,VBlue)

// -1.87115  feature(p,VGreen)
-1.87115  feature(a1,VGreen)

// -1.87115  attribute(LRed)
-1.87115  attribute(LRed)

// -1.87115  attribute(LBlue)
-1.87115  attribute(LBlue)

// -1.87115  attribute(LGreen)
-1.87115  attribute(LGreen)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LRed) => resolution(p)
1       !feature(a1,VRed) v !attribute(LRed) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LRed) => resolution(p)
-2       !feature(a1,VBlue) v !attribute(LRed) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LRed) => resolution(p)
-2       !feature(a1,VGreen) v !attribute(LRed) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LBlue) => resolution(p)
-2       !feature(a1,VRed) v !attribute(LBlue) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LBlue) => resolution(p)
1       !feature(a1,VBlue) v !attribute(LBlue) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LBlue) => resolution(p)
-2       !feature(a1,VGreen) v !attribute(LBlue) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LGreen) => resolution(p)
-2       !feature(a1,VRed) v !attribute(LGreen) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LGreen) => resolution(p)
-2       !feature(a1,VBlue) v !attribute(LGreen) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LGreen) => resolution(p)
1       !feature(a1,VGreen) v !attribute(LGreen) v resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LRed) => !resolution(p)
-1       !feature(a1,VRed) v !attribute(LRed) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LRed) => !resolution(p)
2       !feature(a1,VBlue) v !attribute(LRed) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LRed) => !resolution(p)
2       !feature(a1,VGreen) v !attribute(LRed) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LBlue) => !resolution(p)
2       !feature(a1,VRed) v !attribute(LBlue) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LBlue) => !resolution(p)
-1       !feature(a1,VBlue) v !attribute(LBlue) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LBlue) => !resolution(p)
2       !feature(a1,VGreen) v !attribute(LBlue) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VRed) ^ attribute(LGreen) => !resolution(p)
2       !feature(a1,VRed) v !attribute(LGreen) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VBlue) ^ attribute(LGreen) => !resolution(p)
2       !feature(a1,VBlue) v !attribute(LGreen) v !resolution(a1) v !percept(a1)

// 0       percept(p) ^ feature(p,VGreen) ^ attribute(LGreen) => !resolution(p)
-1       !feature(a1,VGreen) v !attribute(LGreen) v !resolution(a1) v !percept(a1)

// -5.61346  feature(a1,a2)
-5.61346  feature(a1,a2)

// -5.61346  attribute(a1)
-5.61346  attribute(a1)

// -7.23121  resolution(a1)
//-7.23121  resolution(a1)

// -7.23121  percept(a1)
-7.23121  percept(a1)

// -7.23121  resolved(a1)
//-7.23121  resolved(a1)

