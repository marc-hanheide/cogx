
 
 
 ################################################################ 
# I AM A GENERATED FILE (by merge-ccg.pl)                      #  
# DO NOT EDIT ME DIRECTLY !!!                                  #
# INSTEAD, EDIT THE SOURCE .CCG FILES IN ./ccg-files FOLDER    #
################################################################ 
 
 # This contains a few random cats, families, and dicionary-forms
# for important & primary things that don't deserve a file of their own
 

#########################
# SENTENCE & EVENT CATS #
#########################
  
  def EVENT(args)     { E:event( args ) }

  def s_bare(args)    { s <10> [E args] }
  def s(args)         { s_bare(NUM:NUM PERS:PERS MCLASS:MCLASS  MOOD:MOOD POL:POL VFORM:VFORM args)}
#  def s(args)         { s_bare(NUM:NUM PERS:PERS MCLASS  MOOD POL VFORM args)}
  def from-s(args)    { s <~10> [E args] }
 

###############
# The SUBJECT #
###############

 
   def subj(args)        { np<9>[S nom NUM:NUM PERS:PERS args] }
   def from-subj(args)   { np<~9>[S nom NUM:NUM PERS:PERS args] } 

   # Verbs don't actually syntactically'take' their subjects. This is done via rule for ind, via aux or wh-word for int, etc

   def +subj(args)     { \! subj(args) }    
   def +from-subj(args)     { \! from-subj(args) }

 
  
#############################
## COORD CAT & DICT FORMS  ##
#############################


  # The syntactic categories for coordination, as well as the families,
  # are located in their respective files.
  #  e.g Noun & NP coord are in noun.ccg, prep in prep.ccg
  #  Sentential & VP coord are in verb.ccg

  def COORD(args)       { R( args <First>(F) ^ <Next>(N) ) }
 
  # modify a given pos (adj, adv, prep, etc) on the given side (left, right)
  #
  def coord+(form, pos, class, args) {_coord+(form, form, pos, class, args) }
  def _coord+(prd, form, pos, class, args) {
    word form."-coord-".pos : "Coord-" . pos."-" (class, pred=prd)
	{form: args;}
  } 
  def coord(form, pos, class) {_coord(form, form, pos, class) }
  def _coord(prd, form, pos, class) {
    word form."-coord-".pos : "Coord-" . pos."-" (class, pred=prd)
	{form ;}
  } 

############
# PARTICLE #
############

  # As in pick up the ball , pick the ball up.
  # Currently not really being used much. But definitely should!

  def prt(args)      { prt<25>[P args] }
  family Particle	 { entry:  prt(MARK= *) : P(*) ;}


# This file contains the semantic and syntactic features 
# used by the grammar

#####################
# SEMANTIC FEATURES #
#####################

# Note: currently a 'redundancy' for proximity. Can't re-use feature-value names
#       so must have , e.g., distal, e-distal and m-distal corresponding to
#       THAT ball, who said THAT, OVER on the table (or THERE)

feature{

## ENTITY features ##

NUMBER<T:Num>: sg pl;      
PROXIMITY<T:Proximity>: distal proximal;
DELIMINATION<T:Delimitation>: unique existential variable;
QUANTIFICATION<T:Quantification>: specific unspecific uncountable;

## EVENT features ##
  
POLARITY<E:Polarity>: pos neg;
MOOD<E:Mood>: ind imp int;
TENSE<E:Tense>: past pres fut;
ASPECT<E:Aspect>: continuous perfect;
VOICE<E:Voice>: active passive;
E-PROXIMITY<E:Proximity>: e-distal e-proximal;

## MOD features ##

DEGREE<M:Degree>: no-degrees degrees{degree-base comparative superlative};
M-PROXIMITY<M:Proximity>: m-distal m-proximal;

}

# These are the semantic features which are used inside family definitions in the grammar
# Although syntactic features can be used syntactic categories inside the grammar, semantic
# ones can't be (i.e only as 'macros' in dicionary entries) 

  def POS()  { <Polarity>(pos) }  def NEG()  { <Polarity>(neg) }
  def SG()   { <Num>(sg) }        def PL()   { <Num>(pl) }

  def UNCOUNTABLE()             { <Quantification>(uncountable) }
  def UNSPECIFIC()              { <Quantification>(unspecific)  }
  def SPECIFIC()                { <Quantification>(specific)    }

  def UNIQUE()      { <Delimitation>(unique) }
  def VARIABLE()    { <Delimitation>(variable) }
  def EXISTENTIAL() { <Delimitation>(existential) }
  
  def IND() { <Mood>(ind) }   def IMP() { <Mood>(imp) }   def INT() { <Mood>(int) }
  
######################
# SYNTACTIC FEATURES #
######################

# 15 is the feature id for nouns
# 9 is the feature id for the syntatic subject position
# 10 is the feature id for sentences
# 11 is the feature id for finites when 'selected' for by interrogative utterance templates
#       the finite determines subj agreement and pol, vform & fin.
# 42 is used for the np compliment in 'I am a man', used to block ' these are a ball'

feature{

## Noun features ##

NUM<15, 9, 10, 11, 42>:  s-sg s-pl {s-pl-sp s-pl-unsp} s-mass ;  # specific plural (as in 3 balls) or unspecific (balls)
PERS<15, 9, 10, 11>: non-3rd {1st 2nd} 3rd;

CASE<15, 9>: nom acc-both{acc acc-loc}; # acc-loc is for here and there in 'on there', 'up here', 'closer to there' also 'before then' etc.                              
NFORM<15, 9, 11>: nf-real{full pro nf-ctxt} nf-dummy{dummy-there};  # full form vs pronoun vs none (as in the green)

#CASE<15, 9>: nom acc ; # acc-loc is for here and there in 'on there', 'up here', 'closer to there' etc.                              
#NFORM<15, 9, 11>: full pro nf-ctxt;  # full form vs pronoun vs none (as in the green)


## Sentence Features 

# Sept 7 added mood-mixed to handle the coordinate "I am sorry but could you help me"
MOOD<10>: s-major{ s-ind s-imp s-int s-ind-ell s-mood-mixed}  s-minor s-dependent;  
POL<10,11>: s-pos s-prov-pos s-neg;
#VFORM<10,11>: fin{ fin-ctxt fin-full fin-deictic}   vf-base inf ing pp vf-be for-ing ;  


# Aug 20 added ell-subj as vform... may be useful. Should eventually take out of s-mood, me thinks.

VFORM<10,11>: fin{ fin-clause{fin-ctxt fin-ell fin-full} fin-deictic} vf-base vf-to-imp inf ing pp vf-be for-ing;  


#VFORM<10,11>: fin{ fin-clause{fin-ctxt fin-full} fin-deictic} vf-base vf-to-imp inf ing pp vf-be for-ing;  
    # vf-be (am able to)  for-ing (thanks for helping me), fin-ctxt (I did), fin-deictic (I said that) , fin-full (all other finite events)
	# Need two layers b/c any thing which wants a finite-s can take a deictic (I said that, before that, etc.) BUT must the ind-building rule
	# only wants fin-ctxt or full

FIN<10,11>: be do can should will could would must have;  
	# this will be important if we want 1) to handle tag questions 2) to cleanly & quickly handle 'ellipse responses' I did, you shouldn't, can I, etc.



## Adj/Adv Features ##

DEGREE<25>: s-no-degrees s-degrees{s-degree-base s-comparative s-superlative};





######## Modifier Restriction #######


# OpenCCG doesn't seem to like using the same feature-value names for differnt things, 
# so, I have created 3 versions.
#           1) m-#######, the ontological semantic sort
#           2) x-#######, placed on mod themselves, specifying one 'kind' of modifier they are
#           3) s-#######, placed on the s (or verb) to specify what 'kind' of modifiers it
#                         accepts.

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #            If the modifier section of the ontological hierarchy is changed, you will have to add
  #            reflect these changes here
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



MOD-TYPE<25>:          x-negation
                       x-dynamic{ x-direction x-whereto x-wherefrom x-through }
                       x-manner
                       x-time {x-time-point x-time-sequence x-time-interval}
                       x-location
                       x-probability
                       x-frequency    
                       x-comment      
                       x-serial		   
                       x-accompaniment
					   x-instrumental
					   x-comparison 
                       x-benefactor    
                       x-relational{x-cause x-result x-condition}
                       x-purpose       
                       x-intensity;

# placed on modified  (sentence)
# Note: These could in theory also be placed on Mod-Mods to limit the kinds of Mods they can modify.

MCLASS<10>:            s-negation
                       s-dynamic{ s-direction s-whereto s-wherefrom s-through }
                       s-manner
                       s-time  {s-time-point s-time-sequence s-time-interval}
                       s-location
                       s-probability
                       s-frequency    
                       s-comment      
                       s-serial		   
                       s-accompaniment
					   s-instrumental
					   s-comparison 
                       s-benefactor    
                       s-relational{s-cause s-result s-condition}
                       s-purpose       
                       s-intensity
					   s-none

  # These are the classes which verbs lexically select to determine their modificational potential, 
  # i.e., to restrict the types of modifiers they can accept
  # NEW CLASSES CAN EASILY BE ADDED HERE.

  m-class-none  [s-none]
  m-class-5     [                                       s-comment]
  m-class-4     [s-relational s-frequency s-probability s-comment s-time]
  m-class-3     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison]
  m-class-2x    [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison           s-location]
  m-class-2     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location]
  m-class-1     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location s-manner s-serial]
  m-class-1x    [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose            s-manner s-serial s-dynamic]
  m-class-all   [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location s-manner s-serial s-dynamic]
  ;


## Combinatorial Behaviour of Modifiers ##

# These are the features which determine the syntactic behaviour of modifiers
# (where they can be). Each modifer POS (adv, pp) has a rule for each of 
# these saying, e.g, 'if you are allowed to pre-modify sentences, then I'll turn you into a pre-modifier '

# Each modifier lexically (in the dictionary) chooses its syntactic 'class'

CC-TYPE<25, 15>: post-s post-s-loose pre-s pre-vp post-vp 
                 pre-cop-comp   # I am ALSO big,  it is CERTAINLY not a ball
                 post-n pre-n
			     cc-none
			 
			     compound-1st compound-head
				 no-q  # this is placed in slots that don't want 'quality' entities (color, size, shap, etc), e.g. 'what size ball' but not 'what size color'
			 
   # Here are the classes for adverbs (NEW CAN EASILY BE MODIFIED/EXTENDED)			 
			 
   adv-all  [pre-s pre-vp post-vp   post-s pre-cop-comp] 
   adv-1    [pre-s pre-vp post-vp   post-s] #s or vp?
   adv-2    [      pre-vp post-vp   post-s]
   adv-3    [pre-s        post-vp   post-s]
   adv-4    [             post-vp   post-s]
   adv-5    [pre-s pre-vp                 ]
   adv-6    [      pre-vp post-vp         ]
   adv-7  [pre-s pre-vp post-vp   post-s]  

   # Here are the classes for prepositions (NEW CAN EASILY BE MODIFIED/EXTENDED)
			 
   prep-all [post-n post-s post-vp pre-s]
   prep-1   [post-n post-s post-vp      ]
   prep-2   [       post-s post-vp      ]
   prep-3   [post-n                     ]
   prep-4   [       post-s post-vp pre-s]
			 

   # This has been added to some nouns to restrict their behaviour with the n-n compound rule, 
   # e.g. the noun 'left' as in 'the left of the mug' has been set to cc-none to block 'the ball left of the mug'
   #      receiving a reading with 'ball left' as a compound. 
  
   n-all [compound-1st compound-head no-q]
   n-1   [compound-1st  no-q]
   n-2   [compound-head no-q]
   n-3   [compound-1st]
   n-4   [no-q]
  
   ;
  
} # end feature


# This file contains the semantic ontologies (type-heirarchies) 
# used by the grammar (and by dictionary items)

feature{

## EVENT ##
ont-event: event{
                relational
                action {action-motion action-non-motion}
                state {presentational ascription}
                internal {perception cognition}
                modal
                communication
				symbolic
                };

# ! Only the top level 'event' is used in the grammar

## ENTITY ##
ont-entity: entity{
                   physical{ 
                            animate{person}
                            thing
                            e-location{e-region e-place}
						   }
                   e-substance {e-material}
                   e-measure
                   e-event
                   e-time{e-time-point e-time-unit}
                 
				   dummy
				   };


# ! Only the top level 'entity' is used in the grammar
# ! This is because no 'semantic' selectional constraints
# ! have been included in the grammar

## QUALITY ##
ont-quality: quality{
                     q-physical{
                                q-size
                                q-shape
                                q-age
                                q-color
                                q-state
                                q-material
                               }
                     q-position{
                                q-location
                                q-number {number-cardinal number-ordinal number-id}
                                q-temporal
                                q-discourse
                               }
                     q-attitude
                    };


# ! Only the top level 'quality' is used in the grammar

## MODIFIER##

ont-modifier: modifier{
                       m-negation
                       m-dynamic{ m-direction m-whereto m-wherefrom m-through }
                       m-manner
                       m-time {m-time-point m-time-sequence m-time-interval}
                       m-location
                       m-probability
                       m-frequency     # sometimes, often, usually
                       m-comment       # quite generic 'affect'
                       m-serial		   # go get that
                       m-accompaniment # with GJ...
                       m-instrumental  # with the ball...
                       m-benefactor    # for ...
                       m-relational{m-cause m-result m-condition}
                       m-purpose       # I went there 'to get it'
					   m-intensity
					   m-comparison
					   m-restriction   # ball that I picked up,  place where I saw you
                     					  };

#  m-mod-entity {m-location m-accompaniment m-benefactor}


  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  56
  #            The top level 'modifier' is used in the grammar. 
  #
  #            Moreover, any changes to this will require changes in these files:
  #                  types-features.ccg, prep.ccg, adv.ccg and verb.ccg
  #            See these files for specifics.
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

					  

## DISCOURSE##

# this needs re-doing!
ont-discourse: marker{ d-units alignment cue greeting closing reject acknowledge evaluate };
				
}
# This file contains some important categories used by modifiers like
# adjectives, adverbs and prepositions 

# 1) the complex-syntactic categories used in their type-changing rules
# 2) the semantic dependency relations used for modifiers
# 3) syn & sem categories for modifier arguments (like the np arg of prepositions)
# 4) a generic dictionary-entry macro for modifier-modifiers.


####################################
# SYNTACTIC COMPLEX-CAT CATEGORIES #
####################################

# These correspond to the various cc-cat values given to modifiers
# such as prepositions, adverbs, adjectives etc.
#
# The mod argument is the modifier-class corrisponding to the modifier-type of the
# modifier. This is restricts the type of sentences which can be modified.
# I have used MCLASS:mod vs. MCLASS=mod b/c we only want the sentence(verb) to 
# have a class which unifies with the modifier. We don't want to change its value. 
#
# The syn argument here corresponds to any arguments that the modifier 
# may have 'following it', e.g. the np arg of a preposition.
# The ordering here is crucial for incremental parsing:
#	For pre-modifiers, the modifier args will come first then the modifee
#   For post-modifiers, the modifee comes and then then the mod args


  def post-s(mod, syn)          {  from-s() syn \* s(MCLASS:mod )  }
  def post-s-loose(mod, syn)    {  from-s() syn \< s(MCLASS:mod )  }
  def post-vp(mod, syn)         {  from-s() +from-subj()  syn \* ( s(MCLASS:mod) +subj() )  }
    
  def pre-s(mod, syn)                     {  from-s() /^ s(MCLASS:mod )  syn   }
  def pre-vp(mod, syn)                    {  from-s() +from-subj() /^ ( s(MCLASS:mod) +subj() )  syn }  
 
  # I added this Aug 19
  # it is a hack to incrementally parse 'the ball that I just picked up'
  #   Need to sort out incremental handling of this later!
  
  def pre-vp-in-rel-clause(mod, syn)      {  n() / ( from-s() +from-subj() / np<56>[X])  \^ ( n() / ( s(MCLASS:mod) +subj() / np<56>[X] ) ) syn }
 

#  def pre-vp-in-rel-clause(mod, syn)          {  ( from-s() +from-subj() / np<56>[X])  \^ ( s(MCLASS:mod) +subj() / np<56>[X] ) syn }
   
  def post-n(args, syn)         {  from-n(args) syn \* n()  }
  def pre-n(args, syn)          {  from-n(args) / n() syn  }		

########################################
# SPECIAL MODIFIER 'SLOTS' FOR COPULA. #
########################################
#
# These must be defined here because of DotCCG ORDERING ISSUES
#
# This handles I am ALSO big, it is DEFINITELY not a ball, etc.
# i.e. they occur before the compliment  of the copular
# NOTE: To avoid OVER-GENERATION (e.g. I gave him DEFINITELY the ball),
#        the allow compliment possiblities must be specifically defined

# The three possible compliments

 def +cop-np(args)  { / np<42>[X NUM:NUM acc args] }    # the restr & Scope must share number (*these are a ball) 
 def +cop-pp(args)  { /^ pp<2>[X args] } # it must be a preposition which can modify nouns. done semantically(see copual families)
 def +cop-adj(args) { / adj<2>[X args] }

 # Marked as fin=be to block, e.g. I moved CERTAINLY the ball...
 def pre-cop-comp (moder, modee, arg)      { from-s(moder) arg \^ ( s(modee be) arg ) } 

 # These are defined independently because copular negation uses these directly
 #
 def pre-cop-pp(moder, modee, arg)  { pre-cop-comp(moder, modee, +cop-pp() arg   ) }
 def pre-cop-np(moder, modee, arg)  { pre-cop-comp(moder, modee, +cop-np() arg   ) }
 def pre-cop-adj(moder, modee, arg) { pre-cop-comp(moder, modee, +cop-adj() arg  ) }

 # This is invoked by the specific modifier type (e.g. adv) 
 #
 def mod-rule-pre-cop(atomicmod, arg, modee, sem){
	 rule{ typechange: atomicmod arg => pre-cop-pp(, modee, arg) : sem ;}
	 rule{ typechange: atomicmod arg => pre-cop-np(, modee, arg) : sem ;}
     rule{ typechange: atomicmod arg => pre-cop-adj(, modee, arg) : sem ;}
 }


#######################################
# MODIFIER DEPENDENCY RELN SEMANTICS  #
#######################################

# This the generic dependency relation used by ALL MODIFIERS (all adj, pp, adv, ect) 
# in when they are used as modifiers, i.e., this is added the 
# the semantics of the modifee within all of the various complex category type changing rules
# used to turn atomic modifiers into complex modifiers. 

 def MODIFIER(args) {<Modifier>(M  args) }


#####################################
# MODIFIER ARGUMENTS: SLOTS & ROLES # 
#####################################

# These are the syntactic slots and corresponding semantic roles
# used for modifiers with arguments (ma = Modifier Argument)

  # NP/OBL SLOT #
  
  def np_ma(args)            { np<30>[A args] }
  def n_ma(args)             { n<30>[A args] }
  def obl_ma(mrk, args)      { obl<30>[A MARK=mrk args] }
  def obln_ma(mrk, args)      { obln<30>[A MARK=mrk args] }
  

  def ARG(args)              { <Anchor>(A args) }

  # S SLOT #

  def s_ma(args)         { s<31>[G args] }
  def E-ARG(args)		 { <Event>(G args) }


#########
# OTHER #
#########

  # This is the semantic dependency relation used by modifier modifiers,
  #     e.g.  'really' big , 'over' on the table, etc. 
  # The syntactic categories are defined locally in the appropriate
  # modifier .ccg file 
  
  def M-MOD(args)        { <Modifier>(MM args) }


#######################
## DICTIONARY FORMS  ##
#######################

  # modify a given pos (adj, adv, prep, etc) on the given side (pre, post)

  def modifier(form, pos, side, class) {  _modifier(form, form, pos, side, class)  }
  def _modifier(prd, form, pos, side, class) {
    word form.-mod-.side."-".pos."-".class : "Mod-" . side . "-" . pos ."-" ("m-".class, pred=prd)
	{form;}
  } 



###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def n(args)         { n<15> [T CASE NUM PERS NFORM args] }
  def np(args)        { np<15>[T CASE NUM PERS NFORM args] }
   
  def from-n(args)    { n<~15> [T args] }
  def from-np(args)   { np<~15>[T args] }
 
  # This is a 'case' marked np, like the 'with the ball' in 'play with the ball'
  # verbs can specify what marking they recieve. See Markers.ccg for the oblique family
  
  def obl(mrk, args)  { obl<15>[T MARK=mrk args] }
 
   
   
##########################
## SEMANTIC DEFINITIONS ##
##########################

  def ENTITY(args)      { T:entity(args) }
  def OWNER(args)       { <Owner>(O:entity args) }
   
##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def n-cat(args, sem)         { n() args   :   ENTITY( sem) ; }
  def np-cat(args, sem)        { np() args  :   ENTITY( sem) ; }
 
  ## The Families ##
 
  family Noun          { entry: n-cat (               , *         )  }
  
  # July 24, took out contextualized readings at GJ's request, didn't like em popping up in questions
  #
  family Noun+of-np    { entry: n-cat ( / obl_ma(of, Questionable=no) , * <Owner>(A:entity) ) }
                      #   entry: n-cat (               , * <Owner>(A:entity context) ) }
  family Noun+of-n     { entry: n-cat ( / obln_ma(of, Questionable=no) , * <Owner>(A:entity) )  }
                      #   entry: n-cat (                   , * <Owner>(A:entity context) )  }
  family Noun+number   { entry: n-cat ( / number[N] , * <Id>(N:number-cardinal) )  } 

  family Bare-np       { entry: np-cat(               , *        )  }
 
  family Bare-np+of-np { entry: np-cat( / obl_ma(of, Questionable=no) , * <Owner>(A) )  }

  family Context-np+modifier           { entry: np-cat ( , context MODIFIER(*) ) }
  family Context-n+modifier            { entry: n-cat  ( , context MODIFIER(*) ) }

  family Event-np                      { entry: s() : EVENT(*) ; }
  
  # The ugliness here is due to the fact that semantically, we need owner to 'inherit' the number from the word.
  # i.e. 'mine' should have <Owner>( I ^ sg) and 'ours' <Owner>( I ^ pl)
  # The two entries are do to the fact that every owned-np is ambigous between singular and plural 
	
  family Owned-np      { entry: np<16>[T2 s-sg CASE 3rd full]     :  T2:entity(context SG() <Owner>(T *) UNIQUE() SPECIFIC);
                         entry: np<16>[T2 s-pl CASE 3rd full]     :  T2:entity(context PL() <Owner>(T *) VARIABLE() UNSPECIFIC() ); }

  family Owner-pro     { entry: np<~16>[T2 3rd] /^ n<16>[T2 s-sg] :  T2:entity( <Owner>(T *) SG() UNIQUE() SPECIFIC()       );
                         entry: np<~16>[T2 3rd] /^ n<16>[T2 s-pl] :  T2:entity( <Owner>(T *) PL() UNIQUE() SPECIFIC() ); }

  # Negation and Coordition #  

  family Negation-np-(indexRel=polarity)  { entry:  from-np() \ np() :  ENTITY( NEG()  )   ;}
  family Coord-np-       { entry:  np(COM=yes) / np[N] \* np[F COM=no]   : T( * <First>(F) ^ <Next>(N) ) ;}
  family Coord-n-        { entry:  n(COM=yes) / n[N]   \* n[F COM=no]    : T( * <First>(F) ^ <Next>(N) ) ;}


###########
## RULES ##
###########

	
  # These essentially act as determiners, turning plural and mass nouns into np 
  # with the appropriate semantic marking
  
  rule { typechange: n(s-pl-unsp)     =>  from-np(3rd)       :  ENTITY( VARIABLE() UNSPECIFIC() ) ; } 
  rule { typechange: n(s-pl-sp)       =>  from-np(3rd)       :  ENTITY( VARIABLE() SPECIFIC() ) ; }
  rule { typechange: n(s-mass)        =>  from-np(3rd s-sg)  :  ENTITY( VARIABLE() UNCOUNTABLE() ) ; } 

  # This rule is for handling Compound Nouns. It turns any random noun into a pre-n modifier 
  # NOTE: This currently has number attached. Do we want this? Could add another n form....
  # NOTE2: Could (should?) extend this idea for handling multi-word expressions...
    
  rule { typechange: n[T2 full compound-1st]     =>  from-n(cc-none) /* n(compound-head)  :  ENTITY( <Compound>(T2) ) ; } 

  
#######################
## DICTIONARY FORMS  ##
#######################

  # Basic nouns, regular and irr

  def  noun(sing, class, args)       {  noun-irr(sing, pluralize(sing), class, args) }
  def _noun(prd, sing, class, args) { _noun-irr(prd, sing, pluralize(sing), class, args) }
  
  def  noun-irr (sing, plur, class, args) { _noun-irr(sing, sing, plur, class, args) } 
  def _noun-irr(prd, sing, plur, class, args) {
    word sing.-noun-n:Noun(class, pred=prd) {
      sing :  s-sg full args;
      plur :  s-pl-unsp full args;
    }
  }
  

  # Basic nouns with of-np, of-n, number compliments, regular and irr
  # should generalize with one macro!

  def  noun+of-np(sing, class, args)      {  noun-irr+of-np(sing, pluralize(sing), class, args) }
  def _noun+of-np(prd, sing, class, args) { _noun-irr+of-np(prd, sing, pluralize(sing), class, args) }

  def  noun-irr+of-np(sing, plur, class, args) { _noun-irr+of-np(sing, sing, plur, class, args) }
  def _noun-irr+of-np(prd, sing, plur, class, args) {
   word sing.-noun-n-of-np:Noun+of-np(class, pred=prd) {
      sing :  s-sg full args;
      plur :  s-pl full args;
    }
  }

  def  noun+of-n(sing, class, args)      {  noun-irr+of-n(sing, pluralize(sing), class, args) }
  def _noun+of-n(prd, sing, class, args) { _noun-irr+of-n(prd, sing, pluralize(sing), class, args) }

  def  noun-irr+of-n(sing, plur, class, args) { _noun-irr+of-n(sing, sing, plur, class, args) }
  def _noun-irr+of-n(prd, sing, plur, class, args) {
   word sing.-noun-n-of-n:Noun+of-n(class, pred=prd) {
      sing :   s-sg full args;
      plur :   s-pl full args;
    }
  }
  
  # Others
  
  def  noun-mass(form, class, args) { _noun-mass(form, form, class, args) }
  def _noun-mass(prd, form, class, args) {
    word form.-mass-n : Noun(class, pred=prd) {
      form  :  s-mass  full args;
    }
  }

  def name(form, class, args) { _name(form, form, class, args) }
  def _name(prd, form, class, args) {
    word form.-name:Bare-np(class, pred=prd) {
      form :  s-sg 3rd full args;
    }
  }
 
 def pronoun(prd, pers, num, nom-form, acc-form, owner, owned, class,) {
    word prd.-pro-.pers-.num:Bare-np(class, pred=prd) {
      nom-form :  pers s-.num nom pro num;
      acc-form :  pers s-.num acc pro num;
    }
    word prd.-owner-.num:Owner-pro('entity', pred=prd) {
      owner : num ;
	}
    word prd.-owned-.num:Owned-np('entity', pred=prd) {
      owned : num ;
	}
  }

 def context-s(form, args) {
    word form.-deictic-pro-event : Event-np ('event', pred=context) {
      form : fin-deictic m-class-none s-dependent args;    
    }
 }

 # Context nouns and context nouns + modifiers (e.g. those three, the red, etc)
 # are set to c-class n-4, meaning they can't interact with the n-n compound rule
 # this blocks stupid readings for  'three balls' and for 'room 3'  

 def context-n(form,class, args) {_context-n(form, form, class, args)}
 def _context-n(prd, form, class, args) {
    word form.-context-n : Noun (class, pred=context) {
      form : args nf-ctxt n-4;    
    }
 }

 def context-np(form,class, args) {_context-np(form, form, class, args)}
 def _context-np(prd, form, class, args) {
    word form.-context-np : Bare-np (class, pred=context) {
      form : 3rd args nf-ctxt;    
    }
 }

 def context-n+modifier(form,class, args) {_context-n+modifier(form, form, class, args)}
 def _context-n+modifier(prd, form, class, args) {
    word form.prd.-context-n+modifier : Context-n+modifier (class, pred=prd) {
      form : args nf-ctxt n-4;    
    }
 }

 def context-np+modifier(form,class, args) {_context-np+modifier(form, form, class, args)}
 def _context-np+modifier(prd, form, class, args) {
    word form.prd.-context-n+modifierp : Context-np+modifier (class, pred=prd) {
      form : 3rd args nf-ctxt;    
    }
 }


  def pluralize(word) {
    # If the word ends in a vowel + o or y,
    # we add s.  Else, if the word ends in (consonant) + o or y, or s, sh, ch,
    # or x, we change y to i and add es.  Finally, in all other cases,
    # just add s.  So buy -> buys, boy-> boys, but try -> tries, lady -> ladies.
    # Similarly, go -> goes but goo -> goos.  For words like volcano -> volcanos
    # you have to put the forms in manually (or change the rule here, and put
    # forms in -o + es in manually, e.g. does, goes, tomatoes, potatoes).
    #
    ifmatch('^.*[aeiou][oy]$', word, word . s,
      ifmatch('^.*([sxoy]|sh|ch)$', word, regsub('^(.*)y$', '\1i', word) . es,
              word . s))
  }









######################### OLD!!! ###########################

  # Not currently working. Need to create a marking and rule to transform 
  # context nouns into np, allowing modification

  def CONTEXT(args)     { <Context>(T:entity args) }
  def shell-np-cat(args, sem)  { np<15>[T2 NUM CASE PERS] :  T2(* sem);}
  def shell-n-cat(args, sem)   { n<15>[T2 NUM CASE PERS]  :  T2(* sem);}
  family Context-np    { entry: shell-np-cat(, CONTEXT() )     }
  family Context-n     { entry: shell-n-cat (, CONTEXT() ) }

  def context-pronoun(form, num, args) {

    word form.-ctxt-pro-np : Context-np ('entity', pred=form) {
      form :  s-.num num full args;     
    }
 	word form.-ctxt-pro-n : Context-n ('entity', pred=form) {
      form :  s-.num num full args;     
    }
  }
 
   
  

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def adj(args)         { adj<25>[M DEGREE args] }

  def from-adj(args)    { adj<~25>[M args] }


##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def adj-cat(args, sem)   { adj() args  :  M(* sem) }
  
  ## The Families ##

  family Adj						 { entry:  adj-cat(,) ;}
  family Adj+of-np					 { entry:  adj-cat( / obl_ma(of,), ARG() ) ;}
  
  # Modifiers #
  
  family Mod-pre-adj-                { entry:  from-adj() /^ adj()                :  M( M-MOD(*) ) ;}
  family Mod-pre-adj-comparative-    { entry:  from-adj() /^ adj(s-comparative)   :  M( M-MOD(*) ) ;}
  
  family Mod-post-adj-               { entry:  from-adj() \ adj()                 :  M( M-MOD(*) ) ;}
    
  family More-adj(indexRel=degree)   { entry:  from-adj(s-comparative)  / adj(s-degree-base)   ;}
  family Most-adj(indexRel=degree)   { entry:  from-adj(s-superlative)  / adj(s-degree-base)   ;}
  
  family Adj-er-than				 { entry:  from-adj() / np_ma() \* adj(s-comparative) : M( M-MOD(* ARG() )  ) ;}

  # Negation and Coordition #
  
  family Negation-adj-(indexRel=polarity)  { entry:  from-adj() \ adj() :  M( NEG()  ) ;}
  family Coord-adj-                   { entry:  adj[R COM=yes] / adj[N] \* adj[F COM=no] : COORD(*) ;}


###########
## RULES ##
###########

  # The following rule converts the 'base-generated' atomic cat versions of adjectives into
  # their complex-cat form (i.e. the form that actually attach to and modify nouns)

  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() ) categories
  # used in these rules  

  rule { typechange: adj(pre-n)$1  =>  pre-n(, $1) :  ENTITY( MODIFIER() ) ; } 
  
#######################
## DICTIONARY FORMS  ##
#######################

   def _adj-none(prd, base, class, args) {
    word base.prd.-adj:Adj(class, pred=prd) {
      base : s-degree-base args;
    }
  }
  def adj-none(base, class, args) { _adj-none(base, base, class, args) }

  def _adj-deg(prd, base, comp, sup, class, args) {
    word base.-adj:Adj(class, pred=prd) {
      base : s-degree-base pre-n args;
	  comp : s-comparative pre-n comparative args;
	  sup  : s-superlative pre-n superlative args;
    }
  }
  def adj-deg(base, comp, sup, class, args) {_adj-deg(base, base, comp, sup, class, args) }

# This file contains the stuff necessary for determiners, both those
# handled via features only (a, the, some, this, that) and those
# with a semantic head (two balls, every ball, etc)
# I have called these Dets & SDets respectively

# It also contains the stuff for handling and semantic groups, 
# like 'some of the balls over there' or 'the first of GJ's mugs'
# as well as the possessive 's .

# Possessive pronouns have been handled in the pronoun dictionary-macro
# located in noun.ccg (this is due to ordering issues)
  
##########################
## SEMANTIC DEFINITIONS ##
##########################

#def GROUP(sem) { ENTITY(group <Set>(A) sem) }
def GROUP(sem)  { A( <Subgroup>(T:entity ^ subgroup ^ sem) ) }
     
##############
## FAMILIES ##
##############

family Det(indexRel=Delimitation)        { entry: from-np(3rd) /^ n()                   ;}
family Group-np(indexRel=Delimitation)   { entry: np<15>[A] /^ obl_ma(of, s-pl)    : GROUP  () ;}

family SDet                              { entry: from-np(3rd) /^ n()              : ENTITY ( MODIFIER(*) ) ;}
family Un-to-Spec-Det                    { entry: from-n(s-pl-sp) /^ n(s-pl-unsp)  : ENTITY ( MODIFIER(*) ) ;}
family SGroup-np                         { entry: np<15>[A full 3rd s-pl]    /^ obl_ma(of, s-pl) : GROUP  ( MODIFIER(*) ) ;}
family SGroup-np-no-of                   { entry: np<15>[A full 3rd s-pl]    /^ np_ma(s-pl) : GROUP  ( MODIFIER(*) ) ;}
family SGroup-n                          { entry: n<15>[A full s-pl]     /^ obl_ma(of, s-pl) : GROUP  ( MODIFIER(*) ) ;}

family Det-poss-s(indexRel=Owner)        { entry: from-np()    /^ n() \* np[O]     : ENTITY (<Owner>(O) )    ;} 

# cardinal numbers (one, two, three) are used in many ways (see the def macro number in closed dictionary)
# this is an entry used in the immediately following rule to handle, e.g. 'floor 3', 'office 101', etc.
# It functions as a determiner, taking a noun and turning it into an 'Id'd specific, singular np.
 
family Number-id      { entry: nid<16>[M] : M(*) ; }

# ****** This is NOT INCREMENTAL, i.e. 'go to floor' doesn't parse, but 'go to floor 3' does.
# This should be converted to a rule which turns n's into np's wanting a following number
# HOWEVER, b/c this rule was added mid-devil, I didn't want to add a generally applicable rule!

rule { typechange: nid[M]  =>  from-np(3rd) \* n(s-sg) :  ENTITY( <Modifier>(M) SPECIFIC() SG() UNIQUE() ) ; }


#######################
## DICTIONARY FORMS  ##
#######################

def det(form, args) {
    word form.det: Det {
      form : args;
    }
 }

def group-np(form, args) {
    word form.group-np: Group-np {
      form : s-pl args;
    }
 }


def sdet(form, class, args) { _sdet(form, form, class, args) }
def _sdet(prd, form, class, args) {
    word form.prd.sdet: SDet(class, pred=prd) {
      form :  args;
    }
 }


def un-to-spec-det(form, class) { _un-to-spec-det(form, form, class) }
def _un-to-spec-det(prd, form, class) {
    word form.prd."un-to-spec": Un-to-Spec-Det(class, pred=prd) {form;}
 }


def sgroup-np(form, class, args) { _sgroup-np(form, form, class, args) }
def _sgroup-np(prd, form, class, args) {
    word form.prd.sgroup-np: SGroup-np(class, pred=prd) {
      form : s-pl args;
    }
 }

def sgroup-np-no-of(form, class, args) { _sgroup-np-no-of(form, form, class, args) }
def _sgroup-np-no-of(prd, form, class, args) {
    word form.prd.sgroup-np-no-of: SGroup-np-no-of(class, pred=prd) {
      form : s-pl args;
    }
 }

def sgroup-n(form, class, args) { _sgroup-n(form, form, class, args) }
def _sgroup-n(prd, form, class, args) {
    word form.prd.sgroup-n: SGroup-n(class, pred=prd) {
      form : args;
    }
 }

def  number-id (form) { _number-id(form,form) } 
def _number-id(prd, form) {
    word form."-number-id": Number-id("number-id", pred=prd) { form; }
  }



###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def pp_bare(args)       { pp<25>[M args] }
  def pp(args)            { pp_bare(MOD-TYPE CC-TYPE args) }
  def from-pp(args)       { pp<~25>[M args] }

  # A preposition is a prep-phrase (pp) wanting a np argument
  #
  def prep(p-arg, np-arg) { pp(p-arg) /^ np_ma(np-arg acc-both) }
  def prep+obl(p-arg, obl-arg) { pp(p-arg) /^ obl_ma(obl-arg, acc-both) }

  def from-prep(p-arg, np-arg) { from-pp(p-arg) /^ np_ma(np-arg acc-both) }
  def from-prep+obl(p-arg, obl-arg) { from-pp(p-arg) /^ obl_ma(obl-arg, acc-both) }

 # def prep(p-arg, np-arg) { pp(p-arg) /^ np_ma(np-arg ) }
 # def prep+obl(p-arg, obl-arg) { pp(p-arg) /^ obl_ma(obl-arg, ) }


##############
## FAMILIES ##
##############

  ## The Families ##

  family Prep						 { entry:      prep(,)           :  M(* <Anchor>(A:physical) ) ;  }
  family Prep+of-np-	    		 { entry:      prep+obl(, of)    :  M(* <Anchor>(A:physical) ) ;}
  family Prep+to-np-	    		 { entry:      prep+obl(, to)    :  M(* <Anchor>(A:physical) ) ;}
  family Prep+from-np-	    		 { entry:      prep+obl(, from)  :  M(* <Anchor>(A:physical) ) ;}
  family Prep+no-arg-				 { entry:      pp()              :  M(*)        ;}
 
  family Prep--time-unit                { entry:      prep(,)           :  M(* <Anchor>(A:e-time-unit) ) ;  }
  
  # This is used for 'to your right' 'to the left of the ball'
  #
  # It is blocked from being questionable, so that 'what is the ball to' doesn't parse...
  #
  family Prep--region                   { entry:      prep(, Questionable=no)           :  M(* <Anchor>(A:e-region) ) ;  }
	   
  # Modifiers #
   
  family Mod-pre-prep-               { entry:  from-pp() /^ pp()   :  M( M-MOD(*) ) ;}
  family Mod-post-prep-              { entry:  from-pp() \ pp()    :  M( M-MOD(*) ) ;}
    
  # Negation and Coordition #
  
  family Negation-prep-(indexRel=polarity)  { entry:  from-pp() \ pp()             :  M( NEG() )  ;}
  family Coord-prep-                        { entry:  pp<~51>[R COM=yes] /^ pp<~51>[N] \* pp<51>[F COM=no] :  COORD(*)    ;}  

###########
## RULES ##
###########

  # The following rules convert the 'base-generated' atomic cat versions of pps and turns them
  # into their complex-cat form (i.e. the form that actually attach to and modify nouns and sentences)
  # Remember, this combinatorial capacity is specified in the actual dictionary entry of the word
  # by assigning it to a particular cc-class
 
  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() ) categories
  # used in these rules  
	    
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT: If either the dependency relation name (e.g. <Modifier> , <Location> ) or the
  #            modifier section of the ontological hierarchy is changed, you will have to add
  #            a new 'instance' of these rules for each.
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ## Nominal Modifiying Rules ##
 
  # All preps which can modify nouns, post-modify them ( 'the ball on the table', not 'the on the table ball')
  #
  def prep-rule-n(mod-type){
      rule { typechange: pp(x-.mod-type post-n)$1        =>     post-n(, $1)   :  ENTITY( MODIFIER() ) ; }
  }

  # One 'instance' of the rule for each of the modifier classes (from ontology)
  #
  prep-rule-n(location)
  prep-rule-n(comparison)
  prep-rule-n(accompaniment)
  prep-rule-n(benefactor)


  ## Sentential Modifying Rules ##
  #
  # For each of the many sentential/clausal possibilities for prepositions, their is a corresponding rule.

  def prep-rule-s(mod-type){
      rule { typechange: pp(x-.mod-type pre-s)$1           =>   pre-s(s-.mod-type, $1)         :  EVENT( MODIFIER() ) ; } 
      rule { typechange: pp(x-.mod-type pre-vp)$1          =>   pre-vp(s-.mod-type, $1)        :  EVENT( MODIFIER() ) ; } 
      rule { typechange: pp(x-.mod-type post-s)$1          =>   post-s(s-.mod-type, $1)        :  EVENT( MODIFIER() ) ; } 
      rule { typechange: pp(x-.mod-type post-vp)$1         =>   post-vp(s-.mod-type, $1)       :  EVENT( MODIFIER() ) ; } 
	#  rule { typechange: pp(x-.mod-type post-s-loose)$1    =>   post-s-loose(s-.mod-type, $1) :  EVENT( MODIFIER() ) ; } 
  }

  # One 'instance' of the rule for each of the modifier classes (from ontology)
  #
  prep-rule-s(location)
  prep-rule-s(dynamic)
  prep-rule-s(comparison)
  prep-rule-s(accompaniment)
  prep-rule-s(instrumental)
  prep-rule-s(benefactor)
  prep-rule-s(manner)
  prep-rule-s(time)
  
   
  ### Other Rules ###
  
  # These rules handle 
  # 1) nested locationals such as 'It is in the room on the table'
  #    c.f.   get me the ball on the table
  #    Note that this does not give the underlying semantics  (ball on table, table in room) but must be
  #    built grammar externally. This was due to problems in incrementally building 
  #   'inside out' semantic structures like this. 
  #
  # 2) sequences of dynamics: go into the hall, down the corrider ....
  # 


 #  rule { typechange: pp<52>[F x-dynamic CC-TYPE:CC-TYPE COM=no]   =>    pp<53>[R x-dynamic CC-TYPE:CC-TYPE COM=yes] /^   pp<54>[N x-dynamic CC-TYPE:CC-TYPE]  
 #                                                                 : R:m-dynamic( list <First>(F:m-dynamic) ^ <Next>(N:m-dynamic) ) ; }

 #  rule { typechange: pp<52>[F x-location CC-TYPE:CC-TYPE COM=no]   =>   pp<53>[R x-location CC-TYPE:CC-TYPE COM=yes] /^  pp<54>[N x-location CC-TYPE:CC-TYPE] 
 #																   : R:m-location( list <First>(F:m-location) ^ <Next>(N:m-location) ) ; }



 


	   
#######################
## DICTIONARY FORMS  ##
#######################
 
 ## For Prepositions with Physical Anchors
 ##
 def _prp(prd, form, class, args) {
    word form.-prep-.class :Prep(m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp(form, class, args) { _prp(form, form, class, args) }

 ##   
 def _prp+(arg, prd, form, class, args) {
    word form."-prep+".arg."-".class :"Prep+".arg."-" (m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp+(arg, form, class, args) { _prp+(arg, form, form, class, args) }

 ### With degrees (closer to, farthest from)
 #
 def _prp-deg+(arg, prd, form, comp, sup, class, args) {
    word form."-prep-deg+".arg."-".class :"Prep+".arg."-" (m-.class, pred=prd) {
      form : x-.class args;
	  comp : x-.class comparative args;
	  sup : x-.class superlative args;

    }
  }
 def prp-deg+(arg, form, comp, sup, class, args) { _prp-deg+(arg, form, form, comp, sup, class, args) }

 ##
 def _prp-deg(prd, form, comp, sup, class, args) {
    word form."-prep-deg".class :Prep(m-.class, pred=prd) {
      form : x-.class args;
	  comp : x-.class comparative args;
	  sup : x-.class superlative args;
    }
  }
 def prp-deg(form, comp, sup, class, args) { _prp-deg(form, form, comp, sup, class, args) }


 ## For Prepositions with Time-Unit Anchors
 ##
 def _prp--(subsort, prd, form, class, args) {
    word form.-prep-.class.subsort :"Prep--".subsort(m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp--(subsort, form, class, args) { _prp--(subsort, form, form, class, args) }




  
# OLD ATTEMPTS at pp chain rules

# THIS WORKS, but NOT INCREMENTALLY A 2nd entry for preps. Attempts at handling nested-locationals: emailed GJ
#									   entry:      prep(,) \^ pp<52>[W x-location]    :  M(* ARG(<L-Mod>(W) ) ) ; 	  


#  rule { typechange: pp(x-location)    =>  pp() /(pp<53>[R x-location] / np_ma()) :  R( <Arg>(A <Modifier>(M) ) ); }
#  rule { typechange: pp<53>[R x-location]    =>  prep(x-location, ) :  A( <Modifier>(R) ) ; }
# rule { typechange: pp<52>[F x-location]   =>   pp<53>[R x-location] /^  pp<54>[N x-location] : R:m-location( nested <Inside>(F:m-location) ^ <Outside>(N:m-location) ) ; }
# rule { typechange: pp<52>[F x-location]    =>  from-pp() \* pp(x-location) :  M( <Modifier>(F) ) ; }
#  rule { typechange: pp<53>[R x-location]$1    =>   pp<53>[R x-location] /^ prep(x-location, ) $1 :  M:m-location( <Arg>(A:entity <Modifier>(R) ) ); }
#    rule { typechange: pp<52>[W x-location]$1           =>   from-pp(x-location) $1 \* pp()        :  M(<Scope>(W) ); } 
#    rule { typechange: pp<52>[W x-dynamic]$1            =>   from-pp(x-dynamic) $1 \* pp()         :  M(<Scope>(W) ); } 
#    rule { typechange: pp<52>[W x-location]$1           =>   from-pp(x-location) $1 \* pp()        :  M(<Scope>(W) ); } 
#    rule { typechange: pp<52>[W x-dynamic]$1            =>   from-pp(x-dynamic) $1 \* pp()         :  M(<Scope>(W) ); } 

#   rule { typechange: pp<52>[F x-location CC-TYPE:CC-TYPE]   =>   pp<53>[R x-location CC-TYPE:CC-TYPE] /^  pp<54>[N x-location CC-TYPE:CC-TYPE] 
#																   : R:m-location( nested <Inside>(N:m-location) ^ <Outside>(F:m-location) ) ; }


###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def adv(args)         { adv<25>[M DEGREE args] }
  def from-adv(args)    { adv<~25>[M args] }

##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def adv-cat(args, sem)   { adv() args  :  M(* sem) }
  
  ## The Families ##

  family Adv				 { entry:  adv-cat(,) ;}
  family Adv+dep-clause-               	 { entry:  adv-cat( / s_ma(s-dependent MARK=none), E-ARG() ) ;}
  
  family Adv+verb-ing-			     { entry:  post-vp( MCLASS , / (s_ma(ing) +subj() ) ) : EVENT( <Modifier>(M * E-ARG() ))  ;}
  family Adv+verb-base-			     { entry:  post-vp( MCLASS , / (s_ma(vf-base) +subj() ) ) : EVENT( <Modifier>(M * E-ARG() ))  ;}

  # Modifiers #
  
  family Mod-pre-adv-                { entry:  from-adv() /^ adv()   :  M( M-MOD(*) ) ;}
  family Mod-post-adv-               { entry:  from-adv() \ adv()    :  M( M-MOD(*) ) ;}
    
  # Negation and Coordition #
  
  family Negation-adv-(indexRel=polarity)  { entry:  from-adv() \ adv() :  M( NEG()  ) ;}
  family Coord-adv-                        { entry:  adv[R COM=yes] / adv[N] \* adv[F COM=no] : COORD(*) ;}

###########
## RULES ##
###########

 
  # The following rules convert the 'base-generated' atomic cat versions of advss and turns them
  # into their complex-cat form (i.e. the form that actually attach to sentences/clauses/verbs)
  # Remember, this combinatorial capacity is specified in the actual dictionary entry of the word
  # by assigning it to a particular cc-class
 
  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() ) categories
  # used in these rules  
 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT: If either the dependency relation name (e.g. <Modifier>  ) or the
  #            modifier section of the ontological hierarchy is changed, you will have to add
  #            a new 'instance' of these rules for each.
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  # Sentential Modifying Rules #
  #
  # For each of the many sentential/clausal possibilities for adverbs, their is a corresponding rule.

  def adv-rule(mod-type){
    rule { typechange: adv(x-.mod-type pre-s)$1           =>   pre-s(s-.mod-type, $1)         :  EVENT( MODIFIER() ) ; } 
    rule { typechange: adv(x-.mod-type pre-vp)$1          =>   pre-vp(s-.mod-type, $1)        :  EVENT( MODIFIER() ) ; } 
   
    rule { typechange: adv(x-.mod-type post-s)$1          =>   post-s(s-.mod-type, $1)        :  EVENT( MODIFIER() ) ; } 
    rule { typechange: adv(x-.mod-type post-vp)$1         =>   post-vp(s-.mod-type, $1)       :  EVENT( MODIFIER() ) ; } 
  
	# HACK (see adv.ccg)
    rule { typechange: adv(x-.mod-type pre-vp)$1          =>   pre-vp-in-rel-clause(s-.mod-type, $1)        :  EVENT( MODIFIER() ) ; } 
   
	
    mod-rule-pre-cop ( adv(x-.mod-type pre-cop-comp) , $1 , "s-".mod-type , EVENT( MODIFIER() )   )
	
    #  rule { typechange: adv(x-.mod-type post-s-loose)$1   =>   post-s-loose(s-.mod-type, $1)  :  EVENT( MODIFIER() ) ; } 
  }

  # One 'instance' of the rule for each of the modifier classes (from ontology)
  #
  adv-rule(dynamic)
  adv-rule(location)
  adv-rule(manner)
  adv-rule(time)
  adv-rule(probability)
  adv-rule(frequency)
  adv-rule(comment)
  adv-rule(relational)
 
	 
#######################
## DICTIONARY FORMS  ##
#######################

 def adverb(base, class, cc-class, args)  { _adverb(base, base, class, cc-class, args) } 
 def _adverb(prd, base, class, cc-class, args) {
    word base.-adv:Adv("m-".class, pred=prd) {
      base : s-degree-base x-.class cc-class args;
    }
  }

 def adverb-deg(base, comp, sup, class, cc-class, args) { _adverb-deg(base, base, comp, sup, class, cc-class, args)}
 def _adverb-deg(prd, base, comp, sup, class, cc-class, args) {
    word base.-adv-deg:Adv("m-".class, pred=prd) {
      base : s-degree-base x-.class cc-class args;
	  comp : s-comparative x-.class cc-class comparative args;
	  sup  : s-superlative x-.class cc-class superlative args;
    }
  }

 def adverb+(arg, form, class, cc-class, args) {_adverb+(arg, form, form, class, cc-class, args) } 
 def _adverb+(arg, prd, form, class, cc-class, args) {
    word form."adv+".arg : "Adv+".arg."-"("m-".class, pred=prd)
	{form : x-.class cc-class args;}
  } 


# This file contains all of the stuff necessary for 
# standard verbs, the copular and mood rules

#################################
# VERB ARGUMENTS: SLOTS & ROLES # 
#################################

# These are the syntactic slots and corresponding semantic roles
# used for verbal arguments(compliments)

# Semantic Role cats are, like all semantic cats, in CAPS.

# The general format for syn-cat names is type_slot# (args) for the bare compliment itself.
# For the comp plus its slash, +type_slot# (args)

# The slots are numbered based on their left to right position after the verb itself, so
#	    	_SUBJ_	 VERB		_1_			_2_				_3_
                        
# 1)		  I      slept  
# 2)		  I      hit		the ball
# 3)		  I      gave		him			the ball
# 4)		  I		 gave		it			to  him
# 5)		  I		 picked		it			up
# 6)		  I		 put		it			on the table
# 7)          I		 want								    to run
# 8)	      I	     want		him							to run
		 
# As you can see, the slot position is independent of the category (or kind) of the compliment.
# So in 3, 4, 5, 6 we have a NP, an OBLIQUE, a PARTICLE and a PP all in slot 3. Thus,
# the variable name for a given syntactic argument is a combination of category and slot position:
# Verb(vp) & Sentence comps are an exception, they are always in slot 3.. this was just a pragmatic
# decision to avoid doubling all of the cats.

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #         Although there are no semantic constraints for entites (animacy, etc)
  #         some of these verb-roles are restricting for modifiers (where-to and location, e.g.)
  #         Changes to the modifier section of ontological hierarchy will need be reflected here
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  



  # SUBJECT SLOT ##
  
    def ACTOR(args)     { <Actor>(S:entity args) }
  
  ## COMP SLOT 1 ##
  
    def np_1(args)           { np<2>[X acc args] }            def +np_1(args)          { / np_1(args) }
	def +np_1-subj(args)     { \ np<~2>[X nom] }  # this is for 'object-controlled vp comps' like 'I want him to get it'

    def obl_1(frm, args)     { obl<2>[X acc MARK=frm args] }  def +obl_1(frm, args)    { / obl_1(frm, args) }
    def adj_1(args)          { adj<2>[X args] }               def +adj_1(args)         { / adj_1(args) }
    def pp_1(args)           { pp<2>[X args] }                def +pp_1(args)          { / pp_1(args) } 
    def s_1(feats)           { s<2>[X feats] }                def +s_1(feats, args)    { / ( s_1(feats) args ) }
	   
    def PATIENT(args)        { <Patient>(X:entity args) }

    def INSTRUMENT(args)     { <Modifier>(M:m-instrumental ^ with <Arg>(X:entity args) ) }  # used in family for 'use'  you can use the coffee maker to make coffee'

  ## COMP SLOT 2 ##
   
	def np_2(args)           { np<3>[Y acc args] }            def +np_2(args)          { / np_2(args) }
	def +np_2-subj(args)     { \ np<~3>[Y nom] }  
	def obl_2(frm, args)     { obl<3>[Y acc MARK=frm args] }  def +obl_2(frm, args)    { / obl_2(frm, args) }
    def adj_2(args)          { adj<3>[Y args] }               def +adj_2(args)         { / adj_2(args) }
    def pp_2(args)           { pp<3>[Y args] }                def +pp_2(args)          { / pp_2(args) }
    def prt_2(args)          { prt<3>[Y args] }               def +prt_2(args)         { / prt_2(args) }

    def RECIPIENT(args)      { <Recipient>(Y:entity args) }
	def PARTICLE(args)       { <Particle>(Y args) }
	
	# These are all given dependecy <Result>, but have different semantic resrictions on their arg
  	def R-LOC(args)            { <Result>(Y:m-location args) }
	def R-WHERETO(args)        { <Result>(Y:m-dynamic args) }
	def R-QUALITY(args)        { <Result>(Y:quality args) }
	
	def R-MODIFIER(args)       { <Result>(Y:modifier args) }
	def R-ENTITY(args)         { <Result>(Y:entity args) }

  ## COMP SLOT 3 ## 

   def s_3(feats)           { s<4>[Z feats] }      def +s_3(feats, args)    { / ( s_3(feats) args ) }
   def ECOMP(args)          { <Event>(Z:event args) }


##############
# MOOD RULES #
##############

  # The mood of a clause is projected as early as possible. i.e. we don't wait for the verb.
  # Instead, the first 'core' element of the clause does this
  #   Indicative: a free standing, clause initial NP
  #   Imperative: a base form verb wanting a subject (see below for dropped subjects)
  #   Interrogative: auxillaries in Y/N & Wh-words in Wh cases (see wh-words.ccg , verb-finite.ccg and copular section below for more)  
 
  rule {no typeraise;   # b/c indicative rule handles the building of standard indicative clauses, no need for type-raise
                        # this removes the unncessary readings
	no sub;}        # THIS ADDED TO KILL STUPID COLLAPSED ARG READINGS 'put this on the table' with this & table co-indexed.


  # The 'floating' subject np in the early stages of the (incremental) parsing of indicatives and interrogatives
  # is integrated into the utterance semantics by assigning it to the dependency slot <Subject>
  # Althoug it may seem it, this is not entirely a hack.
  # At these early stages, this np may not have a Thematic (Ideational) role (i.e actor, patient, etc) assigned to it by
  # its verb, but it has a very important interpersonal role. It is the thing which is argued with
 
  # It's big.                             
  # No, it's small, isn't it. 
  # It shouldn't be, should it.
  # etc.
  
  # i.e. it plays the role of Subject in the Mood structure of Systemic Functional Linguistics
  
  def SUBJECT(args)         { <Subject>(S:entity args) }

  # This creates indicative clauses out of any old NP, either as the subject (in Systemic Functional Grammar sense) or as a Fronted-object
  # as in 'this one I dont like'

    rule { typechange: subj() $1                           =>  from-s(s-ind ) /  ( s(VFORM:fin-clause s-minor) +subj() )  $1                             : EVENT( IND() SUBJECT() )             ; } 
    rule { typechange: np<12>[F acc nf-real] $1            =>  from-s(s-ind)  /  ( s(VFORM:fin-clause s-minor) +subj(nf-real) / np<12>[F]) /^ subj()  $1 : EVENT( IND() SUBJECT() <Fronted>(F) ); }

  # this rule creates a dependent, moodless clause with MOOD=s-dependent (the form mimics that of ind above)
  # It can be marked by 'that', 'if', 'whether', etc or not as in 'I hope you come'
  
    rule { typechange: subj() $1                           =>  from-s(s-dependent ) /  ( s(VFORM:fin-clause s-minor) +subj() )  $1                             : EVENT( SUBJECT() )             ; }

 # These rules turn verbs wanting subjects into 1) imperatives and 
 #                                               2) verbs with contextually 'alighted' (i.e. dropped) subjects
 # Despite standard claims that English is not a pro-drop language, it is still a widely attested phenomena 
 # in at least two specific 'genres'  1) single sequential episodes in narratives (see e.g. Chafe 1994)
 # and much more importantly for Moloko 2) in highly interactional discourses where the talk is directed  
 # at physical/practical tasks/actions involving the situation, i.e what is 'at hand' (see, e.g., McCarthy's work on CANCODE corpus)
 
 
 # JULY 24  ADDED restriction that nf-real to block presentational, clefts, etc from getting contextualized missing 'dummy' subject readings
 # AUG  5   ADDED vf-to-imp value, this allows verbs to  lexically select whether or not they receive an imp 
 #                (see verb and verb-no-imp dictionary macros below)         
 
   def imp-rule(args){ 
        rule { typechange: s(vf-to-imp) +subj(nf-real) args          => from-s(fin-full s-imp) args      : EVENT( IMP() SUBJECT(addressee) ); } 
 #      rule { typechange: s(fin) +subj(nf-real) args                => from-s(fin-ell s-ind-ell) args   : EVENT( IND() SUBJECT(context) ); }  
    }						 
    def imp-rule-set(args){
       rule { typechange: s(vf-base) +subj() { args }      => from-s(fin s-imp) { args }   : EVENT( IMP() SUBJECT(addressee) ); } 
#      rule { typechange: s(fin) +subj() { args }          => from-s(fin s-ind-ell) { args }   : EVENT( IND() SUBJECT(context) ); } 
    }


##############
## FAMILIES ##
##############

## Family Building Macros ##
 
  def vcat(args, sem)             {  s(s-minor) +subj(nf-real)   args   : EVENT(* ACTOR() sem)  }
  def vcat-set(args, sem)         {  s(s-minor) +subj() { args } : EVENT(* ACTOR() sem)  } # for those with sets of args
   
## The Families ##

  family iv(V)               { entry: vcat(,)                                              ; }    
						          imp-rule( )
  family tv(V)               { entry: vcat(+np_1()              , PATIENT() )              ; } 
  family v+Rec-np(V)     { entry: vcat(+np_2()              , RECIPIENT() )              ; } 
						          imp-rule( +np_1() )
  
  # Oblique objects
  #
  def v+obl(word){
                    family "v+".word."-np"(V)          { entry: vcat(+obl_1(word,)          , PATIENT() )              ; }
                	                                        imp-rule(+obl_1(word,) )
  }
  v+obl(of)
  v+obl(with)
  v+obl(for)
  v+obl(to)
  v+obl(from)
	  
								  
  family v+np+prt(V)         { entry: vcat(+prt_2() +np_1() , PATIENT() PARTICLE() )   ;
                               entry: vcat(+np_1() +prt_2() , PATIENT() PARTICLE() )   ;     }
  						          imp-rule(+prt_2() +np_1() )
 						          imp-rule(+np_1() +prt_2()  )

  family v+pp-whereto(V)  { entry: vcat(+pp_2() , R-WHERETO()  )   ;  }
  family v+pp-loc(V)      { entry: vcat(+pp_2() , R-LOC()  )   ;  }
  family v+pp(V)          { entry: vcat(+pp_2() , R-MODIFIER()   )   ; }
              		             imp-rule(+pp_2() )
 
  family v+adj(V)         { entry: vcat(+adj_2() , R-QUALITY()   )   ; }
               		             imp-rule(+adj_2() )
  
#######
#Mar 3:  So, if we don't have setarg & want /np/pp & /pp/np, we get stupid double-bound readings for put on# (>S operator does it)
#		BUT if we DO have setarg, then fronting won't parse b/c it's looking for (s\np/np)
#		
#	PROBLEMS HERE:	HOW DO WE FIGURE OUT WHAT CAN BE FRONTED/WH-QUESTIONED, HOW DOES THIS RELATE TO ORDER, ETC....
#######

### IMP-RULES DON'T WORK WITH SET-ARG (Jason confirmed this)


  family v+np+pp-whereto(V)  { entry: vcat(+pp_2() +np_1()      , PATIENT() R-WHERETO()  )   ; 
                               entry: vcat(/< np_1() /^ pp_2()  , PATIENT() R-WHERETO()  )   ;  }
  # AUG 18
  # the second entry allows 'extraction' of the patient np. We should eventually sort out a way of 'blocking' this from 
  # parsing via ind and imp rules (perhaps another layer of mood)
  #
  # THIS NEEDS TO BE GENERALIZED THROUGHOUT ARG-STRUCTURES (verb families)

							   
  family v+np+pp-loc(V)      { entry: vcat(+pp_2() +np_1()      , PATIENT() R-LOC()      )   ; 
                               entry: vcat(+np_1() +pp_2()      , PATIENT() R-LOC()      )   ;  }
 						          imp-rule(+pp_2() +np_1() )
                                  imp-rule(+np_1() +pp_2() )

 
  family v+np+adj(V)         { entry: vcat(+adj_2() +np_1()  , PATIENT() R-QUALITY()   )   ; 
                               entry: vcat(+np_1()  +adj_2() , PATIENT() R-QUALITY()   )   ; }
             		             imp-rule(+adj_2() +np_1() )
                                 imp-rule(+np_1() +adj_2() )

  family dtv(V)              { entry: vcat(+np_1() +np_2()          , PATIENT() RECIPIENT() )  ; }
  family dtv-for(V)          { entry: vcat(+np_1() +obl_2(for,)     , PATIENT() RECIPIENT() )  ; 
                               entry: vcat(+obl_1(for,) +np_2()     , PATIENT() RECIPIENT() )  ; }
  family dtv-to(V)           { entry: vcat(+np_1() +obl_2(to,)      , PATIENT() RECIPIENT() )  ; 
                               entry: vcat(+obl_2(to,) +np_1()      , PATIENT() RECIPIENT() )  ; }
		                       	          imp-rule(+np_2() +np_1() )
        					  imp-rule(+np_1() +obl_2(for,) )
  						  imp-rule(+obl_2(for,) +np_1() )
						  imp-rule(+np_1() +obl_2(to,) )
  						  imp-rule(+obl_2(to,) +np_1() )
  						     
  family v+sent(V)            { entry: vcat(+s_3(fin,)                       , ECOMP() )        ; }

  family v+dep-clause(V)       { entry: vcat(+s_3(s-dependent MARK=that,)     , ECOMP() )        ;
                                 entry: vcat(+s_3(s-dependent,)               , ECOMP() )        ; }
                              imp-rule(+s_3(,) )
 
  family v+deictic-event(V)   { entry: vcat(+s_3(fin-deictic,)  , ECOMP() )    ; }  
 						          imp-rule(+s_3(fin-deictic,)  )

  family v+verb-ing(V)        { entry: vcat(+s_3(ing,     +subj() )      , ECOMP() )        ; } 
  						          imp-rule(+s_3(ing,     +subj() ) )
  family v+verb-inf(V)        { entry: vcat(+s_3(inf,     +subj() )      , ECOMP() )        ; } 
 						          imp-rule(+s_3(inf,     +subj() ) )

  family v+np+sent(V)         { entry: vcat(+s_3(fin,) +np_1()                         , PATIENT() ECOMP() )    ; }    
  family v+np+dep-clause(V)   { entry: vcat(+s_3(s-dependent MARK=that,) +np_1()       , PATIENT() ECOMP() )    ; 
                                entry: vcat(+s_3(s-dependent,) +np_1()       , PATIENT() ECOMP() )    ; }  
  
							  imp-rule(+s_3(,) +np_1() )
  family v+np+verb-inf(V)     { entry: vcat(+s_3(inf, +np_1-subj() ) +np_1()        , PATIENT() ECOMP() )    ; }
  
  family v+np+verb-base(V)    { entry: vcat(+s_3(vf-base, +np_1-subj() ) +np_1()    , PATIENT() ECOMP() )    ; }    
						          imp-rule(+s_3(vf-base, +np_1-subj() ) +np_1() )
  family v+np+verb-ing(V)     { entry: vcat(+s_3(ing, +np_1-subj() ) +np_1()        , PATIENT() ECOMP() )    ; }    
       					          imp-rule(+s_3(ing, +np_1-subj() ) +np_1() )
   
  
  ## More specialized verb families  ##

  # don't be silly
  family imp-do(V)               { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity addressee) ) ;}
  family imp-lets(V)             { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity speaker+addressee) ) ;}

  # I made it from plastic, it is made of plastic, etc.
  def v+np+obl-result(word){
                 family "v+np+".word."-np-result"(V)         { entry: vcat(+obl_2(word,) +np_1()  , PATIENT() R-ENTITY()   )   ; 
                                                              entry: vcat(+np_1()  +obl_2(word,) , PATIENT() R-ENTITY()   )   ; }
             	 imp-rule(+obl_2(word,) +np_1() )
                 imp-rule(+np_1() +obl_2(word,) )
  }
  v+np+obl-result(of)
  v+np+obl-result(from)
  v+np+obl-result(out_of)  
	  
  # you use this to pick up balls
  family v+instrumental-np+verb-inf(V)  { entry: vcat(+s_3(inf, +subj() ) +np_1()   , PATIENT() ECOMP( INSTRUMENT() ) )    ; }    
    					          imp-rule(+s_3(inf, +np_1-subj() ) +np_1() )
  
  # thank you for helping me  
  family v+Rec-np+for-verb-ing(V) { entry: vcat(+s_3(for-ing, +np_2-subj() ) +np_2()    , RECIPIENT() ECOMP() )    ; }    
						         # imp-rule(+s_3(for-ing, +np_2-subj() ) +np_2() )
 
  family Thanks(V)  { entry: s(s-ind) +s_3(for-ing, \ np_2(nom) )  : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ECOMP() ) ;
                      entry: s(s-ind)                              : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ) ;  
                      entry: s(s-ind) +obl_1(for,)                  : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) PATIENT() ) ;  

}

  ##################################
  ## VP & Sentential Coordination ##
  ##################################
    
  # First entry handles coordinated vps, i.e. subject controlled vp chains.
  # Every syn feature except for modifier class must be identical. If this weren't allowed to differ, 
  # couldnt handle I walked in and picked it up, cuz walk and pick have dif m-classes. 
  
  # Note: A nice consistent handling of these clausal chains seem to require the imp-rules above
  #       By converting s[base]\!np into imps, this entry allows the chaining of multiple vps
  #       to be 'converted' into an imp only once, thus having a single mood scoping over the
  #       whole chain. With base-level (lexical) s/args : E( <Mood>imp ... args), this wouldn't be possible
  
  # Question: what should the m-class of the result be?
  
  # Second entry handles general sentence coordination. The conjuncts must be mooded-clauses, 
  # the result is of general s-major mood and 'fin' verb form (if you don't give it a verb form
  # then some rules will grap a hold of it and make silly readings (e.g. see rules around imperatives)
  #   NOTE: May 15 restricted these to being ind or int, not dropped subject ind (s-ind-ell) or imp.
  #         This is because we want those to be handled using the vp-chains. This reduces number of parses
  #         and looks more sexy, like Givon's(1995)   S[subj vp vp vp vp vp ...] treatment
		    
  family Coord-s-  { entry:   (s<10>[R VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=yes] +subj() ) 
                            / (s<11>[N VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS] +subj() ) 
							\ (s<12>[F VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=no] +subj() ) : COORD(*) ; 
                     entry:    s<10>[R s-ind fin COM=yes] /^ s<11>[N  fin s-ind ] \* s<12>[F fin s-ind COM=no]  : COORD(*) ;  
		     entry:    s<10>[R s-int fin COM=yes] /^ s<11>[N  fin s-int ] \* s<12>[F fin s-int COM=no]  : COORD(*) ;  
                     entry:    s<10>[R s-mood-mixed fin COM=yes] /^ s<11>[N  fin s-ind ] \* s<12>[F fin s-int COM=no]  : COORD(*) ;    
                     entry:    s<10>[R s-mood-mixed fin COM=yes] /^ s<11>[N  fin s-int ] \* s<12>[F fin s-ind COM=no]  : COORD(*) ;  
                     entry:    s<10>[R s-mood-mixed fin COM=yes] /^ s<11>[N  fin s-int ] \* s<12>[F fin s-imp COM=no]  : COORD(*) ;  
                     entry:    s<10>[R s-mood-mixed fin COM=yes] /^ s<11>[N  fin s-ind ] \* s<12>[F fin s-imp COM=no]  : COORD(*) ;  }

   # Added sept 18 to allow incremental parsing of coordinated imperatives. 
   #    go and ...  walk over there and ...
   # Is currently 'over generating' by also applying to pre-placable adverbs to receive
   # an 'imp waiting for verb' reading

   imp-rule ( / (s<11>[N VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS] +subj() ) )

#######################
## DICTIONARY FORMS  ##
#######################


  # This handles verbs which are perfectly regular ex. jump -> jumps, jumping, jumped (past), jumped (past participle)
  #
  def verb-reg(stem, mod, class, props)       {  verb(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg(prd, stem, mod, class, props) { _verb(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }

  # This handles verbs whose 3rd person present form is regular, but whose past and past particle aren't
  #
  def verb(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }

  # This handles irregular verbs, i.e. each form must be fully specified
  #
  def verb-basic(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.-verb-.class.mod:props(class, pred=prd) {
	  stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
      3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
      stem:      mod fin-full pres s-pos do         s-pl  ;
      pasttense: mod fin-full past s-pos do               ;
	  pastpart:  mod pp                                   ;
	  ving:      mod ing                                  ;
	  stem:      mod vf-base                              ;
   	  stem:      mod vf-to-imp                            ;   # This entry gets turned into an imp via rule (see above)

    }
  }

  
 
  # This set is identical but DOES NOT have a to-imp reading
  # Use these if you don't want this verb to receive an imperative reading.
  #
  #
  def verb-reg-no-imp(stem, mod, class, props)       {  verb-no-imp(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg-no-imp(prd, stem, mod, class, props) { _verb-no-imp(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def verb-no-imp(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic-no-imp(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb-no-imp(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic-no-imp(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def verb-basic-no-imp(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic-no-imp(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic-no-imp(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.prd.-verb-.class.mod:props(class, pred=prd) {
	  stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
      3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
      stem:      mod fin-full pres s-pos do         s-pl  ;
      pasttense: mod fin-full past s-pos do               ;
	  pastpart:  mod pp                                   ;
	  ving:      mod ing                                  ;
	  stem:      mod vf-base                              ;
    }
  }


 def adjectival-verb(stem, mod, class, props) {_adjectival-verb(stem, stem, mod, class, props) }
 def _adjectival-verb(prd, stem, mod, class, props) {
     word stem.-be-adj-to: props (class, pred=prd)
     {stem: vf-be mod;}
 }


## OLD

 
  
  # The 3rd rule turns ing-form verbs into adverbials displaying 'disposition' 
  #  e.x I walked in hoping he would be there
  #      I didn't ask him assuming he didn't know
 
#  HE CAME IN LOOKING FOR A BALL
#  I WENT TO THE LIBRARY EXPCECTING TO FIND A BOOK
#						   rule { typechange: s_ma(ing) +subj() args           => s(m-class-4) +subj() args \* ( s(MCLASS:s-comment) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 
#						  rule { typechange: s_ma(ing) +subj()  { args }      => s(m-class-4) +subj() { args } \* ( s(MCLASS:s-comment) +subj() ) 
#                                                                                 : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 



#     				   rule { typechange:  s(fin MCLASS:s-comment) +subj()        => from-s() +subj() /( s_ma(ing) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-disposition blah E-ARG() ) ); } 

# Must block for some verbs by choosing to allow this, or not... prob same above I kept running should never have 'disposition' reading
#
#     				   rule { typechange:  s(fin MCLASS:s-comment) +subj()        => from-s() +subj() /( s_ma(inf) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 


 # is there ...
 # what is there 

# def pres-entry(syn, sem)      {  
#                                 entry: s(s-int) syn / subj() / np[D CASE = dummy-there]      : EVENT(* INT() ^ <Subject>(D) <Cop-Restr>(S) ^ sem)  ;
#								 entry: s(s-minor) \! np[D:dummy CASE = dummy-there] syn / subj() : EVENT(* <Cop-Restr>(S) ^ sem)  ;  }
#         					   #  entry: s(s-minor) \! np[D CASE = dummy-there] / subj() syn      : EVENT(* <Cop-Restr>(S) ^ sem)  ;  }
							
# family Presentational(V)     {  							   
#      							pres-entry( , ) 
#							pres-entry( / pp_1(CC-TYPE:post-n), <Cop-Scope>(X:m-location) ) 
#       						    # Inverted locational  'On the table is a ball'
						        #
#							    entry: s(s-ind) / subj() \ pp_1(CC-TYPE:post-n)  : EVENT(* IND() <Cop-Restr>(S:entity) ^ <Cop-Scope>(X:m-location) )  ;
#	     					 }


# def pres-entry(syn, sem)      {  
#                                 entry: s(s-int) syn / subj() / np[D dummy-there]      : EVENT(* INT() ^ <Subject>(D) <Presented>(S) ^ sem)  ;
#								 entry: s(s-minor) \! np[D dummy-there] syn / subj() : EVENT(* <Presented>(S) ^ sem)  ;  }


 #########################
 # Obliques (NP markers) #
 #########################
 
   family NP-marker (indexRel="*NoSem*")     { entry: obl<~55>[T MARK=*] /^ np<55>[T CASE=acc NUM PERS] ; 
                                               entry: obln<~55>[T MARK=*] /^ n<55>[T NUM PERS] ; }

 #####################
 # Sentence markers  #
 #####################
   
   # for that, whether, etc. May need to add semantics here (a tag on E) CURRENTLY OVER GENERATING. 
   # MUST SORT OUT

   # family Sent-marker (indexRel="*NoSem*")   { entry:  from-s(MARK= *) / s(MARK=no-mark) ; } 
   family Dep-clause-marker  { entry:  from-s(MARK= *) / s<10>[G s-dependent MARK=none]: EVENT( * <Scope>(G) ) ; }   
   family Dep-clause-marker-no-sem (indexRel="*NoSem*")   { entry:  from-s(MARK= *) / s(s-dependent MARK=none) ; }

 #########################
 # Infinitive Marking To #
 #########################
  
   # Two families: 1st takes a vf-base vp and the second doesn't, adding context pred to this event 
   #       If this turns out to be too promiscous. Add another VFORM value  inf-ctxt, i.e. this
   #       allows whatever chooses inf vps to choose whether or not its inf can be contextualized
   #
   family Infinitive-to (indexRel="*NoSem*") {  entry: ( from-s(inf) +subj() ) / ( s(vf-base) +subj() ) ; 
                                                entry: s(inf) +subj()          : EVENT(context)         ;   } 
   
   family For-verb-ing     (indexRel="*NoSem*") { entry: ( from-s(for-ing) +subj() ) / ( s(ing) +subj() ) ; } 
   # Should this just be a gerund?


  















  
 

  #####################################  
  ## The Copular & Presentational Be ##
  #####################################

  # NOTE: see modifiers.ccg for compliment and modifier definitions 
  #       due to DotCCG ORDERING ISSUES, they had to be put there
  
  def RESTR(args)          { <Cop-Restr>(S args) }
  def SCOPE(args)          { <Cop-Scope>(X args) }


  def cop-entry(arg, sem)         {  entry: s(s-minor) +subj(nf-real) arg      : EVENT(* RESTR() sem)  ; 
                                     entry: s(s-int) arg / subj(nf-real)       : EVENT(* INT() SUBJECT() RESTR() sem )  ; 
									 entry: cop<10>[E] arg / subj(nf-real)     : EVENT(* RESTR() SUBJECT() sem )  ; # USED IN OPEN-QUESTIONS
								   }

 # To avoid 'what is that' or 'what is a ball' getting 2 READINGS (in <Cop-Restr> and <Cop-Scope>), we must
 
 def cop-entry-no-ques-subj(arg, sem)         {  entry: s(s-minor) +subj(nf-real Questionable=no) arg      : EVENT(* RESTR() sem)  ; 
                                                 entry: s(s-int) arg / subj(nf-real)       : EVENT(* INT() SUBJECT() RESTR() sem )  ; 
								                 entry: cop<10>[E] arg / subj(nf-real)     : EVENT(* RESTR() SUBJECT() sem )  ;
								              }
 
 
  ## Need to sort out a way of having super semantic type 'm-mod-entity' which will then be subspecified when filled in
  
  family Copular(V)          {   
                                cop-entry( +cop-pp()  , <Cop-Scope>(X:m-benefactor) )  
								cop-entry( +cop-pp()  , <Cop-Scope>(X:m-accompaniment) )  
								cop-entry( +cop-pp()  , <Cop-Scope>(X:m-comparison) )
     							cop-entry( +cop-adj() , <Cop-Scope>(X:quality) )  
                            #    cop-entry-no-ques-subj( +cop-np()  , <Cop-Scope>(X:entity) )
							
							entry: s(s-minor) +subj(nf-real Questionable=no) +cop-np()    : EVENT(* RESTR() <Cop-Scope>(X:entity))  ; 
                            entry: s(s-int) +cop-np() / subj(nf-real)                     : EVENT(* INT() SUBJECT() RESTR() <Cop-Scope>(X:entity) )  ; 
						    entry: cop<10>[E] +cop-np(no-q) / subj(nf-real)                   : EVENT(* RESTR() SUBJECT() <Cop-Scope>(X:entity) )  ;   # USED IN OPEN-QUESTIONS

							
         					 }

 # A second family to control locational modifiers (i.e. I am hungry at work, but I am in the kitchen at work, will combine)
 #
 family Copular-location(V) { cop-entry( +cop-pp()  , <Cop-Scope>(X:m-location) ) }
 
 # NOTE: doing (cop item) and allowing the cop entry to handle its own subject allows
 #      'who is he with', 'what is he on', i.e. the subject comes after the unit is built.
 #       NOTE: this is NOT INCREMENTAL! (**sigh**)

  def wh-copular-entry(item, syn, sem)  {
#	  entry: from-s(s-int)  /^ subj() /^ ( cop<10>[E] item / subj(nf-real) ) syn
#    	   : E:ascription( INT() SUBJECT() <Wh-Restrrrrrrrrr>(sem) ); 
  	  entry: from-s(s-int)  /^ ( cop<10>[E] item  ) syn
    	   : E:state( INT() <Wh-Restr>(sem) ); 
  } 


 

 family Cop-negation (indexRel=Polarity) { entry: pre-cop-pp  (s-neg, s-prov-pos, )  ;
                                           entry: pre-cop-np  (s-neg, s-prov-pos, )  ;
                                           entry: pre-cop-adj (s-neg, s-prov-pos, ) ;
						     	         }
					   							
 family Presentational(V)           { entry: s(s-minor) \! np[D dummy-there] / subj()         : EVENT(* <Presented>(S) )  ;
                                      entry: s(s-int)/ subj() / np[D dummy-there]             : EVENT(* INT() ^ <Subject>(D) <Presented>(S)); 
									  entry: cop<10>[E] / subj() / np[D dummy-there]          : EVENT(*  <Subject>(D) <Presented>(S));  } 
									   
 family Presentational-inverted(V)  { entry: s(s-ind) / subj(nf-real) \ pp_1(CC-TYPE:post-n)  : EVENT(* IND() <Presented>(S:entity) ^ <Modifier>(X:m-location) )  ; }


 # Handling Questions like 'when were you big' and 'where was there a ball', i.e. 's-modifier questions' for copula and presentational
 # These are actually added in the appropriate wh family

 def be-wh-sent-mod-entry(item){
       entry: from-s(s-int) item  /^ subj() / vp-extr(be, item )
            : E:state( INT() SUBJECT() WH-RESTR(V * <Scope>(E:event)) ); 
 }
 
 def be-wh-sent-mod-entries(){
     be-wh-sent-mod-entry( +cop-pp() ) 
     be-wh-sent-mod-entry( / np() ) 
     be-wh-sent-mod-entry( +cop-adj() ) 
 }

 
   # Works, but would need loads separate for Presentational because it must be restricted to NP objects....Also should add
 
  # must add this entry to Cop above		entry: caux<10>[E] : EVENT(*);
    
 # def wh-copular-entry(syn, sem)  {
 #     entry: from-s(s-int)  /^ subj(nf-real) /  caux<10>[E] syn                   
#		   : EVENT( INT() SUBJECT() WH-RESTR(sem) RESTR() <Cop-Scope>(F)  ); 
#  } 

 

# This contains the stuff for 'auxe verbs', i.e.
#    auxillaries (be, have, do)
#    modals      (can, should, will, etc)

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def aux(args)           { aux<11>[E NUM:NUM PERS:PERS VFORM:VFORM FIN:FIN POL:POL args] }


##############
## FAMILIES ##
##############

  ## Family Building Macros ##

  ## Must separate Y/N indicatives from others because only finite forms of auxs receive this
  #  i.e. I have BEEN sleeping but not BEEN I sleeping
     #     NOTE: currently, the context events are restricted to m-class-3. This SHOULD be taken out
     #           but is now just to block 'I am on the table' from not getting such readings.
     #
  def fin-entry-no-int(arg){
  
	  ## Indicative Entry: with vp and context ##
	  entry: ( s(fin-full MCLASS:MCLASS POL:POL) +subj() ) 
	           /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=arg] +subj() )                  ;  
      entry:  s(fin-ctxt m-class-4 POL:POL) +subj()			   : EVENT(context) ;
    
      ## The selectable version (used by wh-words) ##
 	  entry: aux( VFORM=arg)										                    ;
		  
  }

 
  def fin-entry(arg){
  
      fin-entry-no-int(arg)
  
      ## The Y-N question versions: with vp and context ##
	  #
	  entry: from-s( s-int fin-full ) / ( s(arg) +subj() ) /^ subj()                     : EVENT(INT() SUBJECT() ) ;              
      entry: s( s-int m-class-4 fin-ctxt) /^ subj()							   : EVENT(INT() SUBJECT() context) ;              
  
  
  }

  
  # Added semantics, i.e. <Modifier> (see modal family below)
  #
  def fin-entry+sem(arg, sem){
      
      entry: ( s(fin-full MCLASS:MCLASS POL:POL) +subj() ) 
	           /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=arg] +subj() )  : EVENT(sem);  
      entry:  s(fin-ctxt m-class-4 POL:POL) +subj()			            : EVENT(context sem) ;	  
	 
	  entry: aux( VFORM=arg)										    : EVENT(sem) ;
      
	  entry: from-s( s-int fin-full) / ( s(arg) +subj() ) /^ subj()     : EVENT(INT() SUBJECT() sem) ;              
      entry: s( s-int m-class-4 fin-ctxt) /^ subj()								: EVENT(INT() SUBJECT() context sem) ;              
  }

  # For Passives
  #
  # In theory could create rule which changes passive vp's into vp / by-subj
  # this would require a syntactic voice feature 
  # This may be attractive cuz right now we're gonna need to duplicate this in Wh-forms anyway.. sigh.
  
  def pass-ind()       { ( s(fin-full MCLASS:MCLASS POL:POL) \! np[X] ) /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=pp] +subj() / np[X] )  }
  def pass-yn()        { s(fin-full s-int) / ( s<14>[E VFORM=pp] \! np[S] / np[X] ) /^ np<9>[X NUM:NUM PERS:PERS nom]  }  	   
 
  def pass-ind-by()    { ( s(fin-full MCLASS:MCLASS) \! np[X] ) /^ obl[S MARK=by] /^ ( s<14>[E MCLASS:MCLASS VFORM=pp] +subj() / np[X] )    }
  def pass-yn-by()     { s( s-int fin-full) /^ obl[S MARK=by] / ( s<14>[E VFORM=pp] \! np[S] / np[X] ) /^ np<9>[X NUM:NUM PERS:PERS nom]  }  	   
 
     
  ## The Families ##

  family Modal-vf-base                       { fin-entry+sem(vf-base, MODIFIER(*) ) }
  
  family Aux-vf-base (indexRel=Tense)        { fin-entry(vf-base ) }
  family Aux-no-int-vf-base (indexRel=Tense) { fin-entry-no-int(vf-base ) }
  
  family Aux-pp (indexRel=Aspect)            { fin-entry(pp) }
  family Aux-no-int-pp (indexRel=Aspect)     { fin-entry-no-int(pp) }
  
  family Aux-ing (indexRel=Aspect)           { fin-entry(ing) }
  family Aux-no-int-ing (indexRel=Aspect)    { fin-entry-no-int(ing) }
  
  family Aux-vf-be (indexRel=Tense)          { fin-entry(vf-be) }
  family Aux-no-int-vf-be (indexRel=Tense)   { fin-entry-no-int(vf-be) }

  # Should add 'context' readings here.
  family Aux-no-int-passive(indexRel=Voice){
           entry: pass-ind()      : S(context);        # the actor is markerked as 'unexpressed'
       	   entry: pass-ind-by()   ; 
           entry: aux( VFORM=pp)  ; 
   }

  family Aux-passive (indexRel=Voice){						  
           entry: pass-ind()      : S(context);        # the actor is markerked as 'unexpressed'
       	   entry: pass-ind-by()   ; 
           entry: aux( VFORM=pp)  ; 
           entry: pass-yn()     : EVENT( INT() <Subject>(X))  S(context) ;
           entry: pass-yn-by()  : EVENT( INT() <Subject>(X) ) ;
  }

 # Could be cleaned up by making defs for these categories (since repetition of above)
 #
 family Aux-negation (indexRel=Polarity) {
    
	   # Standard, indicative and Y-N Int
	
       entry:     ( (from-s(s-neg) +subj() ) / (s<14> +subj() ) )
	            \ ( s(s-prov-pos) +subj()    / (s<14> +subj() ) ) ;  
	   entry:     ( from-s(s-neg) / ( s<14> +subj() ) )
	            \ ( s( s-int s-prov-pos) / ( s<14> +subj() ) ) ;     
	   
	   # Passive, indicative and Y-N with and without 'by actor'
	  
	   entry:     ( (from-s(s-neg) \! np[X] ) / (s<14> +subj() / np[X] ) ) 
	            \ ( (s(s-prov-pos) \! np[X] ) / (s<14> +subj() / np[X] ) ) ;  # Pass Ind
	   entry:     ( (from-s(s-neg) \! np[X] )  /^ obl[S MARK=by] / (s<14> +subj() / np[X] ) )
	            \ ( (s(s-prov-pos) \! np[X] ) /^ obl[S MARK=by] / (s<14> +subj() / np[X] ) ) ;  # Pass Ind-by
    
	   entry:     ( from-s(s-neg) / ( s<13> \! np[S] / np[X] ) )
	            \ ( s( s-int s-prov-pos)  / ( s<13> \! np[S] / np[X] ) ) ;     
       entry:     ( from-s(s-neg)  /^ obl[S MARK=by] / ( s<13> \! np[S] / np[X] ) )
	            \ ( s( s-int s-prov-pos) /^ obl[S MARK=by] / ( s<13> \! np[S] / np[X] ) ) ;     


 }


 

#######################
## DICTIONARY FORMS  ##
#######################

  # The auxillary verbs be, have, do are done 'by-hand' in dictionary-closed.ccg

  def modal(form, class, args)  { modal-irr(form, form."n't", class, args) }

  def modal-irr(pos-form, neg-form, class, args) {
      word pos-form.-auxev : Modal-vf-base(class, pred=pos-form){
	     pos-form : pos-form s-prov-pos args; 
	     neg-form : pos-form s-neg neg args;
	  }
  }

 
 
 
# This file contains various 'discourse related' families (e.g. Discourse Markers)
# and also rules handling discourse phenomena like discourse 'fragments', 
# Pre-NPs, Refernt-Negotiations(appositions), etc.

      # NOTE: these rules can easily be shut off by commenting them out

 ######################
 # Discourse Markers  #
 ######################

def dm-entries(args, sem){
    entry: du[A COM=no] args                                     :  A(* sem) ; 
    entry: du[R COM=yes ] / du[N] args                           :  R:d-units(list <First>(F * sem) ^ <Next>(N:marker) ) ;
    entry: du[R COM=yes ] / s<10>[N MOOD:s-major] args           :  R:d-units(list <First>(F * sem) ^ <Next>(N:event) ) ;
  
 }


family DM(du)  { 
   dm-entries( , )
} 
family DM+np(du)  { 
   dm-entries( / np() , <Addressee>(T:entity) )
} 


  def _dis-marker(prd, form, class) {
      word form."xx"."-du" : DM (class, pred=prd) {form ;}
   }
  def dis-marker(form, class) { _dis-marker(form, form, class)}

 def _dis-marker+(prd, form, class, args) {
      word form."xx"."-du" : DM (class, pred=prd) {form: args ;}
   }
  def dis-marker+(form, class, args) { _dis-marker(form, form, class)}


  def dis-marker+np(form, class) {
      word form."-du+np" : DM+np (class, pred=form) {form ;}
   }



 ##################### 
 # DICTIONARY ENTRY  #
 #####################

    def discourse-marker(form, class) {
      word form."-dis-marker" : Discourse-marker(class, pred=form) {form ;}
    }




 
###################
# Discourse Rules #
###################


# Discourse units
# 
# Some, i.e. markers, begin their life as DUs... they have no scope. This could be changed.
# The rest are 'created' by converting various 'full' syntactic units (np, s, adj, etc) into du.
# There is one rule which linearly attaches all these chunks together.
# Hence, it allows.   The ball the big one um get it for me ok Robot 

def du-rule(from, to)  { rule { typechange: from $1                   =>  to $1   ; } }

#du-rule( np(full)   , du[T COM=no])
#du-rule( s(s-major) , du[E COM=no])
#du-rule( adj()      , du[M COM=no])

#rule { typechange: du[F COM=no]                 =>  du[F COM=yes] / du[N]             :       F( <Next>(N) )              ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] / du[N]              :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] / s(s-major)         :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] \* s(s-major)         :       COORD( sequence)            ; } 


 

#family DUU(du)  { entry: du<50>[A COM=no] : A(*) ; }
#family DUU+np(du)  { entry: du<50>[A COM=no]/np() : A(* <Anchor>(T) ) ; }

#family DUU(du)     { entry: s<> / s() : EVENT( MODIFIER(*) ); }
#family DUU+np(du)  { entry: du<50>[A COM=no]/np() : A(* <Anchor>(T) ) ; }


#def _disc-unit(prd, form, class) {
#      word form."-du" : DUU (class, pred=prd) {form ;}
#   }
#def disc-unit(form, class) { _disc-unit(form, form, class)}

#def disc-unit+np(form, class) {
#      word form."-du+np" : DUU+np (class, pred=form) {form ;}
#   }



# These were rules playing around with the idea of handling 'aborted' units, i.e. repair sequences.
# Problem with the general one is it allowed the 'abortion' of completed units....
# Also, it would give readings like  <I> <want the ball>
#
# Perhaps this should be a parser meta-rule. If you get something you don't expect, hack off
# the args of previous. i.e. it should be backward looking!


#du-rule( np()/n()   , du[T COM=no] : T(abort) )
#rule { typechange: np() / n()                      =>   du[T COM=no] : T(abort)    ; } 
#rule { typechange: du[F COM=no] $1                     =>  du[F COM=no]             :       F(abort <ABORTED>yes )    ; } 

#rule { typechange: du[F COM=no] $1                 =>  du[R COM=yes] $1 / du[N COM=rep]            :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no REP=no] $1            =>  du[R COM=no] / du[N COM=no REP=yes]      :   R(abort <ABORTED>(F) <Next>(N) )   ; } 


# MAY 8: A lot of this should be done at the DISCOURSE LEVEL. I need to implement utt units which get sequentially concatinated.


  # These handle extra-syntactic phenomena 'floating' phrases, pre and post nps.

  # REFERENT-NEGOTIATION/APPOSTIONS
  
  # This handles '2nd tries' at describing referents
  
  #  rule { typechange: np(full)                   =>  from-np() /* np[A]                      : ENTITY( <Apposition>(A) )                   ; } 
  
  # These two rules handle post and pre nps. There is no 'grammar internal' processing of these
  # They would require heurstics based on 1) mood 2) ontological sort compatibility 3) Discourse model expectations etc. 

  # PRE-NPS
  #       Vocative:   GJ go get the ball  GJ where did you put it    
  #       Ref-Negotiation: The big one on the table the one that is close to you I want you to pick it up. 
  #       Reference-Point.  GJ his ball is on the table.
  #
#  rule { typechange: np(full) $1                   =>  s() /^ s(MOOD:s-major) $1                      : EVENT( <Pre>(T) )                   ; } 
 	
	    
  # POST-NPS
  #		  Vocative: go get the ball GJ   where is it Robot
  #       Referent-Clarifications: go get it for me the ball over there on the table
  #       Interpersonal Uses: He's a nice guy your brother
  #  
  #
 # rule { typechange: np(full) $1                   =>  s() \* s(MOOD:s-major) $1                      : EVENT( <Post>(T) )                  ; } 

 
  # MINOR CLAUSES
  # Creates minor clauses out of 'floating' nps, pps, adjs. Could add for other types
  #
  def floating-rule(arg) { rule { typechange: arg $1                   =>  s(s-minor) $1                      : EVENT( <Mood>(minor) <Floating>(F) )   ; } }
#  floating-rule(np[F acc] )
#  floating-rule(adj[F]    )
#  floating-rule(pp[F]     )  # Currently gives some weird reading


# This file contains the following long-distance-dependency/extraction constructions
#   Wh-Words for questions ( WHO is he,  WHERE did you go, etc)
#   Role-Defined Constituents  ( I picked up 'WHAT you wanted', I don't know 'WHO he is', etc)
#   Relative Clauses (the ball THAT you picked up)   

# For the sake of incremental parsing and early projection, all of these are treated 
# as the semantic and syntactic head of their respective constituents. 

######## WH-WORDS ############

# There are two entries for most of the question words, one for copulars, 'Who am I' 
# and one for other verbs which must use an auxillary, 'What did you see'

# They assign mood (both syntactic and semantic), select for the clauses Subject, 
# and properly distribute the features dictated by the specifics of the question word


###########################
## SYNTACTIC DEFINITIONS ##
###########################

def vp-extr(arg, item)  { ( s(VFORM:VFORM FIN:FIN POL:POL arg) +subj() item ) }


##########################
## SEMANTIC DEFINITIONS ##
##########################

   def WH-RESTR(arg)    {<Wh-Restr>(arg)}
   
##############
## FAMILIES ##
##############

 ## Family Building Macros ##

 # The first one is for cases where the 'extracted' element is in the main clause (what did you want), 
 # The second is for when it is embedded (e.g. who did he want me to see X)
 
  def wh-auxe-entry(item, syn, sem)  {
      entry: from-s(s-int fin-full)  / vp-extr(,item) /^ subj(nf-real) /  aux() syn                   
		   : EVENT( INT() SUBJECT() WH-RESTR(sem) ); 
      entry: from-s(s-int fin-full) / (s<13>[G] $1 item) / vp-extr(, / (s<13>[G] $1) ) /^ subj(nf-real) /  aux() syn                   
		   : EVENT( INT() SUBJECT() WH-RESTR(sem) ); 
  } 

#  def wh-copular-entry(item, syn, sem)  {
#	  entry: from-s(s-int)  /^ subj() /^ vp-extr(be, item)  syn
#    	   : E:state( INT() <Subjecttttttt>(S) WH-RESTR(sem) ); 
#  } 
 

   
	 
# silly hack, copular entry with /np is blocked so as to not allow subject questioning, this means what is it only gets 1 instead of '2' question forms
#

   def wh-subj-entry(syn, sem) { entry: from-s(s-int)     / ( s(fin) \ np[F nom 3rd s-sg nf-real Questionable=yes] ) syn    :    EVENT( INT() <Subject>(F) WH-RESTR(sem) );  }
 

  def wh-comp-entries(item, syn, sem){ wh-auxe-entry ( item, syn, sem )
                                    wh-copular-entry( item, syn, sem ) } 
                                #     wh-copular-entry( syn, sem )  }

  def wh-no-copular-entries(item, syn, sem) { wh-auxe-entry ( item, syn, sem )
                                              wh-subj-entry(  syn, sem )          }
							
  def wh-all-entries(item, syn, sem) { wh-auxe-entry ( item, syn, sem )
                                       wh-copular-entry( item, syn, sem )
                                #      wh-copular-entry( syn, sem )
				       wh-subj-entry(  syn, sem )          }

    
   ## The Families ##
   
   
   #### MUST CHECK SPEC & QUANT ###### THEN CHANGE BELOW IN ROLE-DEFINED
   
   #### Aug 20, changed 'extracted' entity to ^ slash mode, now parses 'what object did I put on the table' incrementally, didn't before

   family Quality-class            { entry: qclass<10>[C] : C(*) ; } 
   
   family Wh-np- (Wh)              { wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , F:entity * ) }
    
   # These two must be separated because we want 'what ball' = 'which ball', but 'which' != 'what'
#   family Wh-np-spec- (Wh)         { wh-all-entries ( / np<12>[F Questionable=yes]   , / n<12>[F s-sg which-n]             , V * <Scope>(F:entity SG() SPECIFIC() UNIQUE() ) ) 
#									 wh-all-entries ( / np<12>[F Questionable=yes]   , / n<12>[F s-pl-unsp which-n]        , V * <Scope>(F:entity PL() UNSPECIFIC() UNIQUE() ) )  }
   family Wh-np-spec- (Wh)         { wh-all-entries ( /^ np<~12>[F Questionable=yes]   , / n<12>[F s-sg]             , V * <Scope>(F:entity SG() SPECIFIC() UNIQUE() ) ) 
				     wh-all-entries ( /^ np<~12>[F Questionable=yes]   , / n<12>[F s-pl-unsp]        , V * <Scope>(F:entity PL() UNSPECIFIC() UNIQUE() ) )  }
	
   family Wh-np-spec-ctxt- (Wh)     { wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V * <Scope>(F:entity context UNIQUE() ) )  }   
								   								   
   family Wh-np-quant-count- (Wh)  { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-pl]             , V *  <Scope>(F:entity PL() UNSPECIFIC() VARIABLE() )          )
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V *  <Scope>(F:entity context PL() UNSPECIFIC() VARIABLE() ) ) }
   
   family Wh-np-quant-mass- (Wh)   { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-mass]           , V *  <Scope>(F:entity VARIABLE() UNCOUNTABLE()) ) 
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V *  <Scope>(F:entity context  VARIABLE() UNCOUNTABLE() ) ) }
    
   family Wh-np-qclass- (Wh)       { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-sg no-q]  /qclass<13>[Q]        , V *  <Scope>(Q <Scope>(F:entity SG() SPECIFIC() UNIQUE()) )  )
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-pl-unsp no-q]  /qclass<13>[Q]   , V * <Scope>(Q <Scope>(F:entity PL() UNSPECIFIC() UNIQUE()) )  ) }
	#					   	wh-no-copular-entries   ( /^ np<12>[F Questionable=yes]   , / qclass<13>[Q]                        , V * <Scope>(Q <Scope>(F:entity context) ) ) }

   family Wh-pp- (Wh)              { wh-comp-entries ( /^ pp<12>[F]  ,                             , F:modifier * )  }
   
   family Wh-sent- (Wh)            { wh-auxe-entry ( /^ s<12>[F]      ,                               , F:event *)            # for sentences (what did I say)
                                     wh-auxe-entry ( /^ (s<12>[F inf] +subj())      ,                 , F:event *)    }       # for inf-vp (what did I want)

   
   family Wh-adj- (Wh)             { wh-comp-entries ( /^ adj<12>[F] ,                             , F:quality * ) }
   family Wh-adj-qclass- (Wh)      { wh-comp-entries ( /^ adj<12>[F] , / qclass<12>[F]             , V * <Scope>(F:quality)  ) }
   family Wh-adj-degree- (Wh)      { wh-comp-entries ( /^ adj<12>[F] , / adj<12>[F]                , V * <Scope>(F:quality)  ) }
  
   
   # This is for handling the questioning of modifiers (i.e. optional adjuncts, like location, manner, etc)
   # There are two entries, the first is for scoping on the main (top level) event (where am is sitting), 
   # and the second is for embedded events (where did I want to sit)
   # Attachment of these modifiers is controlled by restricting the mclass of the scoped over (i.e. the 'questioned' event)
   # This is handled lexically, i.e. 'where' specifies that the sentence must unify with s-location
   # (note this fact explains the messiness of the 2nd entry, id 10, the typical sentence id must be associated
   #  with the embedded, scoped over, sentence)
   	   

   # June 17: Since we added s-no-mood, had to change top s to <~13> instead of <13> b/c the mood gets changed from s-no-mood to s-int
   family Wh-sent-modifier- (Wh) {
   
          wh-auxe-entry( , , V *  <Scope>(E:event) ) 
          entry: s<~13>[E s-int]   / (s<~10>[F] $1 )                                                     # the 'internal' s arg#
		                          / ( s<13>[E VFORM:VFORM FIN:FIN POL:POL] +subj() / (s<10>[F] $1 )  ) 
	                              /^ subj(NUM:NUM PERS:PERS nf-real)
			                      /  aux()
              : EVENT( INT() SUBJECT() WH-RESTR(V *  <Scope>(F:event)) ); 
           
		   # This is explicitly designed for handling the presentational question. Where was there a ball? also when was I a jerk, should be extended to handle when was I big, when was I in the room, i.e......
		 
		   
		 #  entry: from-s(s-int) / np()  /^ subj() / vp-extr(be, / np() )
    	 #           : E:state( INT() SUBJECT() WH-RESTR(V * <Scope>(E:event)) ); 

         be-wh-sent-mod-entries()

	}





####################### 'Role-Defined' Constituents #######################
#
#             put it 'WHERE I told you to put it __' 
#             I picked up 'WHAT you wanted __'
#             I don't know 'WHO he is'
#             I am going 'WHERE GJ is sleeping'
#             'WHAT I got __' you got to give it to your mama  
#                    (this is assuming Left-dislocation is handled )
#
# Each of these is semantically and syntactically the entity which would be placed in the __
# So, in the first case, this is a pp [M:m-location], the second  np[T:entity]   

   
  def extr-subj(rslt, syn, sem) { 
  
     entry: rslt    / ( s(fin s-minor) \ np[F 3rd s-sg nf-real] ) syn   
		  : F( sem ^ <Scope-in>(E:event <Subject>(F) ) ) ; 
  }

  # The first one is for cases where the fronted element is in the main clause, 
  # The second is for when it is embedded (e.g. who he wanted me to see X)

  def extr-comp(rslt, item, syn, sem) { 
  
     entry: rslt  / (s<13>[G] $1 item) / vp-extr(fin-full s-minor, / (s<13>[G] $1)) /^ subj(nf-real)  syn                   
	      :  F( sem ^ <Scope-in>(E:event SUBJECT() ) ) ; 
     entry: rslt  / vp-extr(fin-full s-minor, item) /^ subj(nf-real)  syn                   
	      :  F( sem ^ <Scope-in>(E:event SUBJECT() ) ) ; 
   }

  def extr-both (rslt, item, syn, sem)  {

	  extr-subj(rslt, syn, sem) 
	  extr-comp(rslt, item, syn, sem)
 } 


   # The indices are chosen based on underlying POS (e.g. 15 for n/np, 25 for pp)
   # This is because we need to lexically select features (i.e. via macros)
   # Also, the Semantic Index is always F to allow a systematic def (see above) and 
   # also to handle subject 'extraction' properly (all set to F)   

   # QUESTION: FOR EACH FAMILY, how much do we want the 'extracted' item to inherit.
   #   e.g. should an extracted direct object be accusitive...no.
   

   # What you picked up
   family Extr-np- (Wh)              { extr-both (np<15>[F],  /^ np<16>[F Questionable=yes] ,                      , F:entity *                      ) }
   
 	       
   # which (ball) you picked up
   family Extr-np-spec- (Wh)         { extr-both (np<15>[F ], /^ np<~16>[F Questionable=yes] , / n<16>[F s-sg]           ,  F:entity <Restr>(V * ) SG() SPECIFIC() UNIQUE()   ) 
                                       extr-both (np<15>[F ], /^ np<~16>[F Questionable=yes] , / n<16>[F s-pl-unsp]      ,  F:entity <Restr>(V * ) PL() UNSPECIFIC() UNIQUE() ) }

   family Extr-np-spec-ctxt- (Wh)    { extr-both ( np<15>[F ]  ,  /^ np<16>[F Questionable=yes]   ,    ,  F:entity  context ^ <Restr>(V * ) UNIQUE()  )  }   
 
									   
#   how many (balls) you picked up								   								   
   family Extr-np-quant-count- (Wh)  { extr-both (np<15>[F ], /^ np<16>[F Questionable=yes] , / n<16>[F s-pl]      ,  F:entity <Restr>(V * ) UNSPECIFIC() VARIABLE()            )
                                       extr-both (np<15>[F ], /^ np<16>[F Questionable=yes] ,                      ,  F:entity context ^ <Restr>(V * ) UNSPECIFIC() VARIABLE()  ) } 

	   
   # how much (coffee) ...
   family Extr-np-quant-mass- (Wh)  { extr-both  (np<15>[F ], /^ np<16>[F] , / n<16>[F s-mass Questionable=yes]    ,  F:entity ^ <Restr>(V * ) VARIABLE() UNCOUNTABLE()          )
                                      extr-both (np<15>[F ], /^ np<16>[F] ,                                        ,  F:entity context ^ <Restr>(V * ) VARIABLE() UNCOUNTABLE()  ) } 


   # what color/shape/size (ball) you picked up
   family Extr-np-qclass- (Wh)       { extr-both (np<15>[F ], / np<16>[F] , / n<16>[F]/ qclass<13>[Q]  , F:entity ^ <Restr>(V * <Scope>(Q) )               ) 
                                       extr-both (np<15>[F ], / np<16>[F] , / qclass<13>[Q]            , F:entity context ^ <Restr>(V * <Scope>(Q) )     ) }

   # where you put it
   family Extr-pp- (Wh)              { extr-comp (pp<25>[F] ,  /^ pp<26>[F] ,                    , F:modifier *              )}

  
   # what he says,  what you are doing
   # NOTE: B/C we are using <10>, i.e. 'main s' for the vp-extr, using lexical macros to set vf-deictic would also change that.
   #       so instead, we do it here.
    family Extr-sent- (Wh)            { extr-comp (s<20>[F VFORM=fin-deictic], /^ s<21>[F] ,                          , F:event *      )}  # MARK ME!!!
  
   # how did you make it (big, small, etc) 
   family Extr-adj- (Wh)             { extr-comp (adj<25>[F],  / adj<16>[F] ,                   , F:quality *    )}
   
   # what size did you make it
   family Extr-adj-qclass- (Wh)      { extr-comp (adj<25>[F],  / adj<16>[F] , / qclass<13>[Q]   , F:modifer <Restr>(V * <Scope>(Q) )    )}
   
   # how big did you make it
   family Extr-adj-degree- (Wh)      { extr-comp (adj<25>[F],  / adj<16>[F] , / adj<16>[F]      , F:modifer <Restr>(V *)        )}
  
  
  #### When there is no missing arg. ####
  
  # 1st subj then M-Class appropriate main s (this set lexically). Results in M-TYPE appropriate pp.
  # 2nd  subj, then s missing wanting an M-CLASS appropriate s arg, then the s arg
  
  # !!! May 6: Must sort out proper arrangement of the immediate scope and the 'context' scope.
  #  Also unify this with above. <Restr> etc. 
  # !!!
   
   
  family Extr-pp-sent-modifier- (Wh)    { 
  
      entry: pp<25>[F] /^ ( s(fin s-minor) +subj() ) /^ subj()                            
           :  F( * ^ <Scope>(E) <Scope-in>(E:event SUBJECT() ) )  ;
#          :  F( * ^ <Scope>(E SUBJECT() ) )  ;
      entry: pp<25>[F]  /^ (s<~10>[E] $1 )                                                            # the 'internal' s arg
 				        /^ ( s<13>[G fin NUM:NUM PERS:PERS s-minor] +subj() /^ (s<10>[E]$1 )  )        # the external 'main sentence' wanting an s arg
	                    /^ subj()
           :  F( * <Scope>(E:event) <Scope-in>(G:event SUBJECT() ) ) ;  
#           :  F( * <Scope>(E:event <Scope-in>(G:event SUBJECT() ) ) );  

#          :  F( * <Scope>(E:event <Modifier>(M:m-role ^ blah <Scope>(G SUBJECT())  ) ) ); 
 }

  family Extr-adv-sent-modifier- (Wh)  { 
     
	     entry: adv<25>[F] /^  ( s(fin s-minor) +subj() ) /^ subj()                             
              :  F( * ^ <Scope>(E SUBJECT() ) )  ;
         entry: adv<25>[F]  / (s<~10>[E] $1 )
 		                    / ( s<13>[G fin NUM:NUM PERS:PERS s-minor] +subj() / (s<10>[E]$1 )  ) 
	                        /^ subj()
#              :  F( * <Scope>(E <Modifier>(M:m-role ^ blah <Scope>(G SUBJECT())  ) ) );  

	           :  F( * <Scope>(E:event <Scope-in>(G:event SUBJECT() ) ) );  
}


####################### Relative Clauses ######################
#
#        the ball 'THAT I put on the table'   
#
#  basically uses the extracted-NP from above (c.f. what I put on the table) and 'sticks' it in 
#  a post-noun modifier  n / ABOVE SYNTAX \ n : T( <Modifier>(m-role ^ blah  <Scope>(ABOVE SEMANTICS)
#
#        the room 'WHERE books can be found'  ,   the place 'WHERE I put it earlier'
# 
#  this is actually handled 'automatically' from the role-defined stuff above.
#  these are turned into pps, which then get run through the pp -> post-n modifer rule (see prep.ccg)
#  If we decide this isn't the right kind of semantics, we will have to put a syntactic feature
#  on the rules above 'shutting off' this rule (basically extend CC-TYPE feature) and then
#  add a comparible rule here.

 family Rel-Clause-np- (indexRel=Modifier)  { 
	# blocked form being 1st part of compound
	entry: post-n(n-2 , /^ vp-extr(fin-full s-minor, / np<16>[T 3rd] ) /^ subj() )#
#	     : T( <Modifier>(M:m-role  blah ^ <Scope>(E  SUBJECT() ) ) ) ; 
	     : T( <Scope-in>(E  SUBJECT() ) ) ; 
    entry: post-n( , /^ ( s(fin-full s-minor) \ np[T 3rd s-sg] ) ) 																 
#     	 : T( <Modifier>(M:m-role  blah ^ <Scope>(E  <Subject>(T) ) ) ) ; 
      	 : T( <Scope-in>(E <Subject>(T) ) ) ;
 }


  word that-RCn : Rel-Clause-np- {that ;}

	   
#######################
## DICTIONARY FORMS  ##
#######################

  # Basic nouns, regular and irr

  def  wh-word (form, class, props) { _wh-word(form, form, class, props) } 
  def _wh-word (prd, form, class, props) {
    word form.-wh-word.class: props(class, pred=prd) { form ; }
  }

  def  wh-word+feat (form, class, props, args )  { _wh-word+feat(form, form, class, props, args )  } 
  def _wh-word+feat (prd, form, class, props, args )  {
    word form.-wh-word.class.props: props(class, pred=prd)  { form: args ; }
  }

  def  extr (form, class, props, args )  { _extr(form, form, class, props, args )  } 
  def _extr (prd, form, class, props, args )  {
    word form.-wh-comp.class.props: props(class, pred=prd)  { form: args ; }
  }

  def  quality-class (form) { _quality-class(form, form) } 
  def _quality-class (prd, form) {
    word form.prd.-quality-class: Quality-class(quality, pred=prd) { form; }
  }



#### OLD STUFF

# This was before I realized that in order to get a single graph, must have proper
# semantic type at top
#
   # This is the Event which the SWh word is 'based on', i.e. either 'extracts' from or scopes over (or provides context for scoping over)
   #
#   def ES() { <Event>(E SUBJECT() ) }


   # What you picked up
#   family SWh-np(Wh)              { swh-entry (np(sg),  / np() ,                      , T:entity( * ES() )                      ) }
   
   # which (ball) you picked up
#   family SWh-np-spec(Wh)         { swh-entry (np(sg), / np() , / n(s-sg)            , V( * <Scope>(T:entity) ES() )            ) 
#                                    swh-entry (np(sg), / np() ,                      , V( * <Scope>(T:entity context) ES() )    ) }   

   # how many (balls) you picked up								   								   
#   family SWh-np-quant-count(Wh)  { swh-entry (np(sg), / np() , / n(s-pl)            , T:entity( <Restr>(V *) ES() )            )
#                                    swh-entry (np(sg), / np() ,                      , T:entity(context <Restr>(V *) ES() )     ) }
 
#     family SWh-np-quant-count(Wh)  { swh-entry (np(sg), / np() , / n(s-pl)            , V( * <Scope>(T:entity) ES() )            )
#                                    swh-entry (np(sg), / np() ,                      , V( * <Scope>(T:entity context) ES())     ) }

	   
   # how much (coffee) ...
#   family SWh-np-quant-mass(Wh)   { swh-entry (np(sg), / np() , / n(s-mass)          ,  V( * <Scope>(T:entity) ES() )           ) 
#                                   swh-entry  (np(sg) , / np() ,                      , V( * <Scope>(T:entity context) ES() )   ) }
   
   # what color/shape/size (ball) you picked up
#   family SWh-np-qclass(Wh)       { swh-entry (np(sg), / np() , / n() / qclass<13>[Q]  , V( * <Scope>(Q <Scope>(T:entity) )        ES() )   ) 
#                                    swh-entry (np(sg), / np() , / qclass<13>[Q]        , V( * <Scope>(Q <Scope>(T:entity context)) ES() )   ) }

   # where you put it
#   family SWh-pp(Wh)              { swh-entry (pp() ,  / pp() ,                        , M( * ES() )         )}

  
   # what he says,  what you are doing
#   family SWh-sent(Wh)            { swh-entry (s_ma(), / s_ma() ,                      , G:event( * ES() )    )}  # MARK ME!!!
  
   # how did you make it (big, small, etc) 
#   family SWh-adj(Wh)             { swh-entry (adj(),  / adj() ,                      , M:quality( * ES() )   )}
   
   # what size did you make it
#   family SWh-adj-qclass(Wh)      { swh-entry (adj(),  / adj() , / qclass<13>[Q]      , V( * <Scope>(Q) ES() )  )}
   
   # how big did you make it
#   family SWh-adj-degree(Wh)      { swh-entry (adj(),  / adj() , / adj()              , V( * <Scope>(M:quality) ES() )   )}
  
  
	     	   
   #family SWh-sent-modifier(Wh) {auxe-entry( , , V *  <Scope>(E:event) ) 
   #                             entry: s<13>[E s-int]   / (s<~10>[F] $1 )
#								                        / ( s<13>[E VFORM:VFORM FIN:FIN POL:POL] +subj() / (s<10>[F]$1 )  ) 
#	                                                    /^ subj(NUM:NUM PERS:PERS)
#						                                /  aux()
 #                   		 : EVENT( INT() SUBJECT() WH-RESTR(V *  <Scope>(F:event)) );  }



# This was before I tried to unify relative-clauses and 'subords', i.e. I know where you went #

#  def inverted-entry(item, syn, sem)  {
#
#      entry: from-s(s-subord)  / ( s(VFORM:VFORM FIN:FIN POL:POL) +subj()  item ) 
#	                                 /^ subj(NUM:NUM PERS:PERS)
#		   					         syn                   
#			 : EVENT( SUBJECT() WH-RESTR(sem) ); 
#  } 

  
# This contains the dictionary items and testbed for 
# the COMSYS-DEVIL release

# to run the testbed use the command ccg-test

# NOTE:  the " " around single quotes are NOT IN THE GRAMMAR
#        but simply required by DotCCG

#############
## Testbed ##
#############

# You will get 3 readings for the bulk of these:
#         the np reading
#         the type-raised np as subject reading
#         the np as fronted object reading
# For 'the square' and 'the green square' you will get 9
# because square has an adjectival entry ( see X dictionary-open.ccg )


testbed {

  ########## 
  ## Demo ##
  ##########

  the triangle: 3 ;
  the circle: 3 ;
  the square: 9 ;        
  the star: 3 ;
  the red triangle: 3 ;
  the blue circle: 3 ;
  the green square: 9 ;
  the yellow star: 3 ;
  the red thing: 3 ;
  the blue thing: 3 ;
  the green thing: 3 ;
  the yellow thing: 3 ;
  
  a yellow flag: 3 ;
  a car: 3;
  
  ############
  ## Part 1 ##
  ############
   
	### Recognition of complex action sequences ##
	
	I am playing a game: 1 ;
    which game am I playing : 1 ;
	I do not know : 1 ;
	the shape game or the colour game: 1 ;
	which game am I playing : 1 ;
	you are playing the shape game : 1 ;
	
	### Ability to verbalise rules ##
	
	# to distinguish 'he goes to the table' from 'it goes on the table'
	# I gave the latter the pred go-loc
	
	where should the blue triangle go: 1;
	it should go next to the left flag: 1 ; # next to is treated as a mwe, hence underscore
	now I am playing the colour game : 1 ;
	where does the blue square go: 1 ;
	it should go next to the blue flag: 1;
	where is the blue flag: 1;
	it is on the right: 1;
	it is on the right of the red flag: 1;
	
	### Ability to apply context specific game rules
	
	### Ability to play the game
	
	play the colour game: 1;
	play the shape game: 1;
	
  ############
  ## Part 2 ##
  ############

	this is a car: 1;
	where is the car: 1;
	behind the wall: 1;
	what is behind the wall: 1;
	I see a car and a blue thing: 1;
	what is the blue thing: 1;
	it is a ball: 1;

  ######################
  ## Part 3: Explorer ##
  ######################

	could you go and find the Borland book please: 1;
	#I will go and look for it in a library where books are normally found: 1;
	do you know where the Borland book is: 1;
	I believe it is in GJ "'s" office: 1;
	the book is in GJ  "'s" office near the Starbucks mug: 1;
	
        I am sorry but could you help me: 1;
        could I ask you a question: 1;
        would you know where the Borland book is: 1;
        could you tell me where the Borland book is: 2;
        I would like to know something: 1;
        I would like to ask you something: 1;
        would you happen to know where the Borland book is: 1;
        I would need to kill you now: 1;
        I would need your help: 1;
        so_long and thanks for all the fish: 1;
	
}  


# The vast majory of dictionary entries are in dictionary-open.ccg. 
# Also, see this file for general info on adding dictionary items.

# This file contains the 'core vocabulary' or 'closed class' words:
#    Pro-forms  (pronouns, pro-verb 'do', pro-sentences (I said it), pro-locations (here, there) )
#    Adjective related function words (more, most, bigger THAN) 
#    Markers (obliques, infinitival to, subordinate-sentential clause markers, etc)
#    Determiners, Possessive 's, Deictics, 'Group'-words, Numbers (ordinal & cardinal)
#    Auxillary & Modal Verbs

##############
## PRONOUNS ##
##############

  # pronoun(pers, sg-nom, sg-acc, pl-nom, pl-acc, posessed, class,)
  # deictic(sing, plur, range, args)

  pronoun(I,    1st, sg, I    , me   , my   , mine   , person,)
  pronoun(I,    1st, pl, we   , us   , our  , ours   , person,)
  pronoun(you,  2nd, sg, you  , you  , your , yours  , person,)
#  pronoun(you,  2nd, pl, you  , you  , your , yours  , person,) 
  pronoun(he,   3rd, sg, he   , him  , his  , his    , person,)
  pronoun(she,  3rd, sg, she  , her  , her  , hers   , person,)
  pronoun(it,   3rd, sg, it   , it   , its  , its    , thing,)
  pronoun(they, 3rd, pl, they , them , their, theirs , entity,)

  context-np(someone,  person, s-sg sg existential specific full)   _context-np(someone, somebody, person, s-sg sg existential specific full)
  context-np(anyone,   person, s-sg sg variable    specific  full)   _context-np(anyone, anybody, person, s-sg sg  variable    specific full) 

  context-np(something,  thing, s-sg sg existential  specific  full)   
  context-np(anything,   thing, s-sg sg variable     specific  full)  



#########################
# Pro-Verbs & Sentences #
#########################

  verb(do, doing, did, done, m-class-all, event,                v+deictic-event )
 
  context-s(this, e-proximal)
  context-s(that, e-distal)
  context-s(it, )

 # These two don't work until we get a way to handle delim in events.. same problem as proximal/distal
 # Alternatively, could convert certain nouns to s's
 
 # context-s(something, existential  specific )   
 # context-s(anything,  variable     specific )  

#############################
## Pro-Locations and Times   ##
#############################

  # here & there #
  
  _prp+(no-arg, context, there, location, prep-1 m-distal)
  _prp+(no-arg, context, there, whereto, prep-2 m-distal)
  _prp+(no-arg, context, here, location, prep-1 m-proximal)
  _prp+(no-arg, context, here, whereto, prep-2 m-proximal)

  # these are used as contexualized anchors for prepositions: 'I went in there', 'walk over to here'
  # these use case loc-acc that only prepositions can accept

  context-np(here, e-location, sg s-sg acc-loc proximal specific unique full) 
  context-np(there, e-location, sg s-sg acc-loc distal specific  unique full)  
    
  # somewhere/anywhere
   
  prp+(no-arg, somewhere, location, prep-1 )  _prp+(no-arg, somewhere, anywhere, location, prep-1 )
  prp+(no-arg, somewhere, whereto, prep-2 )  _prp+(no-arg, somewhere, anywhere, whereto, prep-2 )

  # Temporal
  
  context-np(then, e-time, sg s-sg acc-loc specific unique full)  
   
  

#######################
## ADJECTIVE RELATED ##
#######################

  word more : More-adj: comparative;
  word most : Most-adj: superlative;
  word than : Adj-er-than(m-comparison);

############
## MARKER ##
############

  word of  : NP-marker;
  word by  : NP-marker;
  word at  : NP-marker;
  word to  : NP-marker;
  word for : NP-marker;
  word from : NP-marker;
  word out_of : NP-marker;


# These are big time overgenerating. must restrict some how...or add sem label
#  word that: Sent-marker;
#  word whether: Sent-marker;
  word infinitive-to: Infinitive-to {to;}
  word for-verb-ing: For-verb-ing {for;}
  word that: Dep-clause-marker-no-sem;
  word if: Dep-clause-marker;
  word whether: Dep-clause-marker;

#  relative-clause-marker(that, entity, )
#  relative-clause-marker(who, animate, )
#  word where-RC : RC-marker-s-mod (m-location, pred=where) {where: s-location;}

####################
## DET and GROUPS ##
####################
  
  word possessive-s: Det-poss-s { 
		"'s": unique specific sg s-sg; 
		"'s": unique specific pl s-pl; 
  }	
  
  # These are higher order dictionary-entry macros
  # which collect other dict-macros together to reduce redundancy in the grammar
    
  def det+context-np (form, args)  {
      det(form, args) 
	  context-np(form,"entity",  args) 
  }

  def det+context-np+group-np  (form, args) {
      det+context-np(form, args) 
	  group-np(form, args)
  }

  def sdet+context-np  (form, class, args) {
      sdet(form, class, args)
	  context-np+modifier(form, class, args) 
  }

  def sdet+context-np+group-np (form, class, args) {
        sdet+context-np(form, class,args) 
		sgroup-np(form, class,args)
  }

  det                      (the,   s-sg  sg unique      specific)
  det                      (the,   s-pl-sp pl unique      specific) 
  det                      (the,   s-pl-unsp pl unique    unspecific) 
  
  det                      (a,     s-sg sg  existential specific)   
  det                      (some,  s-sg sg  existential specific) 
  det+context-np+group-np  (some,  s-pl-unsp pl existential unspecific )
  det+context-np           (any,   s-sg sg      variable    specific   )
  det+context-np+group-np  (any,   s-pl-unsp pl variable    unspecific )
    
  det+context-np       (this,  s-sg sg  unique       specific  proximal)
  det+context-np       (these, s-pl-unsp pl unique  unspecific  proximal)
  det                  (these, s-pl-sp pl unique    specific  proximal)
  det+context-np       (that,  s-sg sg unique       specific  distal  )
  det+context-np       (those, s-pl-unsp pl unique  unspecific  distal  )
  det                  (those, s-pl-sp pl unique    specific  distal  )

  sdet+context-np+group-np (more, comparative, s-pl-unsp pl variable unspecific)
  sdet+context-np+group-np (less, comparative, s-pl-unsp pl variable unspecific)
  sdet+context-np+group-np (all,  quantity, s-pl-sp  unique unspecific)
      sgroup-np-no-of(all,  quantity, s-pl-sp  unique unspecific)
   
  sdet+context-np+group-np (both, quantity, s-pl-sp  pl unique specific)
  sdet+context-np+group-np (another, quantity, s-sg  sg existential specific)
  sdet+context-np+group-np (the_rest, quantity, s-pl-unsp  pl unique unspecific)
  sdet+context-np+group-np (enough, quantity, s-pl-unsp  pl variable unspecific)
  sdet+context-np+group-np (none, quantity, s-pl-sp  variable unspecific)
  sdet+context-np+group-np (a_few, quantity, s-pl-unsp pl existential unspecific)  # FIX
  sdet+context-np+group-np (several, quantity, s-pl-unsp pl existential unspecific)
 
  sdet(No, quantity, s-sg variable specific sg)
  sdet(No, quantity, s-pl-sp variable unspecific pl)
  
  sdet(every, quantity, s-sg variable specific)

#############
## NUMBERS ##
#############


  # These dictionary entry macros handle the various uses of numbers
  # Note that both numeric and "written out" versions are created 
  # for both cardinal (1, 2, 3 ...) and ordinal numbers (1st, 2nd, 3rd ...)
  #
  def number(card, r-card) {number-irr (card, card."th", r-card, r-card."th") }
  def number-irr(card, ord, r-card, r-ord) { number-basic (card, ord, r-card, r-ord, pl, s-pl-sp) }  
  def number-basic (card, ord, r-card, r-ord, num, s-num) {
		
		# CARDINAL		
		un-to-spec-det      (card,         "number-cardinal" ) # num s-num feat just repeated to fill slot
		un-to-spec-det      (r-card,       "number-cardinal" )
		_un-to-spec-det     (card, r-card, "number-cardinal" )
    	        _un-to-spec-det     (r-card, card, "number-cardinal" )
		
		sdet                (card,         "number-cardinal"  , num s-num existential specific)
		sdet                (r-card,       "number-cardinal"  , num s-num existential specific)
		_sdet               (card, r-card, "number-cardinal"  , num s-num existential specific)
		_sdet               (r-card, card, "number-cardinal"  , num s-num existential specific) 
		
		sgroup-np           (card,         "number-cardinal"  , num s-num existential specific)
                sgroup-np           (r-card,       "number-cardinal"  , num s-num existential specific)
                _sgroup-np          (card, r-card, "number-cardinal"  , num s-num existential specific)
                _sgroup-np          (r-card, card, "number-cardinal"  , num s-num existential specific)

		context-n+modifier  (card,         "number-cardinal"  , s-num )
		context-n+modifier  (r-card,       "number-cardinal"  , s-num )
		_context-n+modifier (card, r-card, "number-cardinal"  , s-num )
		_context-n+modifier (r-card, card, "number-cardinal"  , s-num )
		
		context-np+modifier  (card,         "number-cardinal"  , num s-num  existential specific)
		context-np+modifier  (r-card,       "number-cardinal"  , num s-num existential specific)
		_context-np+modifier (card, r-card, "number-cardinal"  , num s-num existential specific)
		_context-np+modifier (r-card, card, "number-cardinal"  , num s-num existential specific)
		
                number-id  (card )
		number-id  (r-card)
		_number-id (card, r-card)
		_number-id (r-card, card)
 
  		# ORDINAL (The predicate for ordinals is always the corresponding cardinal)
		
                _adj-none           (card, ord,     "number-ordinal"   ,  ) 
		_adj-none           (r-card, r-ord, "number-ordinal"   ,  ) 
		_adj-none           (card, r-ord,   "number-ordinal"   ,  ) 
		_adj-none           (r-card, ord,   "number-ordinal"   ,  ) 
		
		_context-n+modifier (card, ord,     "number-ordinal"   , s-sg  )  
		_context-n+modifier (r-card, r-ord, "number-ordinal"   , s-sg  )  
		_context-n+modifier (card, r-ord,   "number-ordinal"   , s-sg  )  
		_context-n+modifier (r-card, ord,   "number-ordinal"   , s-sg  )  
		
		_sgroup-n            (card, ord,      "number-ordinal"   , s-sg  ) 
               	_sgroup-n            (r-card, r-ord,  "number-ordinal"   , s-sg  ) 
    	        _sgroup-n            (card, r-ord,    "number-ordinal"   , s-sg  ) 
		_sgroup-n            (r-card, ord,    "number-ordinal"   , s-sg  ) 
    
		
   
 }
  
  number-basic(one, first, "1", "1st", s-sg, sg)
     # This gives a reading equivalent to 'a ball'
     det+context-np+group-np  (one,   s-sg sg  existential specific)        
     # This is for handling the dummy noun for the contextual 'the ones on the table'
	 context-n(ones, entity, s-pl full)  
	 context-n(one, entity, s-sg full)
	   
  number-irr(two, second, "2", "2nd")
  number-irr(three, third, "3", "3rd")
  number(four, "4")
  number-irr(five, fifth, "5", "5th")
  number(six, "6")
  number(seven, "7")
  number-irr(eight, eighth, "8", "8th")
  number(nine, "9")
  number(ten, "10")
  number(eleven, "11")
  number(twelve, "12")
  number(thirteen, "13")
  number(fourteen, "14")
  number(fifteen, "15")
 
###############
## ADVERBS   ##
###############

# Purpose ascribing to, i.e. I went in to see him, I picked it up to play with it.

word to-purpose: Adv+verb-base- (m-purpose, pred=to)    {to: s-purpose ;}


###############
## PARTICLES ##
###############

  word up : Particle;

###########
## COORD ##
###########

  coord+(and, np,   entity, s-pl pl)
  coord+(and, n,    entity, s-pl pl)
  coord+(then, np,   entity, s-pl pl) _coord+(then, and_then, np,   entity, s-pl pl)
  coord+(then, n,    entity, s-pl pl) _coord+(then, and_then,  n,   entity, s-pl pl)
  
  coord+(before, np,   entity, s-pl pl) 
  coord+(before, n,    entity, s-pl pl)
  
  coord+(after, np,   entity, s-pl pl) 
  coord+(after, n,    entity, s-pl pl)


  coord+(or, np,   entity, s-sg)
  coord+(or, n,    entity, s-sg)

  coord(and, s, event)
  coord(but, s, event)
  coord(then, s, event)   _coord(then, and_then, s, event)    
  coord(or, s, event) 

  coord(and, prep, modifier)
  coord(but, prep, modifier)
  coord(then, prep, modifier)  _coord(and, and_then, prep, modifier)
  coord(or, prep, modifier)

  coord(and, adv, modifier)
  coord(but, adv, modifier)
  coord(then, adv, modifier)  _coord(and, and_then, adv, modifier)
  coord(or, adv, modifier)

  coord(and, adj, quality)
  coord(but, adj, quality)
  coord(then, adj, quality)  _coord(and, and_then, adj, quality)
  coord(or, adj, quality)


############
# WH-WORDS #
############

# This only handles a single family, not a list like 
# the underlying classes. This is due to string formation
#
def wh+extr(form, class, item, args) {
  wh-word(form, class, "Wh-".item."-")
#  extr(form, class, "Extr-".item."-", args)
#  _extr(form, form."ever", class, "Extr-".item."-", args)  # must add features!
}

def wh+extrrr(form, class, item, args) {
  wh-word(form, class, "Wh-".item."-")
  extr(form, class, "Extr-".item."-", args)
  _extr(form, form."ever", class, "Extr-".item."-", args)  # must add features!
}


wh+extrrr(who, animate, np , s-sg nf-real)

wh+extrrr(what, entity, np , s-sg nf-real)
wh+extrrr(what, event, sent, fin)

wh+extrrr(which, specifier, np-spec, nf-real)
wh+extrrr(which, specifier, np-spec-ctxt, nf-real)

wh-word(which, specifier , Wh-np-spec-ctxt- Wh-np-qclass- Wh-adj-qclass-  )
#wh-word(which, specifier , Wh-np-spec- Wh-np-spec-ctxt- Wh-np-qclass- Wh-adj-qclass-  )
wh-word(what , specifier , Wh-np-spec- Wh-np-qclass- Wh-adj-qclass-  )

wh-word(whose, owner , Wh-np-spec- Wh-np-spec-ctxt-)

wh+extrrr(how_much, quantity, np-quant-mass  , s-sg nf-real)
wh+extrrr(how_many, quantity, np-quant-count , s-sg nf-real)

# Adding degree-base here wasn't really 'intended'. It was to avoid having an
# empty arg slot in the wh+extr def

wh+extr(how, quality, adj , s-degree-base cc-none)
wh+extr(how, quality, adj-degree , s-degree-base cc-none)
wh-word+feat(how, m-manner, Wh-sent-modifier-, s-manner)
extr(how, m-manner, Extr-adv-sent-modifier-, adv-2 s-manner x-manner)

wh+extrrr(where, m-location, pp , prep-1 x-location )
wh-word+feat(where, m-location, Wh-sent-modifier-, s-location)
extr(where, m-location, Extr-pp-sent-modifier-,  prep-1 s-location x-location)

wh+extrrr(where, m-dynamic, pp , x-dynamic prep-2 )
wh-word+feat(where, m-dynamic, Wh-sent-modifier-, s-dynamic)
extr(where, m-dynamic, Extr-pp-sent-modifier-,  prep-1 s-dynamic x-dynamic)

# Time Questions

wh-word+feat(when, m-time-point, Wh-sent-modifier-, s-time)
wh-word+feat(how_long, m-time-interval, Wh-sent-modifier-, s-time)


#wh-word(how, degree , Wh-adj-degree Extr-adj-degree )
#wh-word(how, quality, Wh-adj Extr-adj)
#wh-word+(how, m-manner, Wh-sent-modifier, s-manner)
#wh-word+(how, m-manner, Extr-adv-sent-modifier, adv-2 s-manner x-manner)

# Prep-1 allows post-s, post-vp 
#        and post-n, i.e. it can handle 'the place where I put it', 'the room where I stayed' etc.
 
#wh-word(where,  m-location, Wh-pp) 
#wh-word+(where, m-location, Wh-sent-modifier,        s-location)
#wh-word+(where, m-location, Extr-pp,                  prep-1 x-location)
#wh-word+(where, m-location, Extr-pp-sent-modifier,    prep-1 s-location x-location)

#wh-word(where,  m-dynamic, Wh-pp)  
#wh-word+(where, m-dynamic, Wh-sent-modifier,     s-dynamic)
#wh-word+(where, m-dynamic, Extr-pp,               prep-1 x-dynamic)
#wh-word+(where, m-dynamic, Extr-pp-sent-modifier, prep-1 s-dynamic x-dynamic)

quality-class(size)
quality-class(shape)
quality-class(color) _quality-class(color, colour)
quality-class(age)
quality-class(material)
quality-class(substance)
quality-class(temperature)
quality-class(orientation)


#wh-s-mod(where, m-location, s-location)
#wh-s-mod(blah, m-dynamic, s-dynamic)
#wh-s-mod(how, m-manner, s-manner)



############
# BE-FORMS #
############

# These forms of the be verb are used by be as copular & as its various aux forms 
# ( be + v+ing, be + passive )

def be-forms (args) {
    am:        be  pres  1st     s-sg s-prov-pos      args;
	are:       be  pres          s-pl s-prov-pos      args;
	are:       be  pres  2nd     s-sg s-prov-pos      args;
	"aren't":  be  pres          s-pl s-neg      neg  args;
	"aren't":  be  pres  2nd     s-sg s-neg      neg  args;
    is:        be  pres  3rd     s-sg s-prov-pos      args;
    "isn't":   be  pres  3rd     s-sg s-neg      neg  args;
	"ain't":   be  pres               s-neg      neg  args;
	was:       be  past  1st     s-sg s-prov-pos      args;
	was:       be  past  3rd     s-sg s-prov-pos      args;
	"wasn't":  be  past  1st     s-sg s-neg      neg  args;
	"wasn't":  be  past  3rd     s-sg s-neg      neg  args;
	were:      be  past  2nd     s-sg s-prov-pos      args;
	were:      be  past          s-pl s-prov-pos      args;
	"weren't": be  past  2nd     s-sg s-neg      neg  args; 
	"weren't": be  past          s-pl s-neg      neg  args; 
}


###########
# COPULAR #
###########

# The copular and its negation
# There are two versions of this because the normal locational (I am here)
# is blocked from allowing additional post-modified locations
#
word be-copular: Copular(ascription, pred=be){

    be-forms(fin-full m-class-2x)

 	been:    pp        m-class-3; 
    being:   ing       m-class-3;
 	be:      vf-base   m-class-3; 
	be:      vf-to-imp m-class-3; 

}

word be-copular-loc: Copular-location(ascription, pred=be){

    be-forms(fin-full m-class-3)

 	been:    pp        m-class-3; 
    being:   ing       m-class-3;
 	be:      vf-base   m-class-3; 
 	be:      vf-to-imp m-class-3; 

}


word not-cop-neg :Cop-negation{not: neg;}

# The presentational there+be
# There are two versions of this because the inverted version
# is blocked from allowing additional post-modified locations
#
word be-presentational: Presentational(presentational, pred=be){

    be-forms(fin-full m-class-2)

 	been:    pp      m-class-2; 
    being:   ing     m-class-2;
 	be:      vf-base m-class-2; 

}

word be-presentational-inverted: Presentational-inverted(presentational, pred=be){

    be-forms(fin-full m-class-3)

 	been:    pp      m-class-3; 
    being:   ing     m-class-3;
 	be:      vf-base m-class-3; 

}

 word dummy-there : Bare-np(dummy, pred=there){ there: nom dummy-there;}

#####################
## MODAL/AUX VERB ##
#####################

  # Modal Verbs #

  modal(should, modal, pres)
  modal(must,   modal, pres)
  modal(would, modal, )
  modal(could, modal, )
  modal-irr(can,  "can't", modal, pres)
  modal-irr(will, "won't", modal, fut)
   

  # Auxilliary Verbs #

  word not-aux-neg: Aux-negation {not: neg;}  # syntactic change from s-prov-pos to s-neg in family

  # Note: currently  'I did go' is treated identically to 'I went'
  #       and hence collapse. If we want emphatic do, it'll have to be
  #       treated as a modal, and hence be given its own <Modal> dep reln.

  word do-aux: Aux-vf-base(aux){
	do:        do pres non-3rd s-sg  s-prov-pos     ;
    "don't":   do pres non-3rd s-sg  s-neg      neg ;
	do:        do pres         s-pl  s-prov-pos     ;
    "don't":   do pres         s-pl  s-neg      neg ;
	does:      do pres 3rd     s-sg  s-prov-pos     ;
	"doesn't": do pres 3rd     s-sg  s-neg      neg ;
	did:       do past               s-prov-pos	    ;
	"didn't":  do past               s-neg      neg ;
  }
  
  word do-imp: imp-do {
	do:        do   s-prov-pos     ;
    "don't":   do   s-neg      neg ;
  }

  word lets-imp: imp-lets {
	"let's":   do   s-pos      ;
  }

  word have-aux: Aux-pp(aux){   
	have:      have pres perfect non-3rd s-sg  s-prov-pos      ;
    "haven't": have pres perfect non-3rd s-sg  s-neg       neg ;
	have:      have pres perfect         s-pl  s-prov-pos      ;
    "haven't": have pres perfect         s-pl  s-neg       neg ;
	has:       have pres perfect 3rd     s-sg  s-prov-pos      ;
	"hasn't":  have pres perfect 3rd     s-sg  s-neg       neg ;
	had:       have past perfect               s-prov-pos      ;
	"hadn't":  have past perfect               s-neg       neg ;
  }
  word have-aux-no-int: Aux-no-int-pp(aux){  
     have:   vf-base perfect;   # will have
  }


  word be-aux-vf-be: Aux-vf-be (aux) {
    be-forms()
  }
  word be-aux-vf-be-no-int: Aux-no-int-vf-be (aux) {
 	be:       vf-base  ;      # will be going, can be going, etc.
    been:     pp       ;      # have been going
  }

  word be-aux-ing: Aux-ing (aux) {
    be-forms(continuous)
  }
  word be-aux-ing-no-int: Aux-no-int-ing (aux) {
    be:       vf-base  continuous;      # will be going, can be going, etc.
    been:     pp       continuous;      # have been going
  }


  # Currently, no wh-questions can be handled in passsives, as this'll require
  # adding a new 'passive' for for each...

  word be-passive-aux: Aux-passive (aux) {
     be-forms(passive)
  } 

  word be-passive-aux-no-int: Aux-no-int-passive (aux) {
  	 be:      vf-base passive;       
 	 being:   ing     passive;       
	 been:    pp      passive;            
  } 

 word get-passive-aux: Aux-no-int-passive (aux) {
  	 get:      fin-full passive pres s-pos do non-3rd s-sg  ;  	
     gets:     fin-full passive pres s-pos do 3rd     s-sg  ;
     get:      fin-full passive pres s-pos do         s-pl  ;
     got:      fin-full passive past s-pos do               ;
	 get:      vf-base  passive;       
 	 getting:  ing      passive;       
	 got:      pp       passive;            
  } 



######### OLD
  # NOTE: These, like there pp counterparts are modifiable by post-adjs (somewhere big) and pp (somwhere on the table) 
  #       Currently done with these two rules, though it's a hack!
  #       Better would be to return to mod-type for n&nps including direction. This would involve
  #       changing noun modifiers (adj, pp, rel-clause) and dets to set to 'can't modify'
  # rule { typechange: adj(pre-n)$1  =>  from-n() \ n(s-num-post) :  ENTITY( <Property>(M) ) ; } 
  # rule { typechange: n(s-num-post)   =>  from-np(3rd s-sg)  ; } 





# This file contains most dictionary entries. 
# Specifically, the 'open class words' 
#        nouns, verbs, adjectives, adverbs, prepositions, discourse-markers, mod-modifiers

# The entries have been sorted first by 'Part of Speech' then by ontological sort (person, thing, etc)

# All entries are entered using one of the 'dictionary-entry' macros (defs) listed in the various .ccg files
# in the grammar proper. 

# Althoug, of course, you must check the apporpriate file for specifics,
# the standard convention for these dictionary-entry macros is 
#
#     macro-name( various forms, ontological sort (i.e. class), other arguments (including feature-macros, family listing) )
#
# For alternate variations (i.e. different entries with the same predicate (e.g. forward, forwards) )
# for each additional form, you must add a separate entry using the alternate-form macro.
#
#     _macro-name(predicate, various forms, ontological sort (i.e. class), other arguments (including feature-macros, family listing) ) 
#
# This is Identical to the standard macro, except, it is prefaced with an underscore _, and the first element is the predicate, then
# the alternate variation in all of its forms
# 
#  e.g. Here are the entries for the adverbs 'slow' & alternate 'slowly' 
#           adverb(slowly, manner, adv-all,) 
#          _adverb(slowly, slow, manner, adv-all,)

# NOTE:
# There is currently, unlike in older Moloko, a way of handling Multi-word expressions. 


###########
## NOUNS ##
###########

  # Person #

  noun(person, person,)
  noun(boy, person,)
  noun(girl, person,)
  noun(dad, person,)
  noun(mom, person,)  _noun(mom, mamma, person,)
  noun-irr(man, men, person,)
  noun-irr(woman, women, person,)
  noun-irr(child, children, person,)
  noun(guy, person,)
  noun(secretary, person,)
  noun-irr(policeman, policemen, person,)
  noun(janitor, person,)
  noun(student, person,)
  noun(researcher, person,)
  noun(pirate, person,)

  # This gives every person a Discourse Marker reading, allowing it to function as a vocative
  # GJ could you come here . NOTE: NO CO-INDEXING occurs for this in the grammar
  #
  def name+vocative(form, class) {_name+vocative(form, form, class) }
  def _name+vocative(prd, form, class){
     _name(prd, form, class,)
     _dis-marker+(prd, form, class, fin-full) # blocks from getting 'GJ has a ball'... to parse as contextualized, 'GJ, has a ball been put here recently'
  }

  name+vocative(GJ, person,)
  name+vocative(Trevor, person,)	
  name+vocative(Hendrik, person,)	
  name+vocative(Henrik, person,)	
  name+vocative(Pierre, person,)
  name+vocative(Patric, person,)		
  name+vocative(Nick, person,)	
  name+vocative(Michael, person,)	
  name+vocative(Oscar, person,)	
  name+vocative(Daniel, person,)	
  name+vocative(Maria, person,)	  
  name+vocative(Jeremy, person,)	
  name+vocative(Aaron, person,)	
  name+vocative(Chandana, person,)	
 
  noun(Borland, entity,) 
  
  # Animate #
 
  name+vocative(Robot, animate) _name+vocative(Robot, robot, animate)
   
  noun(dog, animate,) 
  noun(cat, animate,) 
  noun-irr(fish, fish, animate,) 
  noun(cow, animate,) 
  noun(animal, animate,) 
  noun(robot, animate,) 
 
  # Thing #
  
  noun(thing, thing,)
  noun(object, thing,)
  noun(entity, thing,)
 
  noun(triangle, thing,) 
  noun(square, thing,) 
  noun(star, thing,) 
  noun(circle, thing,) 
 
  noun(flag, thing,) 
   
  noun(game, thing,) 
    
  noun(car, thing,)
  noun(wall, thing,)
    
  noun(pizza, thing,) 
  noun(thing, thing,) 
  noun(book, thing,) 
  noun(ball, thing,) 
  noun(block, thing,) 
  noun(box, thing,) 
  noun(bucket, thing,) 
  noun(pin, thing,) 
  noun(cube, thing,) 

  noun(trophy, thing,) 
  noun-irr(tooth, teeth, thing,) 
  noun(mug, thing,) 
  noun(cup, thing,) 
  noun(jug, thing,) 
  noun(keyboard, thing,) 
  noun(laptop, thing,) 
  noun(screen, thing,) 
  noun(computer, thing,) 
  noun(mp3-player, thing,) 
  noun(minidisc-recorder, thing,) 
  noun(needle, thing,) 
  noun(thread, thing,) 
  noun-mass(thread, thing,) 
  noun(flower, thing,) 
  noun(phone, thing,) _noun(phone, telephone, thing,)
  noun(mobile, thing,) _noun(mobile, cell, thing,) _noun(mobile, handy, thing,) _noun(mobile, cellphone, thing,)  
  noun(letter, thing,) 
  noun(mailbox, thing,) 
  noun(copier, thing,) 
  noun(fax, thing,) 
  noun(printer, thing,) 
  noun(column, thing,)  _noun(column, pillar, thing,)
  noun-mass(furniture, thing,) 
  noun(floor, thing,) 
  noun(door, thing,) 
  noun(couch, thing,) _noun(couch, sofa, thing,)
  noun(tv, thing,)  _noun(tv, television, thing,)
  noun(oven, thing,) _noun(oven, cooker, thing,) _noun(oven, stove, thing,)
  noun(tabletop, thing,) _noun(tabletop, desktop, thing,)
  noun(fridge, thing,)   _noun(fridge, refridgerator, thing,)
  noun(microwave, thing,)   
  noun-irr(shelf, shelves, thing,) 
  noun(closet, thing,)
  noun(desk, thing,)
  noun(table, thing,)
  noun(chair, thing,)   
  noun(scenery, thing,) 
  noun(fax, thing,)   
  noun(machine, thing,) 
  noun(kettle, thing,) 
  noun-mass(scissors, thing,) 
  noun-mass(food, thing,) 

  
  # How handle 'a water' and 'some water'??
 
  noun(chocolate, thing,)
  noun(tea, thing,) 
  noun(coffee, thing,) 
  noun(water, thing,) 
   
  # e-substance #
  noun-mass(tea, e-substance,)
  noun-mass(coffee, e-substance,)
  noun-mass(chocolate, e-substance,) 
  noun-mass(water, e-substance,) 
  
  noun-mass(wood, e-material,) 
  noun-mass(metal, e-material,) 
  noun-mass(plastic, e-material,) 
	  
  # e-event #

  noun(event,       e-event,) 
  noun(competition, e-event,) 
  noun(interaction, e-event,) 

 # e-location #

  noun(place, e-place,) 
  noun(office, e-place,) 
  noun(room, e-place,)   
  noun(hall, e-place,)  _noun(hall, hallway, e-place,) _noun(hall, corridor, e-place,)
  noun(bathroom, e-place,) _noun(bathroom, washroom, e-place,) _noun(bathroom, toilet, e-place,) _noun(bathroom, wc, e-place,)
  noun(lab, e-place,)  _noun(lab, laboratory, e-place,) 
  noun(kitchen, e-place,) 
  noun(library, e-place,)
  noun(livingroom, e-place,)
  noun(recreationroom, e-place,)
  noun(library, e-place,)
  
  noun(secretariat, e-place,)
  noun(lobby, e-place,)
  noun(entrance, e-place,)
  noun(lift, e-place,) _noun(lift, elevator, e-place,)
  noun(stairs, e-place,) _noun(stairs, starecase, e-place,)
  noun(floor, e-place,)
  noun(way, e-place,)
  noun(direction, e-place,)
  noun(university, e-place,)
  noun(station, e-place,)   # must handle charging station

  noun(location, e-place,)    noun+of-np(location, e-place, n-1)
  noun(area, e-place,)       noun+of-np(area, e-place, n-1)

  name(DFKI, e-place,)		  noun(DFKI, e-place,)
  name(Starbucks, e-place,) 	  noun(Starbucks, e-place,)

  noun(side, e-region,)    noun+of-np(side, e-region, n-1)
  noun(edge, e-region,)    noun+of-np(edge, e-region, n-1)
  noun(corner, e-region,)  noun+of-np(corner, e-region, n-1)
  noun(beginning, e-region,)  noun+of-np(beginning, e-region, n-1)
  noun(start, e-region,)   noun+of-np(start, e-region, n-1)
  noun(end, e-region,)     noun+of-np(end, e-region, n-1)	      
  noun(front, e-region,)   noun+of-np(front, e-region, n-1)
  noun(back, e-region,)     noun+of-np(back, e-region, n-1)
  noun(top, e-region,)      noun+of-np(top, e-region, n-1)
  noun(bottom, e-region,)   noun+of-np(bottom, e-region, n-1)
  noun(middle, e-region,)   noun+of-np(middle, e-region, n-1)
  noun(section, e-region,)    noun+of-np(section, e-region, n-1)
  noun(part, e-region,)    noun+of-np(part, e-region, n-1)
  
  
  # ???? #
 
#  noun(name, entity, n-3)  noun+of-np(name, entity, cc-none )
#  noun(color, entity, n-3) noun+of-np(color, entity, cc-none ) _noun(color, colour, entity, n-3) _noun+of-np(color, colour, entity, cc-none )
#  noun(shape, entity, n-3) noun+of-np(shape, entity, cc-none ) 
#  noun(size, entity, n-3)  noun+of-np(size, entity, cc-none )


  noun(name, entity, )  noun+of-np(name, entity, cc-none )
  noun(case, entity, )  

  noun(color, entity, n-3) noun+of-np(color, entity, cc-none ) _noun(color, colour, entity, n-3 ) _noun+of-np(color, colour, entity, cc-none )
  noun(shape, entity, n-3) noun+of-np(shape, entity, cc-none ) 
  noun(size, entity, n-3)  noun+of-np(size, entity, cc-none )

  noun(question, entity, )    
  noun(answer, entity, )    
  noun(help, entity, )    
  noun(guidance, entity, ) 
  noun(aid, entity, ) 
  noun(suggestion, entity, ) 

  noun(look, entity, )
  noun(peek, entity, )

  # e-time #
  
  noun(time, e-time,)
  noun-mass(time, e-time,)
  
  noun(second, e-time-unit,)    _noun(second, sec, e-time-unit,)  
  noun(minute, e-time-unit,)  
  noun(hour, e-time-unit,)   
  noun(week, e-time-unit,)   
  noun(day, e-time-unit,)   
  noun(month, e-time-unit,)   
  noun(year, e-time-unit,)   

  noun-mass(while, e-time-unit, cc-none)
  noun-mass(bit, e-time-unit, cc-none)


  # e-measure #
  
  noun+of-np(piece, e-measure, n-2)
  noun+of-np(set, e-measure, n-2)
  noun+of-np(pile, e-measure, n-2)
  noun+of-np(few, e-measure, n-2)
  noun+of-np(group, e-measure, n-2)
  noun+of-n(kind, e-measure, n-2) _noun+of-n(kind, sort, e-measure, n-2) _noun+of-n(kind, type, e-measure, n-2)

  

################
## ADJECTIVES ##
################


  # q-attitude #

  adj-deg(good, better, best, q-attitude,)
  adj-deg(bad, worse, worst, q-attitude,)
  adj-deg(sorry, sorrier, sorriest, q-attitude,)
  adj-deg(cool, cooler, coolest , q-attitude,)
  adj-deg(guilty, guiltier, guiltiest, q-attitude,)
  adj-deg(happy, happier, happiest, q-attitude,)
  adj-deg(sad, sadder, saddest, q-attitude,)
  adj-deg(nice, nicer, nicest, q-attitude,)
  
  adj-none(sure, q-attitude,)  
  adj-none(ok, q-attitude,)  
  adj-none(important, q-attitude,)  
  adj-none(correct, q-attitude,)  
  adj-none(right, q-attitude,) 
  adj-none(wrong, q-attitude,)  
  adj-none(true, q-attitude,) 
  adj-none(false, q-attitude,)  
  

  # q-size #
  
  adj-deg(big, bigger, biggest, q-size,) 
  adj-deg(small, smaller, smallest, q-size,)
  adj-deg(tiny, tinier, tiniest, q-size,) 

  # q-color #

  adj-deg(red, redder, reddest, q-color,)
  adj-deg(blue, bluer, bluest, q-color,)
  adj-deg(green, greener, greenest, q-color,)  
  adj-deg(yellow, yellower, yellowest, q-color,)  

  adj-deg(pink, pinker, pinkest, q-color,)
  adj-deg(black, blacker, blackest, q-color,)  
  adj-deg(white, whiter, whitest, q-color,)
  adj-deg(grey, greyer, greyest, q-color,)  
  adj-deg(brown, browner, brownest, q-color,)
  adj-deg(purple, purpler, purplest, q-color,)  

  adj-deg(dark, darker, darkest, q-color,)
  adj-deg(light, lighter, lightest, q-color,)  
  
  # q-shape #
  
  adj-deg(long,longer,longest,q-shape,)
  adj-deg(short,shorter,shortest,q-shape,)
  adj-deg(tall,taller,tallest,q-shape,) 
  adj-deg(narrow,narrower,narrowest,q-shape,)   
  adj-deg(wide,wider,widest,q-shape,) 
  adj-deg(fat,fatter,fattest,q-shape,)   
  adj-deg(thin,thinner,thinnest,q-shape,) 
  adj-deg(round,rounder,roundest,q-shape,)  
  adj-none(oval,q-shape,) 
  adj-none(square,q-shape,)   
  adj-none(triangular,q-shape,)   
   
  # q-physical #
 
  adj-none(open,q-physical,) 
  adj-none(closed,q-physical,) 
  
  adj-none(cluttered,q-physical,) 
  adj-none(accessible,q-physical,) 
  adj-none(inaccessible,q-physical,) 
  adj-none(reachable,q-physical,) 
  adj-none(unreachable,q-physical,) 
  adj-none(visible,q-physical,) 
  adj-none(invisible,q-physical,) 
  adj-none(graspable,q-physical,) 
  adj-none(ungraspable,q-physical,) 
  
  # q-location #
  
  # left & right, near & far are in directions (in prep) below
  
  adj-none(top,q-location,) 
  adj-none(bottom,q-location,) 
  adj-none(middle,q-location,) 
 
  # q-age #
  
  adj-deg(old, older, oldest, q-age,)  
  adj-deg(young, younger, youngest, q-age,)
   
  # q-number #
    
  # Numbers handled in dictionary-closed
  
  # q-position #

  adj-none(first,q-position,) 
  adj-none(last,q-position,)
  adj-none(next,q-position,)
  adj-none(previous,q-position,)
  adj-none(other,q-position,) 
    
  # q-state #
  
  adj-none(empty,q-state,) 
  adj-none(full,q-state,) 
  adj-none(hungry,q-state,)   
  adj-none(thirsty,q-state,)
  adj-none(tired,q-state,) 
  adj-none(finished,q-state,) 
  adj-none(started,q-state,)   
  adj-none(on,q-state,) 
  adj-none(off,q-state,) 
  adj-none(ready,q-state,)   
 	   	   
  # UNSORTED quality

  adj-none(known,quality,)
  adj-none(unknown,quality,)




############
## VERBS  ##
############
  
  # to block a verb from receiving an imperative reading, use ....-no-imp
  # e.g. verb-no-imp or verb-reg-no-imp
  
  ### action-motion ###
  
  verb(go, going, went, gone, m-class-all, action-motion,                iv )
  verb(come, coming, came, come, m-class-all, action-motion,             iv )
  verb-reg(return, m-class-all, action-motion,                           iv )
  verb-reg(walk, m-class-all, action-motion,                             iv )
  verb-reg(turn, m-class-all, action-motion,                             iv )
  verb-reg(follow, m-class-all, action-motion,                           iv tv )
  verb-reg(pass, m-class-all, action-motion,                             iv )
  verb(move, moving, moved, moved, m-class-all, action-motion,           iv tv v+np+pp-whereto)
  
  verb(bring, bringing, brought, brought, m-class-all, action-motion,    iv )
  
  
  
  ### action-non-motion ###
  
  verb-reg(play, m-class-1, action-non-motion,                           iv tv)   # Changed to m-class 1, aug 20, to allow 'how did we play the colour game'. Which how was meant here???
  verb(win, winning, won, won, m-class-2, action-non-motion,             iv tv)  
  verb(lose, losing, lost, lost, m-class-2, action-non-motion,           iv tv) 
  verb-reg(kill, m-class-2, action-non-motion,                           tv) 
  verb-reg(bother, m-class-2, action-non-motion,                         tv)
  
  _verb-no-imp(go-loc, go, going, went, gone, m-class-3, action-non-motion,       v+pp-loc)  # they go on the table. where does this go
  
  verb(buy, buying, bought, bought, m-class-1, action-non-motion,        tv dtv )
  verb(give, giving, gave, given, m-class-1, action-non-motion,          tv dtv dtv-to )
  
  #verb(get, getting, got, got, m-class-1, action-non-motion,             tv dtv dtv-to v+np+pp-whereto )
  #verb(take, taking, took, taken, m-class-1, action-non-motion,          tv v+np+pp-whereto)
  #verb(bring, bringing, brought, brought, m-class-1, action-non-motion,  tv dtv dtv-to v+np+pp-whereto )
  #verb-reg(fetch, m-class-1, action-non-motion,  tv dtv)
  
  
  #Aug 20, changed to m-class-all to allow parsing 'from', i.e. get me the ball from the table
  
  verb(get, getting, got, got, m-class-all, action-non-motion,             tv dtv dtv-to v+np+pp-whereto )
  verb(take, taking, took, taken, m-class-all, action-non-motion,          tv v+np+pp-whereto)
  verb(bring, bringing, brought, brought, m-class-all, action-non-motion,  tv dtv dtv-to v+np+pp-whereto )
  verb-reg(fetch, m-class-all, action-non-motion,  tv dtv)
  
  
  verb(eat, eating, ate, ate, m-class-1, action-non-motion,              iv tv)
  verb(drink, drinking, drank, drank, m-class-1, action-non-motion,      iv tv)
  
  verb(sleep, sleeping, slept, slept, m-class-1, action-non-motion,      iv )
  
  verb(stand, standing, stood, stood, m-class-1, action-non-motion,      iv )
  verb(sit, sitting, sat, sat, m-class-1, action-non-motion,             iv )
  verb-reg(wait, m-class-1, action-non-motion,                           iv v+for-np)
  
  verb(put, putting, put, put, m-class-1, action-non-motion,             v+np+pp-whereto )
  
  verb-reg(pick, m-class-1, action-non-motion,                           v+np+prt )
  verb(make, making, made, made, m-class-1, action-non-motion,           tv v+np+verb-base v+np+adj v+np+of-np-result v+np+from-np-result v+np+out_of-np-result)
  
  verb(find, finding, found, found, m-class-2, action-non-motion,            tv dtv) 
  verb(show, showing, shown, shown, m-class-2, action-non-motion,            tv dtv) 
  verb(explore, exploring, explored, explored, m-class-2, action-non-motion, iv tv) 
  verb-reg(search, m-class-2, action-non-motion,                           iv v+for-np)
     _verb-reg(search, look, m-class-2, action-non-motion,                 iv v+for-np)
  verb(find, finding, found, found, m-class-2, action-non-motion,        iv tv) 
  
  verb-reg(help, m-class-2, action-non-motion,                           tv v+np+verb-base)
  verb(use, using, used, used, m-class-2, action-non-motion,             tv v+instrumental-np+verb-inf) 
  verb-reg(fix, m-class-2, action-non-motion,                            tv)
  verb(break, breaking, broke, broke, m-class-2, action-non-motion,      tv) 
  
  
 
  
  ### cognition ###
  
  verb(know, knowing, knew, known, m-class-3, cognition, iv tv v+adj v+pp v+dep-clause)
  verb(understand, understanding, understood, understood, m-class-3, cognition, iv tv v+adj v+pp v+dep-clause )
  
  # DO WE NEED TO SEPARATE THESE UP ON THEIR TYPE i.e. Modal vs Not
  
  verb(mean, meaning, meant, meant, m-class-3, cognition,         tv v+verb-inf v+dep-clause)
  
  verb-reg(want, m-class-3, cognition,                                    tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb-reg(need, m-class-3, cognition,                                    tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb(like, liking, liked, liked, m-class-3, cognition,                  tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb(memorize, memorizing, memorized, memorized, m-class-3, cognition,  tv)
  
  verb(assume, assuming, assumed, assumed, m-class-3, cognition,         v+dep-clause)
  verb(hope, hoping, hoped, hoped, m-class-3, cognition,                 v+dep-clause v+verb-inf) 
  verb(suppose, supposing, supposed, supposed, m-class-3, cognition,     v+dep-clause v+verb-inf)
  verb(think, thinking, thought, thought, m-class-3, cognition,          v+dep-clause)
  verb(believe, believing, believed, believed, m-class-3, cognition,     v+dep-clause)
  verb(imagine, imagining, imagined, imagined, m-class-3, cognition,     v+dep-clause)
  verb(bet, betting, bet, bet, m-class-3, cognition,                     v+dep-clause)
  verb-reg(guess, m-class-3, cognition,                                  v+dep-clause)
  verb(figure, figuring, figured, figured, m-class-3, cognition,         v+dep-clause)
  
  ### communication ###
  
  
  #### MUST PROPERLY ADD/REMOVE fams to handle 'I told him where he is' but not 'I told him in the room'
  
  verb(tell, telling, told, told, m-class-2, communication,              tv v+np+verb-inf v+np+dep-clause dtv dtv-to v+np+pp-loc)
  verb-reg(ask, m-class-2, communication,                                iv tv v+np+verb-inf v+np+dep-clause dtv dtv-to v+np+pp-loc)
  verb(say, saying, said, said, m-class-2, communication,                iv v+dep-clause)
  verb-reg(explain, m-class-2, communication,                            tv dtv dtv-to)
  verb-reg(talk, m-class-2, communication,                               iv v+to-np v+with-np)
  verb(speak, speaking, spoke, spoke, m-class-2, communication,          iv v+to-np v+with-np)
  
  verb (excuse, excusing, excused, excused, m-class-2, communication,    tv dtv-for v+Rec-np+for-verb-ing)
  verb-reg(pardon, m-class-2, communication,                             tv dtv-for v+Rec-np+for-verb-ing)
  verb(thank, thanking, thanked, thanked, m-class-2, communication,      dtv-for v+Rec-np+for-verb-ing)
  word thanks-verb: Thanks(communication, pred=thank) { thanks: m-class-5 fin pres s-pos ; thank_you: m-class-5 fin pres s-pos;}
     # special verb family which creates indicative with <recipient>addressee and <actor>speaker
     # m-class5 blocks all modification but comments
  
  # perception #
  
  def per-fams() {iv tv v+np+verb-base v+np+verb-ing v+deictic-event} 
  
  verb(see, seeing, saw, seen, m-class-2, perception,                   per-fams() )
  verb-reg(watch, m-class-2, perception,                                per-fams() )
  verb-reg(look, m-class-2, perception,                                 per-fams() v+adj )
  verb(observe, observing, observed, observed, m-class-2, perception,   per-fams() )
  
  verb-reg(listen, m-class-2, perception,          iv v+to-np)
  verb(hear, hearing, heard, heard, m-class-2, perception,              per-fams() )
  verb-reg(sound, m-class-2, perception,                                v+adj )
  
  verb-reg(touch, m-class-2, perception,                                tv)
  verb(feel, feeling, felt, felt, m-class-2, perception,                tv v+adj)
  
  # symbolic #
  
  verb-reg(call, m-class-2, symbolic,                           tv )
  verb(name, naming, named, named, m-class-2, symbolic,         tv )
  
  # state #
  
  verb-basic(have, has, having, had, had, m-class-2, ascription,           tv )
  verb(feel, feeling, felt, felt, m-class-2, ascription,                   v+adj )
  verb(get, getting, got, got, m-class-2, ascription,                      v+adj )
  verb(become, becoming, became, become, m-class-2, ascription,            v+adj )
  
  # event #
  
  verb-reg(happen, m-class-2x, event,   iv v+to-np )
  
  # modal/aspectual ones #
  
  # These verbs have two entries. 1 is for the case where the 'aspectualized' event is
  # explicitly mentioned (e.g. I continued going down the hall). The second receives only
  # an 'implicit' event, (e.g. I continued down the hall)
  # The first is blocked to m-class-3 so that its event comp will receive the modifiers
  # In the second case, since there is no explicit verb here, the aspect verb
  # must be free for any kind of modification (m-class-all)
  
  verb(keep, keeping, kept, kept, m-class-3, modal,                    v+verb-ing v+np+verb-ing) 
  verb(keep, keeping, kept, kept, m-class-all, modal,                  iv)
  
  verb(continue, continuing, continued, continued, m-class-3, modal,   v+verb-inf v+verb-ing ) 
  verb(continue, continuing, continued, continued, m-class-all, modal, iv)
  
  verb(try, trying, tried, tried, m-class-3, modal,                    v+verb-inf v+verb-ing ) 
  verb(try, trying, tried, tried, m-class-all, modal,                  iv) 
  
  verb-reg(start, m-class-3, modal,                                    v+verb-inf v+verb-ing v+np+verb-ing) 
  verb-reg(start, m-class-all, modal,                                  iv)
  
  verb(begin, beginning, began, begun, m-class-3, modal,               v+verb-ing) 
  verb(begin, beginning, began, begun, m-class-all, modal,             iv) 
  
  verb-reg(restart, m-class-3, modal,                                  v+verb-ing v+np+verb-ing) 
  verb-reg(restart, m-class-all, modal,                                iv)
   
  verb-reg(finish, m-class-3, modal,                                   v+verb-ing v+deictic-event) 
  verb-reg(finish, m-class-all, modal,                                 iv) 
  
  verb(stop, stopping, stopped, stopped, m-class-3, modal,             v+verb-ing v+np+verb-ing v+deictic-event) 
  verb(stop, stopping, stopped, stopped, m-class-all, modal,           iv)
   
  verb(quit, quitting, quit, quit, m-class-3, modal,                   v+verb-ing v+deictic-event) 
  verb(quit, quitting, quit, quit, m-class-all, modal,                 iv) 
  
  verb-reg(got, m-class-3, modal,                                      v+verb-inf)
  verb(have, having, had, had, m-class-3, modal,                       v+verb-inf)
  
  verb-reg(happen, m-class-3, modal,                                   v+verb-inf)
  verb-reg(seem, m-class-3, modal,                                     v+verb-inf)

  verb(let, letting, let, let, m-class-4, modal,                       v+np+verb-base)
  
  adjectival-verb(able, m-class-3, modal,    v+verb-inf)
  adjectival-verb(willing, m-class-3, modal, v+verb-inf)
  adjectival-verb(supposd, m-class-3, modal, v+verb-inf)



##################
## PREPOSITIONS ##
##################

# Location & Dynamic #

  prp(at, location, prep-all)

  prp(onto,  whereto, prep-2)
  prp(into,  whereto, prep-2)
  prp(toward,  whereto, prep-2) _prp(toward, towards, whereto, prep-2) 

  prp(from, wherefrom, prep-2) # dynamic event reading      (I went from the office to the kitchen)
 # prp(from, location, prep-3)  # static locational reading  (the girl from the office is nice)
  prp(off, wherefrom, prep-2)
  prp+(of-np, out, wherefrom, prep-2)

  prp(through, through, prep-2)
        prp+(no-arg, through, direction, prep-2)    
  prp(across, through, prep-2)
        prp+(no-arg, across, direction, prep-2)    

  
  ## Restricts sort of anchor to e-region (i.e. to the right, to the corner)
  prp--(region, to, location, prep-all)   prp(to,  whereto, prep-2)
										      
  prp(on, location, prep-all)        prp(on, whereto, prep-2)
  prp(around, location, prep-all)    prp(around, whereto, prep-2)
       prp+(no-arg, around, direction, prep-2)    
  prp(beside, location, prep-all)    prp(beside, whereto, prep-2)
  prp(over, location, prep-all)      prp(over, whereto, prep-2)
  prp(above, location, prep-all)     prp(above, whereto, prep-2) 
  prp(under, location, prep-all)     prp(under, whereto, prep-2) 
     _prp(under, underneath, location, prep-all)             _prp(under, underneath, whereto, prep-2) 
  prp(below, location, prep-all)     prp(below, whereto, prep-2) 
  prp(by, location, prep-all)        prp(by, whereto, prep-2) 
  prp(behind, location, prep-all)    prp(behind, whereto, prep-2) 
  prp(up, location, prep-all)        prp(up, whereto, prep-2) 
      prp+(no-arg, up, direction, prep-2)    
  prp(down, location, prep-all)      prp(down, whereto, prep-2) 
       prp+(no-arg, down, direction, prep-2)      
  prp(along, location, prep-all)     prp(along, whereto, prep-2)
     _prp(along, alongside, location, prep-all)             _prp(along, alongside, whereto, prep-2)  # alongside
  prp(opposite, location, prep-all)  prp(opposite, whereto, prep-2) 
  prp(between, location, prep-all)   prp(between, whereto, prep-2) 

  prp+(to-np, next, location, prep-all)   prp+(to-np, next, whereto, prep-2) 

  prp+(of-np, in_front, location, prep-all)   prp+(of-np, in_front, whereto, prep-2) 
  prp+(of-np, in_back, location, prep-all)    prp+(of-np, in_back, whereto, prep-2) 
  prp+(of-np, on_bottom, location, prep-all)    prp+(of-np, on_bottom, whereto, prep-2) 
  
  prp(in, location, prep-all)        prp(in, whereto, prep-2) 
      prp+(no-arg, in, direction, prep-2) 
      _prp(in, inside, location, prep-all)             _prp(in, inside, whereto, prep-2) 
      _prp+(no-arg, in, inside, location, prep-all)    _prp+(no-arg, in, inside, whereto, prep-2) 

  prp(out, location, prep-all)        prp(out, whereto, prep-2) 
       prp+(no-arg, out, direction, prep-2)     
      _prp(out, outside, location, prep-all)             _prp(out, outside, whereto, prep-2) 
      _prp+(no-arg, out, outside, location, prep-all)    _prp+(no-arg, out, outside, whereto, prep-2) 

  # This gives 1) right of the table  2) to the left of the table  3) to the right
  def direction-word(loc) {
           prp+(of-np, loc, location, prep-all)    prp+(of-np, loc, whereto, prep-2) 
		   prp+(no-arg, loc, direction, prep-2)  
	 	   noun+of-np(loc, e-region, cc-none)
		   noun(loc, e-region, cc-none)
   	 	   adj-none(loc, q-location, )
  }

  direction-word(right)
  direction-word(left)
  direction-word(front)
  direction-word(back)

  prp+(no-arg, forward, direction, prep-2)  _prp+(no-arg, forward, forwards, direction, prep-2)
  prp+(no-arg, backward, direction, prep-2) _prp+(no-arg, backward, backwards, direction, prep-2)
  prp+(no-arg, straight, direction, prep-2) 
  prp+(no-arg, aside, direction, prep-2) 
  prp+(no-arg, away, direction, prep-2) 

  # This gives 1) the near ball 2) push it nearer 3) push it nearer to you 4) I am nearest to you
  
 def prep-adj(base, er, est, obl-marker) {
           prp-deg+(no-arg, base, er, est, location, prep-2)    prp-deg+(obl-marker."-np", base, er, est, location, prep-all) 
		   prp-deg+(no-arg, base, er, est, whereto, prep-2)     prp-deg+(obl-marker."-np", base, er, est, whereto, prep-2) 
		   adj-deg(base, er, est, q-location, )
  }

  prep-adj(far , farther , farthest, from) 
  
  prep-adj(near, nearer, nearest, to)  
        prp(near, location, prep-all)      prp(near, whereto, prep-2)  # near the stairs vs. near to the stairs
  prep-adj(close , closer , closest, to)  
 

  # Others #
  
  prp(for,  benefactor, prep-1)
  prp(with, accompaniment, prep-1)
  prp(with, instrumental, prep-1)
  prp(like, comparison, prep-1)

  
  # Time #
  
  prp--(time-unit, for, time-interval, prep-4)
  prp--(time-unit, in, time-point, prep-4)


################
## ADVERBS    ##
################

  # m-time #

  # time-point
  adverb(now, time-point, adv-1,)
  adverb(today, time-point, adv-3,)
  adverb(yesterday, time-point, adv-3,)
  adverb(tomorrow, time-point, adv-3,)
  adverb(yesterday, time-point, adv-3,)
  adverb(tomorrow, time-point, adv-3,)
  adverb+(dep-clause, when, time-point, adv-1,)
  adverb+(dep-clause, until, time-point, adv-1,)
      prp--(time-unit, until, time-sequence, prep-4)  # Time unit Preposition
  adverb(since, time-point, adv-1,)	  
  adverb+(dep-clause, since, time-point, adv-1,)
      prp--(time-unit, since, time-point, prep-4,)
	  
  # time-sequence
  adverb(next, time-sequence, adv-1,)
  adverb(first, time-sequence, adv-1,)
  adverb(then , time-sequence, adv-5,)

  adverb(after , time-sequence, adv-4,) _adverb(after, afterwards, time-sequence, adv-1,)
     adverb+(dep-clause, after, time-sequence, adv-1,)
     adverb+(verb-ing, after, time-interval, adv-6,)   
     prp--(time-unit, after, time-sequence, prep-4)
  adverb(before , time-sequence, adv-4,) _adverb(before, previously, time-sequence, adv-1,)
     adverb+(dep-clause, before, time-sequence, adv-1,)
     adverb+(verb-ing, before, time-interval, adv-6,)
     prp--(time-unit, before, time-sequence, prep-4)
      

  # time-interval
  adverb+(dep-clause, while, time-interval, adv-1,)
     adverb+(verb-ing, while, time-interval, adv-6,)
 
  # other time
  adverb-deg(soon, sooner, soonest, time, adv-all,)
  adverb-deg(early, earlier, earliest, time, adv-3,)
  adverb-deg(late, later, latest, time, adv-3,)

  adverb(still, time, adv-all,)
  adverb(already, time, adv-all,)
  adverb(just, time, pre-vp,)
  adverb(yet, time, adv-4,)
  adverb(ever, time, adv-6,)

  # m-manner #
 
  adverb(quickly, manner, adv-all,) _adverb(quickly, quick, manner, adv-all,) _adverb(quickly, fast, manner, adv-all,)
  adverb(slowly, manner, adv-all,)  _adverb(slowly, slow, manner, adv-all,)

  adverb(go, manner , adv-5,)
  adverb(run, manner , adv-5,)
  adverb(come, manner , adv-5,)  
  
  
  # m-probability # 

  adverb(maybe, probability, adv-all,)
  adverb(possibly, probability, adv-all,)
  adverb(probably, probability, adv-all,)
  adverb(perhaps, probability, adv-all,)
  adverb(certainly, probability, adv-all,)
  
  # m-frequency #
  
  adverb(normally, frequency, adv-all,)
  adverb(usually, frequency, adv-all,)
  adverb(occasionally, frequency, adv-all,)
  adverb(often, frequency, adv-all,)
  adverb(seldom, frequency, adv-all,) 
  adverb(rarely, frequency, adv-all,)  
  adverb(always, frequency, adv-all,)
  adverb(never, frequency, adv-all,)
  adverb(sometimes, frequency, adv-all,)
  
  adverb(again, frequency, adv-all,)
  
  # m-comment #

  adverb(please, comment, adv-7,)
  adverb(kindly, comment, adv-7,)
  adverb(actually, comment, adv-all,)
  adverb(really, comment, adv-3,) 
  adverb(also, comment, adv-all,) _adverb(also, too, comment, adv-2,)

  ## !! Multi-word I know, you know, I guess  

  # m-relational #
 
   adverb+(dep-clause, if, condition, adv-1,)
   adverb+(dep-clause, because, cause, adv-1,)
   adverb+(dep-clause, so, result, adv-1,)
      

#######################
## DISCOURSE MARKERS ##
#######################


  dis-marker(right, marker)
  dis-marker(yes, marker)
  dis-marker(ok, marker) _dis-marker(ok, okay, marker)
  dis-marker(No, marker)
  dis-marker(sure, marker)
  dis-marker(alright, marker)
  dis-marker(alrighty, marker)
  dis-marker(okidokey, marker)
  dis-marker(okido, marker)
  dis-marker(well, marker)
  dis-marker(huh, marker)
  dis-marker(um, marker)
  dis-marker(but, marker)
  dis-marker(and, marker)

  dis-marker(good, marker)
  dis-marker( "," , marker)
  dis-marker( sorry , marker)
  dis-marker( hi , greeting)  dis-marker+np( hi , greeting)
  dis-marker( hello , greeting)  dis-marker+np( hello , greeting)
  dis-marker( bye , closing)  dis-marker+np( bye , closing)
  dis-marker( ciao , closing)  dis-marker+np( ciao , closing)
  dis-marker( good_bye , closing)  dis-marker+np( good_bye , closing)
  dis-marker( so_long , closing)  dis-marker+np( so_long , closing)
  

###################
## MOD-MODIFIERS ##
###################

  modifier(really, adj, pre, intensity )
  modifier(really, adv, pre, intensity )
  modifier(too, adj, pre, intensity )
  modifier(too, adv, pre, intensity )
  modifier(very, adj, pre, intensity )
  modifier(very, adv, pre, intensity )

  modifier(much, adj-comparative, pre, intensity)

  modifier(over, prep, pre, direction )
  modifier(away, prep, pre, direction )
  modifier(up, prep, pre, direction )
  modifier(down, prep, pre, direction )
  modifier(straight, prep, pre, direction )
  
  modifier(right, prep, pre, manner )
  modifier(up, prep, pre, manner )






# NOTE: In some of the cases below, the 'expected' number of parses will be incorrect
#       This is because as new features get added, old ones removed, these numbers fluxuate
#       this is especially true with various 'discourse phenomena' and 'complex constructions'

testbed {

  # And now on to the show....

  ####################################
  # The 3 moods & INCREMENTAL PARSES #
  ####################################

  # Indicative #

  # Indicative mood is no longer attributed to an utterance by its verb.
  # Instead, it is handled by type-changing rule which, essentially, adds
  # some semantics to your standard np type-raising rule.
  # Any 'floating' np can become the <Subject> of an indicative clause waiting for its verb+args (vp)

  # Motivation: 1) early projection. When we 'see' an NP in first position in the clause we know it is
  # either the 'Subject' of indicative, or it is a fronted object, or pre-np. See end of this for 
  # these cases. Thus, there is no reason to 'wait' for the verb to explicitly represent this info
  #             2) semantic integration. By placing the subject in a semantic slot, we now can avoid
  # multiple un-integrated semantic fragments in simple sentences. Specifically 'I really' now recieves
  # an integrated reading, which 'knows' it is part of a yet unspecified event.
  #

  # An example 

  the: 6 ;                                            # free-np, subj-np of ind-clause, fronted-np of ind-clause, etc      x 2 for 2 readings of the
  the pizza: 3 ;                                      # lose the plural readings of the
  the pizza on: 3;                                    # "
  the pizza on the: 6;                                # 2 readings of the
  the pizza on the big: 6;                            # "
  the pizza on the big red: 6;                        # "
  the pizza on the big red table: 3;                  # lose the plural reading of the
  the pizza on the big red table makes : 4;           # 4 readings of make ( make dinner, make me run, make me hungry (this one has 2 readings see verbs.ccg) ) 
  the pizza on the big red table makes me : 3;        # "
  the pizza on the big red table makes me hungry: 1;  # 
  
  
  # Interrogatives #
  
  # Wh-questions are controlled by their Wh-word, i.e. the first word projects the structure of the clause.
  # Moreover, to allow fully integrated incrental parsing, they 'select for' (i.e. have syn and/or sem slots for)
  # the auxillary (which then fills in tense, aspect, verbal-agreemnt, polarity, etc), the 'Subject' and then
  # the 'verb missing an arg' 
	
  # Note: Currently, only arguments, not modifiers, can be wh questioned. We can't handle 'extracted optional elements'
  #       Of course, you can question pp args, like 'who did you walk with', b/c once they 'attach' to the verb, their
  #       argument is treated as any old missing arg.
  #       As a hack to handle where questions for motion verbs, I added to each a verbal family with an explicit <Dynamic>
  #       argument. So you can now ask  Where are you going?  BUT NOT where are you playing?
  		  
  # An example (note increase of readings in 4 -> 5)
    
  what: 4;                              # aux-obj, aux-sent-comp, subj, copular-obj
  what did: 4;                          # aux-obj, aux-sent-comp, subj (with did as aux), subj (with did as proverb, e.g. What did it )
  what did GJ: 2;                       # aux-obj, aux-sent-comp
  what did GJ see: 1;                   # aux-obj (transitive reading of see)  
  what did GJ see under: 2;                # aux-obj (transitive reading of see), prep-arg (intranstive reading of see)  
  what did GJ see under the: 2;         # aux-obj (transitive reading of see) with 2 readings of the
  what did GJ see under the table: 1;   # aux-obj (transitive reading of see)

  # Y-N Questions

  # Here, the aux, as first element, controls the mood.
  # Much like Wh-words, it selects for subject & then vp.
  
  are: 32;            # yeah... it's the be-verb and this english, whaddya expect
  are you: 22;        # still loads of possibilities
  are you coming: 4;  # sg/pl for you, with/out dynamic (see above)
 
  # Imperatives (and alighted Subjects) 

  # as the verb is the first element in an imperative clause, it controls the clause.
  # this should be done as it was in moloko, i.e. with a separate verbal category and hence lexical family for each verb.
  # HOWEVER, b-c it would lead to sheer messiness under Dot-CCG, I've added type-changing rules for this...sigh....
    
  # Also, by building verbs like this s\np /args instead of s /args \np  we will necessarily get all of the 'missing subject'
  # readings. I did, however, shut off the subject slot (via !), so we don't see them in other places.
  # A simple way to prune these silly readings is to check the mood. If it is un-specified, prune it. All readings that we 
  # want will have a mood specified somehow (via rule, or via lexical items)
  # For this reason, I added an 'alighted subject' reading as well. (see verbs.ccg for arguments for this.. can still of course remove)
	
  # NOTE: what should we 'call' the alighted subj & imperative actor (currently have em as context, see context entities below)
  #       what about the tense of imperatives? obviously its a silly question, and answering it gets into silly philosophical discussions.
  #       I left it out, is that ok?	
	
  go: 4;                        # imp-parse, 3 moodless parses (base, pl, 2nd-singular, see above)
  go over: 30;                  # ummmmm... as it stands, with so many independent dep reln names being used for modifers (location, dynamic, etc) 
                                # mod-modifiers like over lead to an explosin in readings 
  go over to: 5;                # lose all but <dynamic>, get 1 imp and 4 moodless...
  go over to your: 10;          # x2 b/c of sg-pl versions of your
  go over to your station: 10;  # "

   
  #########################################
  # Participant Roles/Argument Structures #
  #########################################
  
  I slept: 1;                   # iv
  
  I want it: 4;                 # tv

  give me the ball: 4;          # dtv
  give the ball to GJ: 4;     

  I picked it up: 1;  # object + particle 
  I picked up the ball: 1;
 
  I want it bigger: 1;          # resultant 'state'
  make it black: 4;

  I want it on the table: 2;    # 'goal'  (second reading is a post-np, see below)
  put it on the table:    4;  

  I want to sleep: 1;              # event compliment (subj controlled inf)
  I want the robot to sleep: 2;    #                  (obj controlled inf)
  I made it move off the table: 1; # base
  keep moving: 16;                 # ing  (1 of these many parses is the simple s imperative                  
  stop moving: 16;
  I said I wanted to sleep: 1;     # s
   	    	   
  # Special
  
  # 'use X to do Y' Subj controlled inf-verb with patient as instrument

  # Note: These kinds of specialized arg structures are actually quite easy to add
  #       So if anyone think of anymore similar ones they'd like to add... 
  
  you use it to make coffee: 6;                  # open readings for make
  you can use them to pick things up: 2; 


  #############
  # Modifiers #
  #############
 
  ## Modifiers themselves ## 
 
  # Modifiers begin as atomic cats with a semantic index of their own
  # via type-changing rules, the can be 'transformed' into complex cats for use in modifying
  #     the combinatorial possibilities are lexically specified via CC-TYPE (complex-cat type)
  #     see types-features.ccg   
      
  on the table: 8; # Prep-it can modify an entity as <Location>, or event as <Location> or <Dynamic> in multiple syntactic positions  
  big: 2;          # Adj-it can only modify entities as <Property>
  
   
  ## Modifying Modifiers ##
  
  # because modifiers always begin as atomic cats, 'before' they are transformed they can be modified
  # thse mod-modifiers latch onto the atomic cat's index.
  
  over on the table: 8;   
  really big: 2;


  ## Using the Modifiers ##

  # As modifiers (the rule-generated complex cat is used) #

  the ball: 3;
  the ball on the table: 3;
  the ball over on the table: 3;
  
  the big ball: 3;
  the really big ball: 3; 
   	 
  I slept: 1; 
  I slept on the table: 1;
  I slept over on the table: 1;
      
  # As compliments to verbs (the original atomic cat form used) #
  
  the ball is big: 1;
  the ball is really big: 1;

  I want it big: 1;
  I want it really big: 1;
	    
  the ball is on the table: 1;
  the ball is over on the table: 1;
		
  I want it on the table: 1;
  I want it over on the table: 1;

  ## Blocking Modifiers ##

  ## Each verb has the right to choose its own 'potential modifiers', i.e., semantically restrict what kinds 
  ## of things it can take. See the m-class in types-features.ccg for list of restriction classes.
  
  # Although Nouns, nor Modifiers are doing this right now, could in theory be implemented quite naturally.
  
  I am happy to the the table: 0;  # copulars can't take dynamics
  I want it to the table: 0;       # neither can 'want' like modal/cog verbs
  I went to the table: 1;          # motion verbs can
  
  I want it on the table: 1;       # this is a <goal> participant of want, but still blocks dynamic on.
  I walked on the table: 3;           # currently motion verbs like this accept <location> (static) and <dynamic> readings
  								   # Note: 3rd reading is due to hack handling of where questions..... 
		
			   
    ## NOTE: A Suggestion ##
  
  # As it stands, we are using quite a few different dependency relations for 'optional modifiers'
  #   ex. <Dynamic>  <Location>  <Time>  <Property> as well as the more general <Modifer>

  # Instead, I suggest a single dependency relation (call it whatever you want to, <Modifer> is as good as any)
  # which is used for each and every semantic relation. 
  # The nature of the relation is specified by the ontological sort of the relation only.
  #      so <Modifier>(m:color green)  <Modifier>(m:location on ...) <Modifier>(m:where-to onto <Arg> ...)
  # The hierarchical information, i.e. that where-to is a dynamic, that color is a physical-property which is a property
  # will be handled exclusively in the ontological sort hierarchy. Hence, external use will need to look this up
  # instead of merely checking the dep-reln name.
  #
  # In the case of these same 'modifiers' playing sem-roles in arg structure, then we would need either one or more
  # different names (like <Goal> or whatever) to handle these. This has the added benefit of allowing post-processing
  # to know whether a locational was selected for and hence playing a core role, or was merely a 'modifier'
  #     e.x.
  # 'I want it on the table'  should not be interpreted as a want event located on the table, but instead like 'put' with a 
  #  'goal' type locational argument.
  #
   
  # Here are some reasons for why I think the single modifer dep-reln is a good idea:
  
  # 1) Uniformity:
  #       -we are already using the type hierarchy to handle the vast majority of different kinds
  #        of dep-relns, e.g. instrument, accompaniment, comment, etc
  #       -this would allow me to clean up some of the grammar by removing multiple 'checks'
  #	       i.e. if you are a location modifier, then become <Location>, if dynamic.....
  #              else <Modifier>		
  #       -modification of the dependency-relation hierarchy would have much less impact on the grammar
  #        as it stands, if we decide to add 'instrument' as dep-reln (instead of say sub-type of modifier)
  #        this would require going in and building a family. If we unify, just have to add to sort-hierarchy
  #        and then to the new dictionary items.
  #
  # 2) Information Redundancy:
  #       As it stands, we have readings like this <Location>(m:location on ...) & <Time>(m:time before ...) 
  #       And as mentioned above, even in cases like <Dynamic>(m:where-to onto...) the sub-type info provided
  #       here is already available in the sort-hierarchy
  #
  # 3) Parse reduction:
  #       We currently get crap loads of readings for 'pre-modifier modifiers' like 'over on the table' or 'really'
  #       The reason, is that as 'over' doesn't know if it is modifying a dynamic, a location, or whatever, then
  #       it gets a reading for each possibility. Even if we eventually 'restrict' these modifiers to only modify 
  #       the correct kinds, we'll still get one reading for each of these dependency-reln 'ambiguities'.
  #       Compare this to if we had a different 'category' for animates and inanimates, then big would be ambiguous
  #       to these two readings and have to generate both readings
  # 
  # 4) Simplification of the Copular
  #       By returning to a uniform treatment of 'things which modify nouns', I could then revert to the much
  #       cleaner copular which takes adj and pps instead of the complex ugliness we had in older moloko
  #       This would mean much easier uniform handling of questions, among other things.
  #             (note: I actually have this simpler version of copulars implemented, but could change back
  #                    to the more complex version from old moloko)
  # 
  
					   
						   	   
  ###############
  # The Copular #
  ###############

  # Adj 
  it is big: 1;
  it "isn't" big: 1;
  is it big: 1;
  what is big: 1;
  how is it: 2;    # 2nd reading with is as aux-verb

  # With NP
  it is a ball: 1;
  is it a ball: 1;
  what is a ball: 4; # question subj, obj & two other readings with is as aux-verb 
  what is it:     4;   
 
  # with PP
  it is under the table: 1;
  is it under the table: 1;
  where is it: 4; 

  # verbal-adjectives
  
  I am able to walk:    2;
  am I able to walk:    2;

  # inverted locational
  under the table is a ball: 4;  # 1 inverted locational, 3 y-n with fronted locataional , e.g. under the table is there a cat?

  # presentationals
  
  there is a ball: 2; # normal and inverted locational
  there were some balls: 2;
  there are a ball: 0;
  there is a ball on the table: 2;
  is there a ball: 1;  
  is there a ball on the table: 2;
  what is there: 1;
  where is there a ball: 1;
  
  # note that dummy subj doesn't overgenerate
  there walked in: 0;
  there is big: 0;


   


  
  #######################################################
  # Entities: Context Entities, Determiners and Groups  #
  #######################################################
							   		    	  
  # Context Entities #
  
  # I have modified and extended the old Moloko treatment of context nps. Before, we were
  # handling them in two ways:
  # 1) by attaching a dependency relation containing the entities semantic features
  # with some sort of outside 'Shell' 
  #   e.g.    one      @entity(one <Context> (<num, spec, delim>) )
  # 2) with a ontological type of 'discourse-deictic'
  #   e.g.    this     @discourse-deictic(this <proximity, spec, det, num> )
  #
  # I have unified these two types of contextual entities together with a few others (more below)
  # and given them a simpler and more info-rich representation. First, some issues with these
  # two old treatments
  
  # First, 1) was quite difficult to pull off, in the sense, it required gerry-rigging a lot 
  # of extra categories, and as I wanted to expand the idea of contextual entities, it was a pain
  # As well, when these shell nps were modifed 'big one', the 'semantic head' was the outside entity
  # and hence the modifying information was separate from the lexically specified features.
  # Second, 2) has the problem of loosing the ontological info that it is an entity. Furthermore, if
  # we eventually want more semantically refined types of context nps, then this info wouldn't
  # be visible (see also Context Events below)

  # New represenation:  A context entity is exactly like any other entity except its propisition is 
  # the word context. i.e. all of its 'grounding features' (num, spec, prox, etc) are there, along
  # with any modifiers, the only thing that needs to be contextually found is the 'head', or the info
  # that would be given in the 'nominal class'.
  
  # So....  this (as deictic entity)
  #         @entity(context <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  # what is nice is that now it has exactly the same semantics as 'determiner' this, except 'head' is filled in by context
  # i.e. compare with
  #			this       np/n
  #         @entity(     <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)       
  #         this ball  np
  #         @entity(ball <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  # and further, this as 'event deictic' only differs in its ontological sort.
  #         @event(context <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  #
  
  # Besides context being used in deictics, it is also used with
  #   1)'discourse one' 
  #   2) numbers (both cardinal and ordinal) 
  #   3) in some Wh-questions (see below)
  #
  #  NOTE: We could extend this to cover other things like some adjectives ('colors' I want the green, etc)
 
  # GROUPS #
    
  # In addition, I have added the handling of 'subgroups' of specified groups.
  #  e.x. one of the balls,   some of GJ's money,   the first of the three balls.
  # 
  # The basic semantics is:    @entity(group
  #                                    'subset specifying info'									
  #                                    <Set>(info specifying the set)
  #
  # subset specifying info is handled by the 'pre-of' stuff (one, some, first, etc)
  # and the set info, by the 'post-of' stuff.
  # So in the cases, like some, where there is no propositional info attached, then only features 
  # at top level. In other case, like numbers, it is contained in a <Modifier>() at this level.  
		
  this: 11;  # 'this' can be det, context-np, context-event from above. Multiply for each slot
  this ball: 5;
  the this ball: 0;
  this of the balls: 0;
  
  some: 20;  # 'some' can be det (sg, pl), context-np(pl), and set-selector(pl)
  some balls: 9;
  the some balls: 0;
  some of the balls: 9;

  two: 22;  #  cardinals can be a det, context-np, context-n set-selector and simple modifier
  two balls: 19;
  the two balls: 9;
  two of the balls: 5;
  those two: 26;

  the third: 20;  # ordinals can be context-n, set-selector, and simple modifier
  the third ball: 5; 
  the third of the three balls: 9; 
  third ball is big:0 ;  # but they can't be dets
  
  the green ones: 5; # ones is a generic plural context-n
 	  
  # Left to do: What about nothing, none, etc... how should we handle these?	  

  ##################
  # Context Events #
  ##################
    
  I "didn't" say that: 6;   # 1 of these readings is an s, the rest are treating 'that' as 
                            # the subj/front np (or its det) of the sent comp
 
  who said it:  3;        # similar, but no det readings
  what did he say: 1;

  # pro-verb do #
  
  # NOTE: what should the prop be for this?  
  
  I "didn't" do it: 1;
  I do I went: 0;                # the event compliment to accept context-events, so         
  who did this: 1;
  what is he doing: 1; 
  what is he doing with the ball: 1; 

  # Subj+Aux with context main events.
  
  I will: 2;
  I do : 2;
  I can not: 2;
  will I: 2;
  "won't" I: 2;
  can I: 1;
  
  # contextualized inf comps
  
  I want to:  2;
  I want him to: 2;
  I hope to: 2;
  do you want me to: 2;
  
  ###############################
  # Context Locations and Anchors #
  ###############################

   I walked there: 1;  # full pro-pp location
   I was here: 1;
   I put it in there: 1 ; # anchor only
   I picked up there: 0;    # here/there don't overgenerate (uses CASE = acc-loc)
   
  
   
  ################
  # WH-QUESTIONS # 
  ################

  ## Questioning a complement (i.e. extracted argument) ##

  # In some of these cases, context entities are used.
  # For example, how much do you want. This is questioning the amount of a contextually defined
  # entity playing the patient role in want.
  
  what should I pick up: 1;
  
  which ball should I pick up: 1;
  what color ball should I pick up: 1;  
  which color should I pick up: 1;
  
  how is it: 2;
  how do you want it: 2;
  
  what color is it: 8;            # gotta look at this. Getting too many readings (both restr & scope (i.e. subj & obj) readings.)
  what size should I make it: 1; 

  how big is it: 2;
  how big should I make it: 1; 
  how much bigger should I make it: 1; 
  how hungry do you want me to be: 1; 
  
  how_much coffee should I make for him: 1;
  how_much should I make for him: 1;	   
  how_many balls do you want me to pick up: 2;  # 2 readings you
  
  how_many coffee do you want: 0;
  how_much balls do you want: 0;

  ## Questioning a Modifier (i.e. no extracted argument) ##  

  # These questions are handled semantically, i.e. the wh-word defines its own modifer type
  # and this is then used to restrict it's scoped event by checking that it has a compatible 
  # m-class
  
  where is he sleeping: 1;    # loc only
  where is he going: 2;       # static & dynamic
  where does he want it: 3;   # 1 the compliment reading, 2 scoping over Event comp since want can't take loc or dyn modifiers	  
  where does he want it to sleep: 1;
  
  how does he sleep: 1;       # manner reading 
  how did he make it: 2;      # manner reading + result-comp reading 
  
  ######################################
  # Tense, Aspect, Modality & Polarity #
  ######################################
 
  
  he sleeps: 1;
  he does sleep: 1;
  he "didn't" sleep: 1;  
  does he sleep: 1;

  he slept: 1;
  he did sleep: 1;
  he "didn't" sleep: 1;
  did he sleep: 1;

  he will sleep: 1;
  he "won't" sleep: 1;
  will he sleep: 1;

  he is sleeping: 1;
  he "isn't" sleeping: 1;
  is he sleeping: 1;

  he has slept: 1;
  he "hasn't" slept: 1;
  has he slept: 1;
 
  he can sleep: 1;
  he "can't" sleep: 1;
  can he sleep: 1;

  he is able to sleep: 1;
  he "isn't" able to sleep: 1;
  is he able to sleep: 1;  

  # Combinations

  he will have slept: 1;
  will he be sleeping: 1;
  
  he will be sleeping: 1;
  will he  be sleeping: 1;
  
  he has been sleeping: 1;
  has he been sleeping: 1;

  he "can't" have slept: 1;
  he "can't" be sleeping:  1;

  # Correctly Rejected #

  I will can sleep: 0;
  will he sleeps:  0;
  he will sleeps:  0;
  I am sleep:       0;
  I have sleep:   0;
   
      
  #########
  # Voice #
  #########
   
  # Currently no 'get form' (will require combining with aux 'do' for neg & questions)
  # Currently can't handle wh-questions
    
  he "wasn't" seen: 3;
  he "wasn't" seen by GJ: 6;    # 3 by Actor readings, 3 locational readings
  
  was he seen by anyone: 4; 
   
  ##################################
  # Fronted NPs, Pre-NPs, Post-NPs #
  ##################################
  
  
  # THIS WILL ALL BE REPLACE via discourse-units

  # Though certainly not the most important, or interesting feature of the new grammar
  # I figured I should put it first. When you start looking at parses, you'll no doubt 
  # be wondering 'What is all this crap?'

  # Right.
  # People like to place NPs outside clauses, both before and after. 

  # Reasons? task separation (i.e. separating finding/building description of the referent from predicating it), 
  #          info struc, mark logical relations (comparison, listing, etc) 
  #          various interpersonal functions, discourse segmentation, 'repairing' reference etc.
  #
  # Of course all of these tasks are 'extra sentential' and mostly interactive (e.g. only add a 2nd description if
  # they don't seem to get it after the first) but until we handle em in dialogue model, can have it here.
  # clearly will involve some 'post processing' as they do not sub-categorize for these functions, nor does it 
  # make any co-indexing proposals, i.e., treated as separate, i.e. as 'discourse anaphor'(ugh)
    
  # In any case, if you want to shut them off, go to discourse.ccg and comment out the lines.
  
  # there is often some sort of intonational break between clause and np, but not always, and
  # its not like speech rec is going to give us that info anyway...
  
#  the ball I picked it up: 1;
#  the ball I picked up: 2;
#  put it on the table the big ball: 1;
#  the big ball pick it up: 1;
#  who is he that guy there: 1;
    
  # Also, of course, as Vocatives
#  Robot I want you to go away: 2;
#  I want you to go away Robot: 2;
	

        
}
	
rule { typechange: np[D]  =>  du[D]  :  ; } 

rule { typechange: n[D]  =>  du[D] :  ; } 

rule { typechange: adj[D]  =>  du[D]  :  ; } 

rule { typechange: adv[D]  =>  du[D]  :  ; } 

rule { typechange: s[D]  =>  du[D]  :  ; } 

rule { typechange: pp[D]  =>  du[D]  :  ; } 

rule { typechange: s[A] => du[B]/^du[C] : B:d-units ( <First>(A) ^ <Next>(C) ) ; }  
