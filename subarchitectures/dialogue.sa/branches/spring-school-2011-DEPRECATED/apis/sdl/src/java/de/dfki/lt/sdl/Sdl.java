package de.dfki.lt.sdl;

import java.io.*;
import java.util.*;

/**
 * the purpose of this class is merely to  perform a compilation of a system
 * description into a Java class definition;
 *
 * a system descriptions must meet the following EBNF:
 *   <system>       ::= <definition>
 *                      [ <mediator> ]
 *                      [ <threaded> ]
 *                      [ <debug> ]
 *                      <variables>
 *   <definition>   ::= <modulename> "=" <regexpr> <newline>
 *   <modulename>   ::= a fully qualified Java class name
 *   <regexpr>      ::= <var> |
 *                      "(" <regexpr> ")" |
 *                      <regexpr> <regexpr> |
 *                      "(" "|" { <regexpr> }^+ ")" |
 *                      "(" "*" <regexpr> ")"
 *   <newline>      ::= the newline character
 *   <mediator>     ::= "Mediator" "=" <mediatorname>
 *   <mediatorname> ::= a fully qualified Java class name
 *   <threaded>     ::= "Threaded" "=" { "yes" | "no"}
 *   <debug>        ::= "Debug" "=" { "yes" | "no"}
 *   <variables>    ::= { <vareq> <newline> }^+
 *   <vareq>        ::= <var> "=" <modulename> [ <initexpr> ]
 *   <var>          ::= a symbol, consisting of only lowercase letters
 *   <initexpr>     ::= "(" { <string> }^+ ")"
 *   <string>       ::= a Java string
 *
 * @see IMediator
 * @see Mediators
 * @see IModule
 * @see Modules
 *
 * @author (C) Hans-Ulrich Krieger
 * @since JDK 1.4
 * @version 1.4.1, Mon May 10 17:13:56 CEST 2004
 *
 * IMPROVEMENTS:
 *   let local classes also inherit from Modules, so that the repetition of the code
 *   of the methods from IModule can be avoided;
 *   put declaration of _operator and _modules also in the constructor for Modules;
 *   let local constructors call super();
 *   also intorduce _operator and _modules in the new top-level class!
 */
public class Sdl {

  /**
   * the default mediator class, located in this package de.dfki.lt.sdl
   */
  public static final String defaultMediator = "Mediators";

  /**
   * the name of the input file which contains the system description
   */
  private static String sysDescrFile;

  /**
   * the name of the system
   */
  private static String systemName;

  /**
   * the package name derived from the system name
   */
  private static String packageName;

  /**
   * the name of the Java class that will be generated by calling compile()
   */
  private static String className;

  /**
   * a File object, representing the absolute path of the directory, followed
   * by the Java class name, followed by the extension "java"
   */
  private static File systemFile;

  /**
   * the original regular expression, specifying the system
   */
  private static String regExpr;

  /**
   * specifies an optional fully qualified Java class
   */
  private static String mediatorName;

  /**
   * specifies whether modules are executed parallel or sequentiell under '|';
   * default value is "no"
   */
  private static String threadedValue;

  /**
   * specifies whether some useful debug information is printed out during the
   * processing of the compiled module, originating from the system description
   * default value is "no"
   */
  private static String debugValue;

  /**
   * a mapping from a variable name (a string) to a Java class name (a string)
   */
  private static Hashtable varToClassName = new Hashtable();

  /**
   * a mapping from a variable name (a string) to the init arguments (a String
   * array) of the instance to which the variable refers to
   */
  private static Hashtable varToInitArgs = new Hashtable();

  /**
   * a mapping from a newly introduced (local) variable to a simple regular
   * expression of the following form:
   *   (v1 + ... + vN) or (| v1 ... vn) or (* v1)
   */
  private static Hashtable localVarToExpr = new Hashtable();

  /**
   * an integer, employed during the generation of local variables
   */
  private static int index;

  /**
   * the number of opening parantheses during the normalization of the regular
   * system description
   */
  private static int noOfPars;

  /**
   * set Sdl.verbose = true for test purposes
   */
  public static boolean verbose = false;

  /**
   * given a new system description stored in file sysDescrFile, compile() generates
   * a new Java class definition whose location is specified in the file;
   * note that since this is a class method and relies on static fields, I make it
   * a synchronized method!!
   */
  public static synchronized void compile(String sysDescrFile) {
    // some initialization
    Sdl.sysDescrFile = sysDescrFile;
    Sdl.systemName = null;
    Sdl.packageName = null;
    Sdl.className = null;
    Sdl.systemFile = null;
    Sdl.regExpr = null;
    Sdl.mediatorName = null;
    Sdl.threadedValue = "no";
    Sdl.debugValue = "no";
    Sdl.varToClassName.clear();
    Sdl.varToInitArgs.clear();
    Sdl.localVarToExpr.clear();
    Sdl.index = 0;
    Sdl.noOfPars = 0;
    // open the file
     try {
       BufferedReader br = new BufferedReader(new FileReader(sysDescrFile));
       // a valid system description must at least consist of two lines:
       // (1) the system description ...
       String regExpr = Sdl.readSystem(br.readLine());
       // check whether the next lines specify optional commands or whether
       // they are the begin of the variable section
       Sdl.readCommands(br);
       String line;
       while ((line = br.readLine()) != null)
	 // the variable descriptions
	 Sdl.readVariables(line);
       // generate the Java code
       Sdl.generateClass(regExpr);
     }
     catch (IOException e) {
       System.err.println("Error when reading system description from file " + sysDescrFile);
       System.exit(1);
     }
  }

  /**
   * a command is indicated by the following keywords:
   *   o Mediator
   *   o Threaded
   */
  private static boolean isCommand(String line) {
    return ((line.startsWith("Mediator")) ||
	    (line.startsWith("Threaded")) ||
            (line.startsWith("Threaded")));
  }  

  /**
   * reads in and interprets command lines; at the moment, the following commands
   * are implemented:
   *   (1) specify mediator by saying  "Mediator = <a fully qualified Java class name>"
   *   (2) for executing modules parallel/sequentiell under '|', say  "Threaded = yes/no"
   *   (3) to print out debug information, use  "Debug = yes/no"
   */
  private static void readCommands(BufferedReader br) throws IOException {
    int equalPos;
    String line = br.readLine().trim();
    if (line == null || line == "") {
      System.err.println("A system description must consist of at least two lines; exiting ...");
      System.exit(1);
    }
    while (Sdl.isCommand(line)) {
      if (line.startsWith("Mediator")) {
	equalPos = line.indexOf("=");
	line = line.substring(equalPos + 1).trim();
	if (Sdl.verbose)
	  System.out.println("Mediator = \"" + line + "\"");
	Sdl.mediatorName = line;
      }
      else if (line.startsWith("Debug")) {
	equalPos = line.indexOf("=");
	line = line.substring(equalPos + 1).trim();
	if (Sdl.verbose)
	  System.out.println("Debug = \"" + line + "\"");
	Sdl.debugValue = line;
      }
      // line must be "Threaded ..." due to isCommand();
      // do NOT check whether value is proper
      else {
	equalPos = line.indexOf("=");
	line = line.substring(equalPos + 1).trim().toLowerCase();
	if (Sdl.verbose)
	  System.out.println("Threaded = \"" + line + "\"");
	Sdl.threadedValue = line;
      }
      line = br.readLine().trim();
      if (line == null || line == "") {
	System.err.println("Wrongly specified system description; exiting ...");
	System.exit(1);
      }
    }
    // first variable declaration
    Sdl.readVariables(line);
  }

  /**
   * checks whether a proposed system name is a fully qualified Java class name
   */
  private static void analyzeSystemName(String systemName) {
    int lastFullStop = systemName.lastIndexOf(".");
    if (lastFullStop == -1) {
      // system belongs to the unnamed package
      Sdl.packageName = "";
      Sdl.className = systemName;
    }
    else {
      Sdl.packageName = systemName.substring(0, lastFullStop);
      Sdl.className = systemName.substring(lastFullStop + 1);
    }
    // generate a proper File object ...
    if (Sdl.packageName.equals("")) {
      Sdl.systemFile = new File("");
      Sdl.systemFile = Sdl.systemFile.getAbsoluteFile();
    }
    else {
      Sdl.systemFile = new File(Sdl.packageName.replace('.', File.separatorChar));
      Sdl.systemFile = Sdl.systemFile.getAbsoluteFile();
      // ... and look whether we have a proper directory structure
      if (!Sdl.systemFile.isDirectory()) {
	System.err.println("Not a legal directory path: " + Sdl.systemFile.getAbsolutePath());
	System.exit(1);
      }
    }
    // finally check whether this file already exists ...
    Sdl.systemFile = new File(Sdl.systemFile, Sdl.className.concat(".java"));
    if (Sdl.systemFile.isFile()) {
      try {
	System.err.println("\nFile " + Sdl.systemFile.getAbsolutePath() + " already exists;");
	System.err.println("Type \'c\' and <Return> to continue or any other character to abort!");
	InputStreamReader reader = new InputStreamReader(System.in);
	char ch = (char)(reader.read());
	if ((ch == 'c') || (ch == 'C')) {
	  System.err.println("continuing ...");
	}
	else {
	  System.err.println("compilation of system " + Sdl.systemName + " aborted");
	  System.exit(1);
	}
      }
      catch (IOException e) {
	System.err.println("Error when reading from console");
	System.exit(1);
      }
    }
    // ... and memorize the system name
    Sdl.systemName = systemName;
  }

  /**
   * checks whether the proposed variable starts with a lowercase letter
   */
  private static boolean startsWithLowerCase(String varName) {
    return Character.isLowerCase(varName.charAt(0));
  }

  /**
   * a legal token is either a variable or one of the following characters:
   *   '(', ')', '+', '|', '*'
   */
  private static boolean isLegalToken(String token) {
    return (Sdl.startsWithLowerCase(token) ||
	    token.equals("(") ||
	    token.equals(")") ||
	    token.equals("+") ||
	    token.equals("|") ||
	    token.equals("*"));
  }

  /**
   * readSystem() separates the system name from the right-hand side regular expression;
   * the regular expression is further normalized and returned
   */
  private static String readSystem(String description) {
    int posOfEquals = description.indexOf("=");
    if (posOfEquals == -1) {
      System.err.println("No equals sign found in system description: " + description);
      System.exit(1);
    }
    // identify system name, perform consistency checking, etc.
    Sdl.analyzeSystemName(description.substring(0, posOfEquals).trim());
    // normalize system description
    Sdl.regExpr = description.substring(posOfEquals + 1).trim();
    boolean space = true;
    StringBuffer sb = new StringBuffer();
    StringTokenizer st = new StringTokenizer(Sdl.regExpr, " ()+|*", true);
    String token;
    while (st.hasMoreTokens()) {
      token = st.nextToken();
      if (token.equals(" ")) {
	// spaces
	if (!space) {
	  sb.append(" ");
	  space = true;
	}
      }
      // all other tokens
      else {
	if (Sdl.isLegalToken(token)) {
	  // prefix variables with '$'
	  if (Sdl.startsWithLowerCase(token))
	    token = "$" + token;
	}
	else {
	  // not a legal token
	  System.err.println("Not a legal variable name: " + token);
	  System.exit(1);
	}
	if (space) {
	  sb.append(token);
	  space = false;
	}
	else {
	  sb.append(" ");
	  sb.append(token);
	}
      }
    }
    return sb.toString();
  }

  /**
   * separates the variable name from the associated Java class name;
   * this association is stored in a global hash table;
   * if further init args are specified, an additional association is
   * established and a String array for the init args is constructed;
   * in case no init args are specified, an empty String array is created
   * anyway to guarantee that init() causes no harm!!
   */
  private static void readVariables(String description) {
    int posOfEquals = description.indexOf("=");
    if (posOfEquals == -1) {
      System.err.println("No equals sign found in variable description: " + description);
      System.exit(1);
    }
    // identify variable name
    String varName = description.substring(0, posOfEquals).trim();
    if (!Sdl.startsWithLowerCase(varName)) {
      System.err.println("Not a legal variable name: " + varName);
      System.exit(1);
    }
    // prefix variable with '$'
    varName = "$" + varName;
    String rhs = description.substring(posOfEquals + 1).trim();
    int posOfOpenPar = rhs.indexOf("(");
    if (posOfOpenPar == -1) {
      // rhs is the class name
      Sdl.varToClassName.put(varName, rhs);
      // no init args specified: generate an empty String array in case that
      // init is called although no init args are specified
      Sdl.varToInitArgs.put(varName, new String[0]);
    }
    else {
      String className = rhs.substring(0, posOfOpenPar).trim();
      Sdl.varToClassName.put(varName, className);
      int posOfClosePar = rhs.indexOf(")");
      String initString = rhs.substring(posOfOpenPar + 1, posOfClosePar).trim();
      String[] initArgs = initString.split("\"");
      // splitting introduces unnecessary strings due to the spaces and the comma
      // between init arguments: use whole number division, i.e., remainder is lost
      String[] properTokens = new String[initArgs.length / 2];
      for (int i = 1; i < initArgs.length; ) {
	properTokens[i / 2] = initArgs[i];
	i = i + 2;
      }
      Sdl.varToInitArgs.put(varName, properTokens);
    }
  }

  /**
   * given a parsed system description, consisting of Sdl.className, Sdl.packageName,
   * Sdl.systemFile, Sdl.varToClassName, Sdl.varToInitArgs, and regExpr,  generateClass()
   * generates Java code which realizes the new complex system behavior
   */
  private static void generateClass(String regExpr) {
    try {
    // open output file
    PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(Sdl.systemFile)));
    Sdl.generateHeader(out);
    Sdl.generateCode(out, regExpr);
    out.flush();
    out.close();
    }
    catch (IOException e) {
      System.err.println("Error when opening file " + Sdl.systemFile.getAbsolutePath());
      System.exit(1);
    }
  }

  /**
   * checks whether className represents an already existing class;
   * if not, outputs a warning and asks for continuation
   */
  private static void lookUpClass(String className) {
    // complete class name and transform it to the platform-dependent filename;
    // Unix/Linux: '.' --> '/'
    if (Sdl.isFromUnnamedPackage(className))
      className = Sdl.packageName + "." + className;
    className = className.replace('.', File.separatorChar);
    className = className + ".java";
    File file = new File(className);
    file = file.getAbsoluteFile();
    if(!file.isFile()) {
      try {
	System.err.println("\nFile " + className + " does not exist;");
	System.err.println("Type \'c\' and <Return> to continue or any other character to abort!");
	InputStreamReader reader = new InputStreamReader(System.in);
	char[] input = new char[1];
	reader.read(input);
	if ((input[0] == 'c') || (input[0] == 'C')) {
	  System.err.println("continuing ...");
	}
	else {
	  System.err.println("compilation of system " + Sdl.systemName + " aborted");
	  System.exit(1);
	}
      }
      catch (IOException e) {
	System.err.println("Error when reading from console");
	System.exit(1);
      }
    }
  }

  /**
   * generates the header of the new Java class
   */
   private static void generateHeader(PrintWriter out) {
     // generate package declaration
     out.println("package " + Sdl.packageName + ";");
     out.println();
     // generate import specifications: optain the values from Sdl.varToClassName
     // and let duplicate occurrences be removed by using a set
     HashSet classNames = new HashSet(Sdl.varToClassName.values());
     Iterator it = classNames.iterator();
     out.println("import java.util.*;");
     out.println("import de.dfki.lt.sdl.*;");
     // if a mediator has been specified, import it
     if (Sdl.mediatorName != null) {
       // if a mediator has been specified, import it and ...
       out.println("import " + Sdl.mediatorName + ";");
       // extract the class name
       Sdl.mediatorName = Sdl.getClassName(Sdl.mediatorName);
     }
     else
       // otherwise use default mediator
       Sdl.mediatorName = Sdl.defaultMediator;
     while (it.hasNext()) {
       String className = (String)(it.next());
       if (!Sdl.isFromUnnamedPackage(className))
	 out.println("import " + className + ";");
       // check whether these classes really exist
       Sdl.lookUpClass(className);
     }
     out.println();
     // generate class comment
     out.println("/**");
     out.println(" * This is an automatically generated Java file which results");
     out.println(" * from the compilation of a system description located in file");
     out.println(" * " + (new File(Sdl.sysDescrFile)).getAbsolutePath() + ";");
     out.println(" *");
     out.println(" * A new system can be generated by calling the constructor for");
     out.println(" * this class:  new " + Sdl.className + "();");
     out.println(" *");
     out.println(" * The new system can be invoked by this schematic piece of code:");
     out.println(" *   " + Sdl.className + " module = new " + Sdl.className + "();");
     out.println(" *   Object result = module.run(<input>);");
     out.println(" *");
     out.println(" *");
     out.println(" * Since this class will implement interface de.dfki.lt.sdl.IModule,");
     out.println(" * it can be employed as a new (structured) module in even more");
     out.println(" * complex systems by calling run(_);");
     out.println(" * Furthermore, since this class extends de.dfki.lt.sdl.Modules,");
     out.println(" * the default implementation for methods specified in IModule can");
     out.println(" * be used;");
     out.println(" *");
     out.println(" * @author (C) Hans-Ulrich Krieger and YOU");
     out.println(" * @since JDK 1.3");
     out.println(" * @version 1.0.1, " + (new Date()).toString());
     out.println(" */");
   }

  /**
   * a class belongs to the unnamed package iff its fully qualified name
   * does NOT contain the full stop character
   */
  private static boolean isFromUnnamedPackage(String className) {
    if (className.indexOf(".") == -1)
      return true;
    else
      return false;
  }

  /**
   * getClassNameFromVar() returns the class name from the fully qualified name
   * stored under variable varName
   */
  private static String getClassNameFromVar(String varName) {
    String fullName = (String)(Sdl.varToClassName.get(varName));
    if (Sdl.isFromUnnamedPackage(fullName))
      return fullName;
    else
      return fullName.substring(fullName.lastIndexOf(".") + 1);
  }

  /**
   * getClassName() returns the name of a class from a perhaps fully qualified
   * class name
   */
  private static String getClassName(String fullName) {
    if (Sdl.isFromUnnamedPackage(fullName))
      return fullName;
    else
      return fullName.substring(fullName.lastIndexOf(".") + 1);
  }

  /**
   * processGlobalVariables() generates a private instance field for every variable
   * in the system description; note that the variables are already marked with '$'
   */
  private static void processGlobalVariables(PrintWriter out) {
    Set keys = Sdl.varToClassName.keySet();
    Iterator it = keys.iterator();
    while (it.hasNext()) {
      out.println("  /**");
      out.println("   * this field corresponds to a single variable in the system description");
      out.println("   */");
      String varName = (String)(it.next());
      out.println("  private " + Sdl.getClassNameFromVar(varName) + " " + varName + ";");
      out.println();
    }
  }

  /**
   * processLocalVariables() generates a private instance field for every newly
   * introduced variable, originating from a subexpression (a completely bracketed
   * expression) of the regular system expression
   */
  private static void processLocalVariables(PrintWriter out) {
    SortedSet keys = new TreeSet(Sdl.localVarToExpr.keySet());
    Iterator it = keys.iterator();
    while (it.hasNext()) {
      out.println("  /**");
      out.println("   * this field corresponds to a subexpression in the system description");
      out.println("   */");
      String varName = (String)(it.next());
      // the class name for class is "_Class" followed by varName without the dollar sign
      out.println("  private _Class" + varName.substring(1) + " " + varName + ";");
      // remember this association
      Sdl.varToClassName.put(varName, ("_Class" + varName.substring(1)));
      out.println();
    }
  }

  /**
   * hasInitArgs() checks whether the module for a given variable has been
   * equipped with additional init args
   */
  private static boolean hasInitArgs(String varName) {
    String[] initArgs = (String[])(Sdl.varToInitArgs.get(varName));
    if (initArgs.length == 0)
      return false;
    else
      return true;
  }

  /**
   * generates an array literal of strings, represented as a string;
   * the array elements are the init args for a certain module associated
   * with varName
   */
  public static String generateArrayLiteral(String varName) {
    StringBuffer sb = new StringBuffer();
    String[] array  = (String[])(Sdl.varToInitArgs.get(varName));
    int length = array.length;
    sb.append("{");
    for (int i = 0; i < length; i++) {
      sb.append("\"");
      sb.append(array[i]);
      sb.append("\"");
      if ((i + 1) != length)
	sb.append(", ");
    }
    sb.append("}");
    return sb.toString();
  }

  /**
   * generateConstructor() generates a nullary public constructor for the newly
   * generated Java class; the purpose of this constructor is to initialize the
   * private instance fields and potentially initializes some of the instances
   */
  private static void generateConstructor(PrintWriter out) {
    out.println("  /**");
    out.println("   * the nullary constructor");
    out.println("   */");
    out.println("  public " + Sdl.className + "() throws ModuleInitError {");
    out.println("    super();");
    // generate the values for the instance fields ...
    out.println("    // set instance fields");
    Set keys = Sdl.varToClassName.keySet();
    String varName;
    Iterator it = keys.iterator();
    while (it.hasNext()) {
      varName = (String)(it.next());
      out.println("    " + "this." + varName + " = new " + Sdl.getClassNameFromVar(varName) + "();");
    }
    // ... and perhaps perform initialization using init() from Modules
    out.println("    // initialize modules");
    keys = Sdl.varToInitArgs.keySet();
    it = keys.iterator();
    String localVar;
    while (it.hasNext()) {
      varName = (String)(it.next());
      if (Sdl.hasInitArgs(varName)) {
	localVar = "_" + ++Sdl.index;
	out.println("    String[] " + localVar + " = " + Sdl.generateArrayLiteral(varName) + ";");
	out.println("    " + "this." + varName + ".init(" + localVar + ");");
      }
    }
    out.println("  }");
    out.println();
  }

  /**
   * a token is a variable iff it starts with '$'
   */
  private static boolean isVariable(String token) {
    if (token.charAt(0) == '$')
      return true;
    else
      return false;
  }

  /**
   * returns the i-th element from array list al;
   * note that al will NOT be altered
   */
  private static String getToken(ArrayList al, int i) {
    return ((String)al.get(i));
  }

  /**
   * returns the first element from array list al;
   * note that this first element will be REMOVED from al
   */
  private static String getToken(ArrayList al) {
    return ((String)(al.remove(0)));
  }

  /**
   * handles sequences of single variables, prefixed by the '|' operator
   */
  private static String regExprPar(ArrayList al, PrintWriter out, String lastVar, String indent, String contClass) {
    // read off | operator
    getToken(al);
    String module, localVar;
    ArrayList modules = new ArrayList();
    // generate a container to have a reference to the threads
    if (Sdl.threadedValue.equals("yes")) {
      out.println(indent + "Thread thread;");
      out.println(indent + "ArrayList threads = new ArrayList();");
    }
    Iterator it = al.iterator();
    while (it.hasNext()) {
      module = (String)(it.next());
      // remember module variable
      modules.add(module);
      // clear internal state of variable and set its input
      out.println(indent + contClass + "this." + module + ".clear();");
      // input MUST be set, both for sequential and concurrent execution of modules
      out.println(indent + contClass + "this." + module + ".setInput(" + lastVar + ");");
      if (Sdl.threadedValue.equals("yes")) {
	// let the thread execute module's run method
	out.println(indent + "thread = new Thread(" + contClass + "this." + module + ");");
	out.println(indent + "threads.add(thread);");
	out.println(indent + "thread.start();");
      }
      else {
	// new local var for storing result of computation of first operand
	localVar = "_" + ++Sdl.index;
	out.println(indent + "Object " + localVar + " = " + contClass + "this." + module + ".run(" + lastVar + ");");
	out.println(indent + contClass + "this." + module + ".setOutput(" + localVar + ");");
      }
    }
    if (Sdl.threadedValue.equals("yes")) {
      // only proceed if all threads are finished
      out.println(indent + "int pos = -1;");
      out.println(indent + "while (!threads.isEmpty()) {");
      // do not create an iterator here every time we check whether threads are finished
      out.println(indent + "  for (int i = 0; i < threads.size(); i++) {");
      out.println(indent + "    if (!((Thread)(threads.get(i))).isAlive()) {");
      out.println(indent + "      pos = i;");
      out.println(indent + "      break;");
      out.println(indent + "    }");
      out.println(indent + "  }");
      out.println(indent + "  if (pos != -1) {");
      out.println(indent + "    threads.remove(pos);");
      out.println(indent + "    pos = -1;");
      out.println(indent + "  }");
      out.println(indent + "}");
    }
    // generate mediator code: (1) array literal
    localVar = "_" + ++Sdl.index;
    out.print(indent + "IModule[] " + localVar + " = {");
    int length = modules.size();
    for (int i = 0; i < length; i++) {
      out.print(contClass + "this." + ((String)(modules.get(i))));
      if ((i + 1) != length)
	out.print(", ");
    }
    out.println("};");
    // (2) compute result of mediation
    String localVar2 = "_" + ++Sdl.index;
    out.println(indent + "Object " + localVar2 + " = _med.par(" + localVar + ");");
    return localVar2;
  }

  /**
   * handles sequences of single variables, connected by the '+' operator
   */
  private static String regExprSeq(ArrayList al, PrintWriter out, String lastVar, String indent, String contClass) {
    String module1 = getToken(al);
    // clear internal state of variable and set its input
    out.println(indent + contClass + "this." + module1 + ".clear();");
    out.println(indent + contClass + "this." + module1 + ".setInput(" + lastVar + ");");
    // new local var for storing result of computation of first operand
    String localVar = "_" + ++Sdl.index;
    out.println(indent + "Object " + localVar + " = " + contClass + "this." + module1 + ".run(" + lastVar + ");");
    out.println(indent + contClass + "this." + module1 + ".setOutput(" + localVar + ");");
    // last variable in sequence? return it, since it is the ANCHOR to the following expression
    if (al.isEmpty())
      return localVar;
    // next token MUST be '+', otherwise exit
    String plus = getToken(al);
    if (!plus.equals("+")) {
      System.err.println("Wrong token in system description; found '" + plus + "'; must be '+'; exiting ...");
      System.exit(1);
    }
    // mediate between the modules; what follows after the '+' MUST be either a variable
    String module2 = getToken(al, 0);
    localVar = "_" + ++Sdl.index;
    out.println(indent + "Object " + localVar + " = _med.seq(" + contClass + "this." + module1 + ", " + contClass + "this." + module2 + ");");
    // recursively call regExprSeq() again
    return Sdl.regExprSeq(al, out, localVar, indent, contClass);
  }

  /**
   * handles a single variable, prefixed by the '*' operator
   */
  private static String regExprFix(ArrayList al, PrintWriter out, String lastVar, String indent, String contClass) {
    // read off * operator
    getToken(al);
    String module = getToken(al);
    // clear internal state of variable and set its input
    out.println(indent + contClass + "this." + module + ".clear();");
    out.println(indent + contClass + "this." + module + ".setInput(" + lastVar + ");");
    // call fixpoint computation
    String localVar = "_" + ++Sdl.index;
    out.println(indent + "Object " + localVar + " = _med.fix(" + contClass + "this." + module + ");");
    out.println(indent + contClass + "this." + module + ".setOutput(" + localVar + ");");
    return localVar;
  }

  /**
   * this is the dispatcher for calling the proper regular expression transformers
   */
  private static void dispatchRegExpr(ArrayList al, PrintWriter out, String input, String indent, String contClass) {
    String lastVar = null;
    String token = getToken(al, 0);
    if (Sdl.isVariable(token))
      lastVar = regExprSeq(al, out, input, indent, contClass);
    else if (token.equals("|"))
      lastVar = regExprPar(al, out, input, indent, contClass);
    else if (token.equals("*"))
      lastVar = regExprFix(al, out, input, indent, contClass);
    else {
      System.err.println("Found non-legal token: '" + token + "'; exiting ...");
      System.exit(1);
    }
    out.println(indent + "return this.setOutput(" + lastVar + ");");
  }

  /**
   * transformRegExpr() generates the code for run(_);
   * note that regExpr is already normalized
   */
  private static void transformRegExpr(String regExpr, PrintWriter out, String indent, String contClass) {
    StringTokenizer st = new StringTokenizer(regExpr);
    if (st.countTokens() == 0) {
      // zero token right-hand side
      System.err.println("No right-hand side is specified in the system description; exiting ...");
      System.exit(1);
    }
    // since the regExpr is already normalized, I transform it into an ArrayList
    // to realize an arbitrary look ahead;
    out.println(indent + "IMediator _med = new " + Sdl.mediatorName + "();");
    ArrayList al = new ArrayList(st.countTokens());
    while (st.hasMoreTokens())
      al.add(st.nextToken());
    // "input" is the anchor of the whole expression, viz., the parameter of run(_)
    Sdl.dispatchRegExpr(al, out, "input", indent, contClass);
  }

  /**
   * makes an association between a newly created local variable and a newly
   * generated local regular expression and returns the local variable name;
   * note that if a structural equivalent expression of an already existing one
   * is entered, a NEW local variable is returned anyhow (which is represented
   * by a class field, hence starting with '$')
   */
  private static String addLocalExpression(String subExpr, boolean verbose) {
    String localVar = "$" + ++Sdl.index;
    if (verbose)
      System.out.println(localVar + " = " + "(" + subExpr + ")");
    Sdl.localVarToExpr.put(localVar, subExpr);
    return localVar;
  }

  /**
   * normalizes a proposed regular expression such that operands are single
   * variables and parentheses has been eliminated;
   * furthermore checks whether opening and closing parentheses match
   */
  private static String normalizeRegExpr(StringTokenizer st) {
    StringBuffer sb = new StringBuffer();
    while (st.hasMoreTokens()) {
      String token = st.nextToken();
      if (Sdl.isVariable(token) ||
	  token.equals("+") ||
	  token.equals("|") ||
	  token.equals("*"))
	// token is NOT a parenthesis
	sb.append(token).append(" ");
      // "(" case
      else if (token.equals("(")) {
	int noOfPars = Sdl.noOfPars;
	++Sdl.noOfPars;
	// recursively call normalizeRegExpr() for an opening parenthesis
	sb.append(normalizeRegExpr(st)).append(" ");
	// do opening and closing parantheses matches?
	if (noOfPars != Sdl.noOfPars) {
	  System.err.println("Opening and closing parentheses do not match (" + Sdl.noOfPars + "); exiting ...");
	  System.exit(1);
	}
      }
      // ")" case
      else if (token.equals(")")) {
	// sub-expression completed
	--Sdl.noOfPars;
	if (Sdl.noOfPars < 0) {
	  System.err.println("Opening and closing parentheses do not match (" + Sdl.noOfPars + "); exiting ...");
	  System.exit(1);
	}
	String subExpr = sb.toString().trim();
	// check for a single token, i.e., does subExpr contains the space character
	// e.g., "(var)" is NOT replaced by a new variable
	if (subExpr.indexOf(" ") == -1)
	  return subExpr;
	  // and if we have more than one token, return a new local variable for that expression
	else 
	  return Sdl.addLocalExpression(subExpr, Sdl.verbose);
      }
      // wrong token otherwise
      else {
	System.err.println("Found non-legal token: '" + token + "'; exiting ...");
	System.exit(1);
      }
    }
    // do opening and closing parantheses matches?
    if (Sdl.noOfPars != 0) {
      System.err.println("Opening and closing parentheses do not match (" + Sdl.noOfPars + "); exiting ...");
      System.exit(1);
      // for the pleasure of javac:
      return "";
    }
    else
      return sb.toString().trim();
  }

  /**
   * given a normalized module expression, extractOperator() returns the
   * operator name (a string);
   * at the moment, possible values are: "+", "|", "*".
   */
  private static String extractOperator(String expr) {
    StringTokenizer st = new StringTokenizer(expr);
    String token = st.nextToken();
    if (isVariable(token))
      return "\"+\"";
    else
      return ("\"" + token + "\"");
  }

  /**
   * given a normalized module expression, extractModules() returns a
   * string, representing an array literal of class names, refering to
   * the classes to which the variables in the module expression are
   * bound
   */
  private static String extractModules(String expr) {
    StringTokenizer st = new StringTokenizer(expr);
    StringBuffer modules = new StringBuffer();
    String token, clazz;
    modules.append("{");
    while (st.hasMoreTokens()) {
      token = st.nextToken();
      if (!(token.equals("+") || token.equals("|") || token.equals("*"))) {
        clazz = (String)(Sdl.varToClassName.get(token));
        // association between local variabels and corresponding local classes is not established yet!!
        if (clazz == null)
          clazz = "_Class" + token.substring(1);
        modules.append("\"").append(clazz).append("\"");
        if (st.hasMoreTokens())
          // the last module name is not succeeded by a ", "
          modules.append(", ");
      }
    }
    modules.append("}");
    return modules.toString();
  }

  /**
   * generates local class definitions inside the newly generated class;
   * map over hashtable Sdl.localVarToExpr.keySet(), where keys are newly introduced
   * variable names and the corresponding values flat regular expressions
   */
  private static void generateLocalClasses(PrintWriter out) {
    String varName, subExpr, className;
    SortedSet keys = new TreeSet(Sdl.localVarToExpr.keySet());
    Iterator it = keys.iterator();
    while (it.hasNext()) {
      varName = (String)(it.next());
      subExpr = (String)(Sdl.localVarToExpr.get(varName));
      className = "_Class" + varName.substring(1);
      out.println("  /**");
      out.println("   * this local class corresponds to the following subexpression in the");
      out.println("   * system speification: (" + subExpr + ")");
      out.println("   */");
      out.println("  private class " + className + " implements IModule, Runnable {");
      out.println("    //");
      out.println("    private Object _input;");
      out.println("    //");
      out.println("    private Object _output;");
      out.println("    //");
      out.println("    private String _operator;");
      out.println("    //");
      out.println("    private String[] _modules;");
      out.println("    //");
      out.println("    private " + className + "() {");
      out.println("      this._input = null;");
      out.println("      this._output = null;");
      out.println("      this._operator = " + Sdl.extractOperator(subExpr) + ";");
      out.println("      this._modules = new String[] " + Sdl.extractModules(subExpr) + ";");
      out.println("    }");
      out.println("    //");
      out.println("    public void clear() {");
      out.println("    }");
      out.println("    //");
      out.println("    public void init(String[] initArgs) {");
      out.println("    }");
      out.println("    //");
      out.println("    public Object getInput() {");
      out.println("      return this._input;");
      out.println("    }");
      out.println("    //");
      out.println("    public Object setInput(Object input) {");
      out.println("      return (this._input = input);");
      out.println("    }");
      out.println("    //");
      out.println("    public Object getOutput() {");
      out.println("      return this._output;");
      out.println("    }");
      out.println("    //");
      out.println("    public Object setOutput(Object output) {");
      out.println("      return (this._output = output);");
      out.println("    }");
      out.println("    //");
      out.println("    public String getOperator() {");
      out.println("      return this._operator;");
      out.println("    }");
      out.println("    //");
      out.println("    public String setOperator(String operator) {");
      out.println("      return (this._operator = operator);");
      out.println("    }");
      out.println("    //");
      out.println("    public String[] getModules() {");
      out.println("      return this._modules;");
      out.println("    }");
      out.println("    //");
      out.println("    public String[] setModules(String[] modules) {");
      out.println("      return (this._modules = modules);");
      out.println("    }");
      out.println("    //");
      out.println("    public Object run(Object input) throws ModuleClearError, ModuleRunError {");
      // NOTE: modules involved in this local class are already initialized in the
      //       constructor of the global class corresponding to the system description;
      //       I do not clear this instance of local class, but only set input/output
      out.println("      this.setInput(input);");
      Sdl.transformRegExpr(subExpr, out, "      ", (Sdl.className + "."));
      out.println("    }");
      // now generate the empty run() method (easy!)
      out.println("    //");
      out.println("    public void run() throws ModuleClearError, ModuleRunError {");
      out.println("      this.run(this.getInput());");
      out.println("    }");
      out.println("  }");
      out.println();
    }
  }

  /**
   * generates the Java code for the module method run(_) from
   * the system description (which has already been normalized by separating
   * each token by a single space character);
   * in order to achieve this, the module operators and the mediators are
   * employed here
   */
  private static void generateRun(PrintWriter out, String regExpr) {
    out.println("  /**");
    out.println("   * this version of run() is consistent with the specification in");
    out.println("   * de.dfki.lt.sdl.IModule; run() realizes exactly the behavior of");
    out.println("   * system " + Sdl.systemName + ", viz.,");
    out.println("   * " +  Sdl.regExpr);
    out.println("   */");
    out.println("  public Object run(Object input) throws ModuleClearError, ModuleRunError {");
    // clear internal state of new module and set its input field to input
    out.println("    this.clear();");
    out.println("    this.setInput(input);");
    // generate code for the normalized regular system expression
    Sdl.transformRegExpr(regExpr, out, "    ", "");
    out.println("  }");
  }

  /**
   * generates the internal code of the Java class;
   * NOTE: I let the class inherits from de.dfki.lt.sdl.Modules and also
   * demands that it must implement de.dfki.lt.sdl.IModule (which it does,
   * since we generate an implementation for run(_)
   */
   private static void generateCode(PrintWriter out, String regExpr) {
     // generate class header
     out.println("public class " + Sdl.className + " extends Modules implements IModule, Runnable {");
     out.println();
     // normalize regExpr such that the operands are single variables and parentheses are eliminated
     regExpr = Sdl.normalizeRegExpr(new StringTokenizer(regExpr));
     // generate instance fields for original variables
     Sdl.processGlobalVariables(out);
     // generate local classes for local expressions introduced  during normalization step
     Sdl.generateLocalClasses(out);
     // generate instance fields for variables of newly introduced local classes
     Sdl.processLocalVariables(out);
     // generate constructor
     Sdl.generateConstructor(out);
     // generate run()
     Sdl.generateRun(out, regExpr);
     // closing brace and finished
     out.println();
     // generate empty run() method
     out.println("  /**");
     out.println("   * empty run() for Runnable is based on the unary run() directly above");
     out.println("   */");
     out.println("  public void run() throws ModuleClearError, ModuleRunError {");
     out.println("    this.run(this.getInput());");
     out.println("  }");
     out.println();
     out.println("}");
   }

  /**
   * sets Sdl.verbose to true and calls the static Sdl.compile() method on first
   * argument args[0]
   */
  public static void main(String[] args) {
    Sdl.verbose = true;
    // for instance: args[0] = "/home/cl-home/krieger/Java/java/de/dfki/lt/sdl/test/test.sdl"
    Sdl.compile(args[0]);
  }

}
