# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains a cats, families, and dicionary-forms for
# important things (sentence, subject, coordination and particles). 
# These items:
#     1) don't deserve a file of their own
#     2) are required by the following files, and hence (in DotCCG) must
#        be defined before hand

 
#########################
# SENTENCE & EVENT CATS #
#########################
  
  def EVENT(args)     { E:event( args ) }

  def s(args)         { s<10> [E NUM:NUM PERS:PERS MCLASS:MCLASS MOOD:MOOD POL:POL FIN:FIN VFORM:VFORM args]}
  def from-s(args)    { s<~10>[E args] }
 

###############
# The SUBJECT #
###############

 
   def subj(args)        { np<9> [S nom NUM:NUM PERS:PERS args] }
   def from-subj(args)   { np<~9>[S nom NUM:NUM PERS:PERS args] } 

   def +subj(args)       { \! subj(args) } 
   def +from-subj(args)  { \! from-subj(args) }

   # NOTE the ! : Verbs don't actually syntactically'take' their subjects.
   #       This is done via rule for ind, via aux or wh-word for int, etc   
 
  
#############################
## COORD CAT & DICT FORMS  ##
#############################


  # The syntactic categories for coordination, as well as the families,
  # are located in their respective files.
  #  e.g Noun & NP coord are in noun.ccg, prep in prep.ccg
  #  Sentential & VP coord are in verb.ccg

  def COORD(args)       { R( args <First>(F) ^ <Next>(N) ) }
 
  # modify a given pos (adj, adv, prep, etc) on the given side (left, right)
  #
  def coord+(form, pos, class, args) {_coord+(form, form, pos, class, args) }
  def _coord+(prd, form, pos, class, args) {
    word form."-coord-".pos : "Coord-" . pos."-" (class, pred=prd)
	{form: args;}
  } 
  
  def coord(form, pos, class) {_coord(form, form, pos, class) }
  def _coord(prd, form, pos, class) {
    word form."-coord-".pos : "Coord-" . pos."-" (class, pred=prd)
	{form ;}
  } 

############
# PARTICLE #
############

  # As in pick UP the ball , pick the ball UP.
  # Currently not really being used much. But definitely should!

  def prt(args)      { prt<25>[P args] }
  family Particle    { entry:  prt(MARK= *) : P(*) ;}
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains the 'basic' semantic and syntactic features 
# used by the grammar. 'Complex' features for word classes are located
# in types-word-classes.ccg

#####################
# SEMANTIC FEATURES #
#####################

# Note: currently a 'redundancy' for proximity. Can't re-use feature-value names
#       so must have , e.g., distal, e-distal and m-distal corresponding to
#       THAT ball, who said THAT, OVER on the table (or THERE)
#
# NOTE: This could be resolved by changing all the relevant cats to having same
#       Index, e.g. preps and deictic events could receive, respectively:
#                  pp[T] / np[A]  :  T:modifier( * <Anchor>A:entity )
#                  s[T]            : T:event(context)
#       in other words, enforcing the index variables chosen is not at all important 

feature{

## ENTITY ##

  NUMBER<T:Num>: sg pl;      
  PROXIMITY<T:Proximity>: distal proximal;
  DELIMINATION<T:Delimitation>: unique existential variable;
  QUANTIFICATION<T:Quantification>: specific unspecific uncountable;

## EVENT ##
  
  POLARITY<E:Polarity>: pos neg;
  MOOD<E:Mood>: ind imp int;
  TENSE<E:Tense>: past pres fut;
  ASPECT<E:Aspect>: continuous perfect;
  VOICE<E:Voice>: active passive;
  E-PROXIMITY<E:Proximity>: e-distal e-proximal;

## MOD ##

  DEGREE<M:Degree>: no-degrees degrees{degree-base comparative superlative};
  M-PROXIMITY<M:Proximity>: m-distal m-proximal;

} # end feature

# These are the semantic features which are used inside family definitions in the grammar
# Although syntactic features can be used syntactic categories inside the grammar, semantic
# ones can't be (i.e only as 'macros' in dicionary entries) 

  def POS()  { <Polarity>(pos) }  def NEG()  { <Polarity>(neg) }
  def SG()   { <Num>(sg) }        def PL()   { <Num>(pl) }

  def UNCOUNTABLE()             { <Quantification>(uncountable) }
  def UNSPECIFIC()              { <Quantification>(unspecific)  }
  def SPECIFIC()                { <Quantification>(specific)    }

  def UNIQUE()      { <Delimitation>(unique) }
  def VARIABLE()    { <Delimitation>(variable) }
  def EXISTENTIAL() { <Delimitation>(existential) }
  
  def IND() { <Mood>(ind) }   def IMP() { <Mood>(imp) }   def INT() { <Mood>(int) }
  
######################
# SYNTACTIC FEATURES #
######################

  # 15 is the feature id for nouns
  # 9 is the feature id for the syntatic subject position
  # 10 is the feature id for sentences
  # 11 is the feature id for finites when 'selected' for by interrogative utterance templates
  #       the finite determines subj agreement and pol, vform & fin.
  # 42 is used for the np compliment in 'I am a man', used to block ' these are a ball'

feature{

## Noun features ##
  
  NUM<15, 9, 10, 11, 42>:  s-sg s-pl {s-pl-sp s-pl-unsp} s-mass ;  # specific plural (as in 3 balls) or unspecific (balls)
  PERS<15, 9, 10, 11>: non-3rd {1st 2nd} 3rd;
  
  CASE<15, 9>: nom acc-both{acc acc-loc}; # acc-loc is for here and there in 'on there', 'up here', 'closer to there' also 'before then' etc.                              
  NFORM<15, 9, 11>: nf-real{full pro nf-ctxt} nf-dummy{dummy-there};  # full form vs pronoun vs none (as in 'I will take the green')
  
 
## Sentence/Verbal Features ##
  
  # Sept 7 added mood-mixed to handle the coordinate "I am sorry but could you help me"
  #
  MOOD<10>:   s-major{ s-ind s-imp s-int s-ind-ell s-mood-mixed}  s-minor s-dependent;  
  POL<10,11>: s-pos s-prov-pos s-neg;
   
  # vf-be (am able to)  for-ing (thanks for helping me), fin-ctxt (I did), fin-deictic (I said that) , fin-full (all other finite events)
  # Need two layers b/c any thing which wants a finite-s can take a deictic (I said that, before that, etc.) BUT must the ind-building rule
  # only wants fin-ctxt or full
  #
  # Aug 20 added ell-subj as vform... may be useful. Should eventually take out of s-mood, me thinks.
  
  VFORM<10,11>: fin{ fin-clause{fin-ctxt fin-ell fin-full} fin-deictic} vf-base vf-to-imp inf ing pp vf-be for-ing;  
  
  # this will be important if we want 1) to handle tag questions 2) to cleanly & quickly handle 'ellipse responses' I did, you shouldn't, can I, etc.
  #
  FIN<10,11>:   be do can should will could would must have;  


## Adj/Adv Features ##
  
  DEGREE<25>: s-no-degrees s-degrees{s-degree-base s-comparative s-superlative};

## OTHER FEATURES ##

  # Questionable=no   -> placed on np slots which cannot be questioned via standard wh udc construction
  # Mark=??           -> placed on obliques and also dependent clauses
  # COM= yes or no    -> used in coordination constructions to block spurious readings
  #                      (only the single staircase reading remains)

} # end feature



feature {

  CORRECTED<1,10,15,25,34>: default asr-correction ;

} 
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains the semantic ontologies (type-heirarchies) 
# used by the grammar (and by dictionary items)

feature{

###########
## EVENT ##
###########


  ont-event: event{
                  relational
                  action {action-motion action-non-motion}
                  state {presentational ascription}
                  internal {perception cognition}
                  modal
                  communication
                  symbolic
                  };


  # ! Only 'event' (top level) and 'state' are used in the grammar



############
## ENTITY ##
############


  ont-entity: entity{
                     physical{ 
                              animate{person}
                              thing
                              e-location{e-region e-place}
  		             }
                     e-substance {e-material}
                     e-measure
                     e-event
                     e-time{e-time-point e-time-unit}
                   
  		     dummy
  		    };


  # ! Only 'entity' (top level), physical, e-time-point, e-time-unit
  # ! are used in the grammar
  # ! This is because very few 'semantic' selectional constraints
  # ! have been included in the grammar



#############
## QUALITY ##
#############

  ont-quality: quality{
                       q-physical{
                                  q-size
                                  q-shape
                                  q-age
                                  q-color
                                  q-state
                                  q-material
                                 }
                       q-position{
                                  q-location
                                  q-number {number-cardinal number-ordinal number-id}
                                  q-temporal
                                  q-discourse
                                 }
                       q-attitude
                      };
  
  
  # ! Only the top level 'quality' is used in the grammar

##############
## MODIFIER ##
##############

  ont-modifier: modifier{

                         m-dynamic{ m-direction m-whereto m-wherefrom m-through }
                         m-manner
                         m-time {m-time-point m-time-sequence m-time-interval}
                         m-location
                         m-probability
                         m-frequency     # sometimes, often, usually
                         m-comment       # quite generic 'affect'
                         m-serial		   # go get that
                         m-accompaniment # with GJ...
                         m-instrumental  # with the ball...
                         m-benefactor    # for ...
                         m-relational{m-cause m-result m-condition}
                         m-purpose       # I went there 'to get it'
  		         m-intensity
  		         m-comparison
  		         m-restriction   # ball that I picked up,  place where I saw you
                        };

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #            'modifier' is used in the grammar. 
  #
  #            Moreover, any changes to this will require changes in these files:
  #                  types-classes.ccg, prep.ccg, adv.ccg and (perhaps) verb.ccg
  #            See these files for specifics.
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

					  
###############
## DISCOURSE ##
###############

  # this needs re-doing!
  ont-discourse: marker{ d-units alignment cue greeting closing reject acknowledge evaluate };
				
}# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains the more 'complex' features used in defining
# word classes. Specifically, event modifier restriction classes for verbs
# and syntactic behaviour classes for modifiers (and now some nouns too...)

# In each case, a set of 'primatives/atoms' are defined, which are then collected
# into classes (via multiple inheritance), i.e.
#
#     CLASS:    atom1 atom2 ... atomN
#               class1 [atom1]  class2[atom1 atom2 atom5] ...

##########################
## Modifier Restriction ##
##########################

  # OpenCCG doesn't seem to like using the same feature-value names for differnt things, 
  # so, I have created 3 versions.
  #           1) m-#######, the ontological semantic sort (see types-ontology)
  #           2) x-#######, placed on mod themselves, specifying one 'kind' of modifier they are
  #           3) s-#######, placed on the s (or verb) to specify what 'kind' of modifiers it
  #                         accepts.

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #            If the modifier section of the ontological hierarchy is changed, you will have to add
  #            reflect these changes here
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


feature {

  MOD-TYPE<25>:          x-dynamic{ x-direction x-whereto x-wherefrom x-through }
                         x-manner
                         x-time {x-time-point x-time-sequence x-time-interval}
                         x-location
                         x-probability
                         x-frequency    
                         x-comment      
                         x-serial		   
                         x-accompaniment
                         x-instrumental
  		         x-comparison 
                         x-benefactor    
                         x-relational{x-cause x-result x-condition}
                         x-purpose       
                         x-intensity;

 
  # Note: These could in theory also be placed on Mod-Mods 
  #       to limit the kinds of Mods they can modify.

  MCLASS<10>:            s-dynamic{ s-direction s-whereto s-wherefrom s-through }
                         s-manner
                         s-time  {s-time-point s-time-sequence s-time-interval}
                         s-location
                         s-probability
                         s-frequency    
                         s-comment      
                         s-serial		   
                         s-accompaniment
      		         s-instrumental
  		         s-comparison 
                         s-benefactor    
                         s-relational{s-cause s-result s-condition}
                         s-purpose       
                         s-intensity
  		         s-none

  # These are the classes which verbs lexically select 
  # Each is a collection of the 'primatives' defined immediately above.
  # NEW CLASSES CAN EASILY BE ADDED HERE.

  m-class-none  [s-none]
  m-class-5     [                                       s-comment]
  m-class-4     [s-relational s-frequency s-probability s-comment s-time]
  m-class-3     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison]
  m-class-2x    [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison           s-location]
  m-class-2     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location]
  m-class-1     [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location s-manner s-serial]
  m-class-1x    [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose            s-manner s-serial s-dynamic]
  m-class-all   [s-relational s-frequency s-probability s-comment s-time  s-instrumental s-accompaniment s-benefactor s-comparison s-purpose s-location s-manner s-serial s-dynamic]
  ;


#############################
## Combinatorial Behaviour ##
#############################

  # These are the features which determine the syntactic behaviour of modifiers
  # (where they can be). Each modifer POS (adv, pp) has a rule for each of 
  # these saying, e.g, 'if you are allowed to pre-modify sentences, 
  # then I'll turn you into a pre-modifier '
  
  # Each modifier lexically (in the dictionary) chooses its syntactic 'class'

  CC-TYPE<25, 15>: post-s post-s-loose pre-s pre-vp post-vp 
                   pre-cop-comp   # I am ALSO big,  it is CERTAINLY not a ball
                   post-n pre-n
    		   cc-none
  		 	 
                   ## Nominal behaviour                 
   
  		   compound-1st compound-head  # the two parts of noun-noun compounds
  		   no-q  # for those that don't want 'quality' entities (color, size, shap, etc),
                         # e.g. 'what size ball' but not 'what size color'
			 
   ## Adverb Classes ## (NEW CAN EASILY BE MODIFIED/EXTENDED)			 
			 
   adv-all  [pre-s pre-vp post-vp   post-s pre-cop-comp] 
   adv-1    [pre-s pre-vp post-vp   post-s] #s or vp?
   adv-2    [      pre-vp post-vp   post-s]
   adv-3    [pre-s        post-vp   post-s]
   adv-4    [             post-vp   post-s]
   adv-5    [pre-s pre-vp                 ]
   adv-6    [      pre-vp post-vp         ]
   adv-7    [pre-s pre-vp post-vp   post-s]  

   ## Prepositions Classes ## (NEW CAN EASILY BE MODIFIED/EXTENDED)
			 
   prep-all [post-n post-s post-vp pre-s]
   prep-1   [post-n post-s post-vp      ]
   prep-2   [       post-s post-vp      ]
   prep-3   [post-n                     ]
   prep-4   [       post-s post-vp pre-s]
			 
   ## Nominal Classes ##   

   n-all [compound-1st compound-head no-q]
   n-1   [compound-1st  no-q]
   n-2   [compound-head no-q]
   n-3   [compound-1st]
   n-4   [no-q]
  
   ;

} # end feature# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains some important categories used by modifiers like
# adjectives, adverbs and prepositions 
#
#    1) the complex-syntactic categories used in their type-changing rules
#    2) the semantic dependency relations used for modifiers
#    3) syn & sem categories for modifier arguments (like the np arg of prepositions)
#    4) a generic dictionary-entry macro for modifier-modifiers.

# Due to DotCCG ordering issues, this file also contains copula argument definitions

####################################
# SYNTACTIC COMPLEX-CAT CATEGORIES #
####################################

  # These correspond to the various CC-CAT values given to modifiers
  # such as prepositions, adverbs, adjectives etc. (see types-word-classes.ccg)
  #
  # The 'mod' argument is the modifier-class corrisponding to the modifier-type of the
  # modifier. This is restricts the type of sentences which can be modified.
  # I have used MCLASS:mod vs. MCLASS=mod b/c we only want the sentence(verb) to 
  # have a class which unifies with the modifier. We don't want to change its value. 
  #
  # The syn argument here corresponds to any arguments that the modifier 
  # may have 'following it', e.g. the np arg of a preposition.
  # The ordering here is crucial for incremental parsing:
  #	For pre-modifiers, the modifier args will come first then the modifee
  #     For post-modifiers, the modifee comes and then then the mod args


  def post-s(mod, syn)          {  from-s() syn \* s(MCLASS:mod )  }
  def post-s-loose(mod, syn)    {  from-s() syn \< s(MCLASS:mod )  }
  def post-vp(mod, syn)         {  from-s() +from-subj()  syn \* ( s(MCLASS:mod) +subj() )  }
    
  def pre-s(mod, syn)           {  from-s() /^ s(MCLASS:mod )  syn   }
  def pre-vp(mod, syn)          {  from-s() +from-subj() /^ ( s(MCLASS:mod) +subj() )  syn }  


  # Added by plison
  def post-s2(syn)          {  from-s() syn \* s()  }
  def post-s-loose2(syn)    {  from-s() syn \< s()  }
  def post-vp2(syn)         {  from-s() +from-subj()  syn \* ( s() +subj() )  }
    
  def pre-s2(syn)           {  from-s() /^ s()  syn   }
  def pre-vp2(syn)          {  from-s() +from-subj() /^ ( s() +subj() )  syn }  
  


  # Added  Aug 19:
  #   this is a hack to incrementally parse 'the ball that I just picked up'
  #   Need to sort out incremental handling of this later!
  
  def pre-vp-in-rel-clause(mod, syn) {       n() / ( from-s() +from-subj() / np<56>[X] ) 
                                        \^ ( n() / ( s(MCLASS:mod) +subj() / np<56>[X] ) ) 
                                           syn
                                     }
 
  def post-n(args, syn)         {  from-n(args) syn \* n()  }
 def post-n2(syn)         {  from-n() syn \* n()  }
  def pre-n(args, syn)          {  from-n(args) / n() syn  }		

########################################
# SPECIAL MODIFIER 'SLOTS' FOR COPULA. #
########################################

  # These must be defined here because of DotCCG ORDERING ISSUES
  #
  # This handles I am ALSO big, it is DEFINITELY not a ball, etc.
  # i.e. they occur before the compliment  of the copular
  # NOTE: To avoid OVER-GENERATION (e.g. I gave him DEFINITELY the ball),
  #        the allow compliment possiblities must be specifically defined
  
  # The three possible compliments

  def +cop-np(args)  { / np<42>[X NUM:NUM acc args] }    # the restr & Scope must share number (*these are a ball) 
  def +cop-pp(args)  { /^ pp<2>[X args] } # it must be a preposition which can modify nouns. done semantically (see copula families)
  def +cop-adj(args) { / adj<2>[X args] }

  # Marked as fin=be to block, e.g. I moved CERTAINLY the ball...
  def pre-cop-comp (moder, modee, arg)      { from-s(moder) arg \^ ( s(modee be) arg ) } 

  # These are defined independently because copular negation uses these directly
  #
  def pre-cop-pp(moder, modee, arg)  { pre-cop-comp(moder, modee, +cop-pp() arg   ) }
  def pre-cop-np(moder, modee, arg)  { pre-cop-comp(moder, modee, +cop-np() arg   ) }
  def pre-cop-adj(moder, modee, arg) { pre-cop-comp(moder, modee, +cop-adj() arg  ) }

  # This is invoked by the specific modifier type (e.g. adv) 
  #
  def mod-rule-pre-cop(atomicmod, arg, modee, sem){
	# rule{ typechange: atomicmod arg => pre-cop-pp (, modee, arg) : sem ;}
	 rule{ typechange: atomicmod arg => pre-cop-np (, modee, arg) : sem ;}
         rule{ typechange: atomicmod arg => pre-cop-adj(, modee, arg) : sem ;}
  }


  def mod-rule-pre-cop2(atomicmod, arg, sem){
	# rule{ typechange: atomicmod arg => pre-cop-pp (, , arg) : sem ;}
	 rule{ typechange: atomicmod arg => pre-cop-np (, , arg) : sem ;}
         rule{ typechange: atomicmod arg => pre-cop-adj(, , arg) : sem ;}
  }


#######################################
# MODIFIER DEPENDENCY RELN SEMANTICS  #
#######################################

  # This is the generic dependency relation used by ALL MODIFIERS (all adj, pp, adv, etc) 
  # when they are used as modifiers, i.e., this is added to the the semantics of the 
  # modifee within all of the various complex category type changing rules used to 
  # turn atomic modifiers into complex modifiers. 
  #
  # Note: further specification of the nature of relation (i.e location, frequency, etc.)
  #       is handled using the semantic sort hierarchy (see types-ontology.ccg)

  def MODIFIER(args) {<Modifier>(M  args) }
  
  def PURPOSE(args) {<Purpose>(M args) }

  # This is the semantic dependency relation used by modifier modifiers,
  #     e.g.  'really' big , 'over' on the table, etc. 
  # The syntactic categories are defined locally in the appropriate
  # modifier .ccg file 
  
  def M-MOD(args)        { <Modifier>(MM args) }


#####################################
# MODIFIER ARGUMENTS: SLOTS & ROLES # 
#####################################

  # These are the syntactic slots and corresponding semantic roles
  # used for modifiers with arguments (ma = Modifier Argument)

  # NP/OBL SLOT #
  
  def np_ma(args)            { np<30>[A args] }
  def n_ma(args)             { n<30>[A args] }
  def obl_ma(mrk, args)      { obl<30>[A MARK=mrk args] }
  def obln_ma(mrk, args)     { obln<30>[A MARK=mrk args] }
  
  def ARG(args)              { <Anchor>(A args) }

  # S SLOT #

  def s_ma(args)             { s<31>[G args] }
  def E-ARG(args)            { <Event>(G args) }


#######################
## DICTIONARY FORMS  ##
#######################

  # modify a given pos (adj, adv, prep, etc) in the given position (pre, post) 

  def modifier(form, pos, side, class) {  _modifier(form, form, pos, side, class)  }
  def _modifier(prd, form, pos, side, class) {
    word form.-mod-.side."-".pos."-".class : "Mod-" . side . "-" . pos ."-" ("m-".class, pred=prd)
	{form;}
  } 

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def n(args)         { n<15> [T CASE NUM PERS NFORM args] }
  def np(args)        { np<15>[T CASE NUM PERS NFORM args] }
   
  def from-n(args)    { n<~15> [T args] }
  def from-np(args)   { np<~15>[T args] }
 
  # This is a 'case' marked np, like the 'with the ball' in 'play with the ball'
  # verbs can specify what marking they recieve. See Markers.ccg for the oblique family
  
  def obl(mrk, args)  { obl<15>[T MARK=mrk args] }
 
   
##########################
## SEMANTIC DEFINITIONS ##
##########################

  def ENTITY(args)      { T:entity(args) }
  def OWNER(args)       { <Owner>(O:entity args) }
   

##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def n-cat(args, sem)         { n() args   :   ENTITY( sem) ; }
  def np-cat(args, sem)        { np() args  :   ENTITY( sem) ; }
 
  ## The Families ##
 
  family Noun          { entry: n-cat (               , *         )  }
  
  # July 24, took out contextualized readings at GJ's request, didn't like em popping up in questions
  #
  family Noun+of-np-    { entry: n-cat ( / obl_ma(of, Questionable=no)  , * <Owner>(A:entity) ) }
                      #   entry: n-cat (                                , * <Owner>(A:entity context) ) }
  family Noun+of-n-     { entry: n-cat ( / obln_ma(of, Questionable=no) , * <Owner>(A:entity) )  }
                      #   entry: n-cat (                                , * <Owner>(A:entity context) )  }
  family Noun+number-   { entry: n-cat ( / number[N] , * <Id>(N:number-cardinal) )  } 

  family Bare-np       { entry: np-cat(              , *        )  }
 
  family Bare-np+of-np { entry: np-cat( / obl_ma(of, Questionable=no)   , * <Owner>(A) )  }

  # These handle, e.g. 'the green', acting as a full referring expression.
  #
  family Context-np+modifier           { entry: np-cat ( , context MODIFIER(*) ) }
  family Context-n+modifier            { entry: n-cat  ( , context MODIFIER(*) ) }

  family Event-np                      { entry: s<10>[T] : T:event(*) ; }  # given index T to allow adding nominal marcos
  
  # The ugliness here is due to the fact that semantically, the number from the owner
  # must be specified lexically, .i.e. 'mine' should have <Owner>( I ^ sg) and 'ours' <Owner>( I ^ pl)
  # Therefore the <Owner> must have the variable T, not the 'owned', and thus other features must
  # be specified here.
  # The two entries are do to the fact that every owned-np is ambigous between singular and plural 
  #	
  family Owned-np      { entry: np<16>[T2 s-sg CASE 3rd full]     :  T2:entity(context SG() <Owner>(T *) UNIQUE() SPECIFIC );
                         entry: np<16>[T2 s-pl CASE 3rd full]     :  T2:entity(context PL() <Owner>(T *) VARIABLE() UNSPECIFIC() ); }

  # This is really a determiner, but the dictionary macro 'pronoun' below uses this, and dets have been defined yet...
  #
  family Owner-pro     { entry: np<~16>[T2 3rd] /^ n<16>[T2 s-sg]      :  T2:entity( <Owner>(T *) SG() UNIQUE() SPECIFIC()       );
                         entry: np<~16>[T2 3rd] /^ n<16>[T2 s-pl-sp]   :  T2:entity( <Owner>(T *) PL() UNIQUE() SPECIFIC()       ); 
                         entry: np<~16>[T2 3rd] /^ n<16>[T2 s-pl-unsp] :  T2:entity( <Owner>(T *) PL() UNIQUE() UNSPECIFIC()     ); }

  # Negation and Coordination #  

  family Negation-np-(indexRel=polarity)  { entry:  from-np() \ np() :  ENTITY( NEG()  )   ;}
  family Coord-np-       { entry:  np(COM=yes) / np[N]  \* np[F COM=no]   : T( * <First>(F) ^ <Next>(N) ) ;}
  family Coord-n-        { entry:  n(COM=yes)  / n[N]   \* n[F COM=no]    : T( * <First>(F) ^ <Next>(N) ) ;}


###########
## RULES ##
###########

	
  # These essentially act as determiners, turning plural and mass nouns into np 
  # with the appropriate semantic marking
  
  rule { typechange: n(s-pl-unsp)     =>  from-np(3rd)       :  ENTITY( VARIABLE() UNSPECIFIC() ) ; } 
 # rule { typechange: n(s-pl-sp)       =>  from-np(3rd)       :  ENTITY( VARIABLE() SPECIFIC() ) ; }
 # rule { typechange: n(s-mass)        =>  from-np(3rd s-sg)  :  ENTITY( VARIABLE() UNCOUNTABLE() ) ; } 

  # This rule is for handling Compound Nouns. It turns any random noun into a pre-n modifier 
  # The two nominals are marked with the appropriate CC-TYPE values allowing the restriction 
  # of, e.g. 'the left ball' as compound (see types-word-classes.ccg)

  # NOTE: Could (should?) extend this idea for handling multi-word expressions...
    
  rule { typechange: n[T2 full compound-1st]     =>  from-n(cc-none) /* n(compound-head)  :  ENTITY( <Compound>(T2) ) ; } 

  
#######################
## DICTIONARY FORMS  ##
#######################

  # Basic nouns, regular and irr
  #
  def  noun(sing, class, args)       {  noun-irr(sing, pluralize(sing), class, args) }
  def _noun(prd, sing, class, args) { _noun-irr(prd, sing, pluralize(sing), class, args) }
  
  def  noun-irr (sing, plur, class, args) { _noun-irr(sing, sing, plur, class, args) } 
  def _noun-irr(prd, sing, plur, class, args) {
    word sing.-noun-n:Noun(class, pred=prd) {
      sing :  s-sg full args;
      plur :  s-pl-unsp full args;
    }
  }
  

  # Basic nouns with argument (of-np or of-n) , regular and irr
  #
  def  noun+(arg, sing, class, args)      {  noun-irr+(arg, sing, pluralize(sing), class, args) }
  def _noun+(arg, prd, sing, class, args) { _noun-irr+(arg, prd, sing, pluralize(sing), class, args) }

  def  noun-irr+(arg, sing, plur, class, args) { _noun-irr+(arg, sing, sing, plur, class, args) }
  def _noun-irr+(arg, prd, sing, plur, class, args) {
   word sing.-noun-n-.arg:"Noun+".arg."-" (class, pred=prd) {
      sing :  s-sg full args;
      plur :  s-pl full args;
    }
  }

  def  noun+of-n(sing, class, args)      {  noun-irr+of-n(sing, pluralize(sing), class, args) }
  def _noun+of-n(prd, sing, class, args) { _noun-irr+of-n(prd, sing, pluralize(sing), class, args) }

  def  noun-irr+of-n(sing, plur, class, args) { _noun-irr+of-n(sing, sing, plur, class, args) }
  def _noun-irr+of-n(prd, sing, plur, class, args) {
   word sing.-noun-n-of-n:Noun+of-n(class, pred=prd) {
      sing :   s-sg full args;
      plur :   s-pl full args;
    }
  }
  
  # Others
  
  def  noun-mass(form, class, args) { _noun-mass(form, form, class, args) }
  def _noun-mass(prd, form, class, args) {
    word form.-mass-n : Noun(class, pred=prd) {
      form  :  s-mass  full args;
    }
  }

  def name(form, class, args) { _name(form, form, class, args) }
  def _name(prd, form, class, args) {
    word form.-name:Bare-np(class, pred=prd) {
      form :  s-sg 3rd full args;
    }
  }
 
  def pronoun(prd, pers, num, nom-form, acc-form, owner, owned, class,) {
    word prd.-pro-.pers-.num:Bare-np(class, pred=prd) {
      nom-form :  pers s-.num nom pro num;
      acc-form :  pers s-.num acc pro num;
    }
    word prd.-owner-.num:Owner-pro('entity', pred=prd) {
      owner : num ;
	}
    word prd.-owned-.num:Owned-np('entity', pred=prd) {
      owned : num ;
	}
  }


 # I said THAT, I didn't do IT, etc. 
 #
 def context-s(form, args) {
    word form.-deictic-pro-event : Event-np ('event', pred=context) {
      form : fin-deictic m-class-none s-dependent args;    
    }
 }

 # Context nouns and context nouns + modifiers (e.g. those three, the red, etc)
 # are set to c-class n-4, meaning they can't interact with the n-n compound rule
 # this blocks stupid readings for  'three balls' and for 'room 3'  
 #
 def context-n(form,class, args) {_context-n(form, form, class, args)}
 def _context-n(prd, form, class, args) {
    word form.-context-n : Noun (class, pred=context) {
      form : args nf-ctxt n-4;    
    }
 }

 # I don't want ONE. Given context pred
 #
 def context-np(form,class, args) {_context-np(form, form, class, args)}
 def _context-np(prd, form, class, args) {
    word form.-context-np : Bare-np (class, pred=context) {
      form : 3rd args nf-ctxt;    
    }
 }

 def context-n+modifier(form,class, args) {_context-n+modifier(form, form, class, args)}
 def _context-n+modifier(prd, form, class, args) {
    word form.prd.-context-n+modifier : Context-n+modifier (class, pred=prd) {
      form : args nf-ctxt n-4;    
    }
 }

 def context-np+modifier(form,class, args) {_context-np+modifier(form, form, class, args)}
 def _context-np+modifier(prd, form, class, args) {
    word form.prd.-context-n+modifierp : Context-np+modifier (class, pred=prd) {
      form : 3rd args nf-ctxt;    
    }
 }

  # Taken directly from Ben and Jasons' tiny.ccg grammar
  # also used for third person present verbal forms (see verbs.ccg)
  # 
  def pluralize(word) {
    ifmatch('^.*[aeiou][oy]$', word, word . s,
      ifmatch('^.*([sxoy]|sh|ch)$', word, regsub('^(.*)y$', '\1i', word) . es,
              word . s))
  }

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def adj(args)         { adj<25>[M DEGREE args] }
  def from-adj(args)    { adj<~25>[M args] }
	
  def nid(args)			{nid<~25>[M args] }

##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def adj-cat(args, sem)   { adj() args  :  M(* sem) }
  
  ## The Families ##

  family Adj                         { entry:  adj-cat(,) ;}
  family Adj+of-np                   { entry:  adj-cat( / obl_ma(of,), ARG() ) ;}
  
  ## Modifiers ##
  
  family Mod-pre-adj-                { entry:  from-adj() /^ adj()                :  M( M-MOD(*) ) ;}
  family Mod-pre-adj-comparative-    { entry:  from-adj() /^ adj(s-comparative)   :  M( M-MOD(*) ) ;}
  
  family Mod-post-adj-               { entry:  from-adj() \ adj()                 :  M( M-MOD(*) ) ;}
    
  family More-adj(indexRel=degree)   { entry:  from-adj(s-comparative)  / adj(s-degree-base)   ;}
  family Most-adj(indexRel=degree)   { entry:  from-adj(s-superlative)  / adj(s-degree-base)   ;}
  
  family Adj-er-than                 { entry:  from-adj() / np_ma() \* adj(s-comparative) : M( M-MOD(* ARG() )  ) ;}

  ## Negation and Coordition ##
  
  family Negation-adj-(indexRel=polarity)  { entry:  from-adj() \ adj() :  M( NEG()  ) ;}
  family Coord-adj-                  { entry:  adj[R COM=yes] / adj[N] \* adj[F COM=no] : COORD(*) ;}


###########
## RULES ##
###########

  # The following rule converts the 'base-generated' atomic cat versions of adjectives into
  # their complex-cat form (i.e. the form that actually attach to and modify nouns)

  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() )
  # categories used in these rules  

  rule { typechange: adj(pre-n)$1  =>  pre-n(, $1) :  ENTITY( MODIFIER() ) ; } 
  
  rule { typechange: nid(post-n)$1  =>  post-n(, $1) :  ENTITY( MODIFIER() ) ; } 
  
  
#######################
## DICTIONARY FORMS  ##
#######################

  def _adj-none(prd, base, class, args) {
    word base.prd.-adj:Adj(class, pred=prd) {
      base : s-degree-base args;
    }
  }
  def adj-none(base, class, args) { _adj-none(base, base, class, args) }

  def _adj-deg(prd, base, comp, sup, class, args) {
    word base.-adj:Adj(class, pred=prd) {
      base : s-degree-base pre-n args;
	  comp : s-comparative pre-n comparative args;
	  sup  : s-superlative pre-n superlative args;
    }
  }
  
  def adj-deg(base, comp, sup, class, args) {_adj-deg(base, base, comp, sup, class, args) }


  	 
  
  
  
  
  # Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains the stuff necessary for determiners, both those
# handled via features only (a, the, some, this, that) and those
# with a semantic head (two balls, every ball, etc)
# These are called Dets & SDets respectively

# It also contains the stuff for handling:
#  1) semantic groups like 'some of the balls over there' or 'the first of GJ's mugs'
#  2) the possessive 's .
#  3) identifying number like 'floor 3'

# Possessive pronouns have been handled in the pronoun dictionary-macro
# located in noun.ccg (this is due to ordering issues)
  
##########################
## SEMANTIC DEFINITIONS ##
##########################

  def GROUP(sem)  { A( <Subgroup>(T:entity ^ subgroup ^ sem) ) }
  # this replaces def GROUP(sem) { ENTITY(group <Set>(A) sem) }
     
##############
## FAMILIES ##
##############

  family Det(indexRel=Delimitation)        { entry: from-np(3rd) /^ n()                   ;}
  family Group-np(indexRel=Delimitation)   { entry: np<15>[A] /^ obl_ma(of, s-pl)    : GROUP  () ;}
  
  family SDet                              { entry: from-np(3rd) /^ n()              : ENTITY ( MODIFIER(*) ) ;}
  
  family SGroup-np                         { entry: np<15>[A full 3rd s-pl]    /^ obl_ma(of, s-pl) : GROUP  ( MODIFIER(*) ) ;}
  
  # used for 'all the balls', c.f. 'all of the balls'
  #
  family SGroup-np-no-of                   { entry: np<15>[A full 3rd s-pl]    /^ np_ma(s-pl)      : GROUP  ( MODIFIER(*) ) ;}
  

  # Words like ordinal numbers change plurals from unspecific to specific. For incrementality's sake, this is done
  # only syntactically. the semantic feature is set by the "real" determiner, e.g. 'THE three balls' or rule, e.g. 
  # the 'bare plural rule' in "I see three balls" c.f. (I see balls) defined in noun.ccg. In many senses then, these
  # words are just a special type of adjective.
  #
  family Un-to-Spec-Det                    { entry: from-n(s-pl-sp) /^ n(s-pl-unsp)  : ENTITY ( MODIFIER(*) ) ;}
  family SGroup-n                          { entry: n<15> [A full s-pl-sp]     /^ obl_ma(of, s-pl) : GROUP  ( MODIFIER(*) ) ;}

  family Det-poss-s(indexRel=Owner)        { entry: from-np()    /^ n() \* np[O]     : ENTITY (<Owner>(O) )    ;}   

  # cardinal numbers (one, two, three) are used in many ways (see the def macro number in closed dictionary)
  # this is an entry used in the immediately following rule to handle, e.g. 'floor 3', 'office 101', etc.
  # It functions as a determiner, taking a noun and turning it into an 'Id'd specific, singular np.
  # 
  family Number-id      { entry: nid<16>[M] : M(*) ; }
  
  # ****** This is NOT INCREMENTAL, i.e. 'go to floor' doesn't parse, but 'go to floor 3' does.
  # This should be converted to a rule which turns n's into np's wanting a following number
  # HOWEVER, b/c this rule was added mid-devil, I didn't want to add a generally applicable rule!
  
 # rule { typechange: nid[M]  =>  from-np(3rd) \* n(s-sg) :  ENTITY( <Modifier>(M) SPECIFIC() SG() UNIQUE() ) ; }


#######################
## DICTIONARY FORMS  ##
#######################

  def det(form, args) {
      word form.det: Det {
        form : args;
      }
   }
  
  def group-np(form, args) {
      word form.group-np: Group-np {
        form : s-pl args;
      }
   }
  
  
  def sdet(form, class, args) { _sdet(form, form, class, args) }
  def _sdet(prd, form, class, args) {
      word form.prd.sdet: SDet(class, pred=prd) {
        form :  args;
      }
   }
  
  
  def un-to-spec-det(form, class) { _un-to-spec-det(form, form, class) }
  def _un-to-spec-det(prd, form, class) {
      word form.prd."un-to-spec": Un-to-Spec-Det(class, pred=prd) {form;}
   }
  
  
  def sgroup-np(form, class, args) { _sgroup-np(form, form, class, args) }
  def _sgroup-np(prd, form, class, args) {
      word form.prd.sgroup-np: SGroup-np(class, pred=prd) {
        form : s-pl args;
      }
   }

  
  def sgroup-np-no-of(form, class, args) { _sgroup-np-no-of(form, form, class, args) }
  def _sgroup-np-no-of(prd, form, class, args) {
      word form.prd.sgroup-np-no-of: SGroup-np-no-of(class, pred=prd) {
        form : s-pl args;
      }
   }
  
  def sgroup-n(form, class, args) { _sgroup-n(form, form, class, args) }
  def _sgroup-n(prd, form, class, args) {
      word form.prd.sgroup-n: SGroup-n(class, pred=prd) {
        form : args;
      }
   }
  
  def  number-id (form) { _number-id(form,form) } 
  def _number-id(prd, form) {
      word form."-number-id": Number-id("number-id", pred=prd) { form; }
    }
  
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def pp(args)            { pp<25> [M MOD-TYPE CC-TYPE args] }
  def from-pp(args)       { pp<~25>[M args] }

  # A preposition is a prep-phrase (pp) wanting a np argument
  # This np is marked as 'case' acc-both which means it allows 'there' and 'here'
  # so, 'on here' and 'under there' both parse.
  #
  def prep(p-arg, np-arg)      { pp(p-arg) /^ np_ma(np-arg acc-both) }
  def prep+obl(p-arg, obl-arg) { pp(p-arg) /^ obl_ma(obl-arg, acc-both) }

  def from-prep(p-arg, np-arg) { from-pp(p-arg) /^ np_ma(np-arg acc-both) }
  def from-prep+obl(p-arg, obl-arg) { from-pp(p-arg) /^ obl_ma(obl-arg, acc-both) }

 
##############
## FAMILIES ##
##############

  # Currently, there are three semantically subcategorized versions of preps
  # those with physical anchors (under the table), time unit anchors (for five minutes)
  # and region anchors (to your right)
  
  ## The Families ##

  family Prep             { entry:      prep(,)           :  M(* <Anchor>(A:physical) ) ;}
  family Prep+of-np-      { entry:      prep+obl(, of)    :  M(* <Anchor>(A:physical) ) ;}
  family Prep+to-np-      { entry:      prep+obl(, to)    :  M(* <Anchor>(A:physical) ) ;}
  family Prep+from-np-    { entry:      prep+obl(, from)  :  M(* <Anchor>(A:physical) ) ;}
  family Prep+no-arg-     { entry:      pp()              :  M(*)        ;}
 
  family Prep--time-unit  { entry:      prep(,)           :  M(* <Anchor>(A:e-time-unit) ) ;  }
  
  family Prep--region     { entry:      prep(, Questionable=no)           :  M(* <Anchor>(A:e-region) ) ;  }
    # NOTE: blocked from being questionable, so that 'what is the ball to' doesn't parse...
 	   
  # Modifiers #
   
  family Mod-pre-prep-   { entry:  from-pp() /^ pp()   :  M( M-MOD(*) ) ;}
  family Mod-post-prep-  { entry:  from-pp() \ pp()    :  M( M-MOD(*) ) ;}
    
  # Negation and Coordition #
  
  family Negation-prep-(indexRel=polarity)  { entry:  from-pp() \ pp()             :  M( NEG() )  ;}
  family Coord-prep-                        { entry:  pp<~51>[R COM=yes] /^ pp<~51>[N] \* pp<51>[F COM=no] :  COORD(*)    ;}  

###########
## RULES ##
###########

  # The following rules convert the 'base-generated' atomic cat versions of pps and turns them
  # into their complex-cat form (i.e. the form that actually attach to and modify nouns and sentences)
  # Remember, this combinatorial capacity is specified in the actual dictionary entry of the word
  # by assigning it to a particular cc-class
 
  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() ) categories
  # used in these rules  
	    
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT: If either the dependency relation name (e.g. <Modifier> ) or the
  #            modifier section of the ontological hierarchy is changed, you will have to add
  #            a new 'instance' of these rules for each.
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  ## Nominal Modifiying Rules ##
 
  # All preps which can modify nouns, post-modify them ( 'the ball on the table', not 'the on the table ball')
  #
      rule { typechange: pp(post-n2)$1        =>     post-n2($1)   :  ENTITY( MODIFIER() ) ; }


  ## Sentential Modifying Rules ##
  #
  # For each of the many sentential/clausal possibilities for prepositions, their is a corresponding rule.
  # MODIFIED BY PLISON

  #    rule { typechange: pp(pre-s2)$1           =>   pre-s2($1)         :  EVENT( MODIFIER() ) ; } 
  #    rule { typechange: pp(pre-vp2)$1          =>   pre-vp2($1)        :  EVENT( MODIFIER() ) ; } 
      rule { typechange: pp(post-s2)$1          =>   post-s2($1)        :  EVENT( MODIFIER() ) ; } 
  #    rule { typechange: pp(post-vp2)$1         =>   post-vp2($1)       :  EVENT( MODIFIER() ) ; } 

  
   
  ### Other Rules ###
  
  # These rules handle 
  # 1) nested locationals such as 'It is in the room on the table'
  #    c.f.   get me the ball on the table
  #    Note that this does not give the underlying semantics  (ball on table, table in room) but must be
  #    built grammar externally. This was due to problems in incrementally building 
  #   'inside out' semantic structures like this. 
  #
  # 2) sequences of dynamics: go into the hall, down the corrider ....
  # 


 #  rule { typechange: pp<52>[F x-dynamic CC-TYPE:CC-TYPE COM=no]   =>    pp<53>[R x-dynamic CC-TYPE:CC-TYPE COM=yes] /^   pp<54>[N x-dynamic CC-TYPE:CC-TYPE]  
 #                                                                 : R:m-dynamic( list <First>(F:m-dynamic) ^ <Next>(N:m-dynamic) ) ; }

 #  rule { typechange: pp<52>[F x-location CC-TYPE:CC-TYPE COM=no]   =>   pp<53>[R x-location CC-TYPE:CC-TYPE COM=yes] /^  pp<54>[N x-location CC-TYPE:CC-TYPE] 
 #																   : R:m-location( list <First>(F:m-location) ^ <Next>(N:m-location) ) ; }



	   
#######################
## DICTIONARY FORMS  ##
#######################
 
 ## For Prepositions with Physical Anchors
 ##
 def _prp(prd, form, class, args) {
    word form.-prep-.class :Prep(m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp(form, class, args) { _prp(form, form, class, args) }

 ##   
 def _prp+(arg, prd, form, class, args) {
    word form."-prep+".arg."-".class :"Prep+".arg."-" (m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp+(arg, form, class, args) { _prp+(arg, form, form, class, args) }

 ### With degrees (closer to, farthest from)
 #
 def _prp-deg+(arg, prd, form, comp, sup, class, args) {
    word form."-prep-deg+".arg."-".class :"Prep+".arg."-" (m-.class, pred=prd) {
      form : x-.class args;
	  comp : x-.class comparative args;
	  sup : x-.class superlative args;

    }
  }

 def prp-deg+(arg, form, comp, sup, class, args) { _prp-deg+(arg, form, form, comp, sup, class, args) }

 def _prp-deg(prd, form, comp, sup, class, args) {
    word form."-prep-deg".class :Prep(m-.class, pred=prd) {
      form : x-.class args;
	  comp : x-.class comparative args;
	  sup : x-.class superlative args;
    }
  }
 def prp-deg(form, comp, sup, class, args) { _prp-deg(form, form, comp, sup, class, args) }


 ## For prepositions with subcategorized Anchors
 ##
 def _prp--(subsort, prd, form, class, args) {
    word form.-prep-.class.subsort :"Prep--".subsort(m-.class, pred=prd) {
      form : x-.class args;
    }
  }
 def prp--(subsort, form, class, args) { _prp--(subsort, form, form, class, args) }

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def adv(args)         { adv<25>[M DEGREE args] }
  def from-adv(args)    { adv<~25>[M args] }

##############
## FAMILIES ##
##############

  ## Family Building Macros ##
  	
  def adv-cat(args, sem)   { adv() args  :  M(* sem) }
  
  ## The Families ##

  family Adv                { entry:  adv-cat(,) ;}
  family Adv+dep-clause-    { entry:  adv-cat( / s_ma(s-dependent MARK=none), E-ARG() ) ;}
  
  # These handle, e.g. I will watch you 'while working at my desk'.
  # b/c typechange rules don't seem to allow a co-indexing of source and target sub-structures 
  # (here the subject), these are not build using a basic cat, but directly.
  #
  family Adv+verb-ing-      { entry:  post-vp( MCLASS , / (s_ma(ing) +subj() ) )     : EVENT( <Modifier>(M * E-ARG() ))  ;}
  family Adv+verb-base-     { entry:  post-vp( MCLASS , / (s_ma(vf-base) +subj() ) ) : EVENT( <Modifier>(M * E-ARG() ))  ;}

  # Modifiers #
  
  family Mod-pre-adv-                { entry:  from-adv() /^ adv()   :  M( M-MOD(*) ) ;}
  family Mod-post-adv-               { entry:  from-adv() \ adv()    :  M( M-MOD(*) ) ;}
    
  # Negation and Coordition #
  
  family Negation-adv-(indexRel=polarity)  { entry:  from-adv() \ adv() :  M( NEG()  ) ;}
  family Coord-adv-                        { entry:  adv[R COM=yes] / adv[N] \* adv[F COM=no] : COORD(*) ;}

###########
## RULES ##
###########

 
  # The following rules convert the 'base-generated' atomic cat versions of advss and turns them
  # into their complex-cat form (i.e. the form that actually attach to sentences/clauses/verbs)
  # Remember, this combinatorial capacity is specified in the actual dictionary entry of the word
  # by assigning it to a particular cc-class
 
  # see modifiers.ccg for the syntactic ( post-n(), pre-s(), etc ) and semantic ( MODIFIER() ) categories
  # used in these rules  
 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT: If either the dependency relation name (e.g. <Modifier>  ) or the
  #            modifier section of the ontological hierarchy is changed, you will have to add
  #            a new 'instance' of these rules for each.
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  # Sentential Modifying Rules #
  #
  # For each of the many sentential/clausal possibilities for adverbs, their is a corresponding rule.

    rule { typechange: adv(pre-s2)$1           =>   pre-s2($1)         :  EVENT( MODIFIER() ) ; } 
    rule { typechange: adv(pre-vp2)$1          =>   pre-vp2($1)        :  EVENT( MODIFIER() ) ; } 
   
  #  rule { typechange: adv(post-s2)$1          =>   post-s2($1)        :  EVENT( MODIFIER() ) ; } 
  #  rule { typechange: adv(post-vp2)$1         =>   post-vp2($1)       :  EVENT( MODIFIER() ) ; } 
  
	# HACK (see modifier.ccg)
  #  rule { typechange: adv(pre-vp2)$1          =>   pre-vp-in-rel-clause($1)        :  EVENT( MODIFIER() ) ; } 
   
	
    mod-rule-pre-cop2 ( adv(pre-cop-comp2) , $1, EVENT( MODIFIER() )   )
	
    #  rule { typechange: adv(post-s-loose2)$1   =>   post-s-loose2($1)  :  EVENT( MODIFIER() ) ; } 


#######################
## DICTIONARY FORMS  ##
#######################

 def adverb(base, class, cc-class, args)  { _adverb(base, base, class, cc-class, args) } 
 def _adverb(prd, base, class, cc-class, args) {
    word base.-adv:Adv("m-".class, pred=prd) {
      base : s-degree-base x-.class cc-class args;
    }
  }

 def adverb-deg(base, comp, sup, class, cc-class, args) { _adverb-deg(base, base, comp, sup, class, cc-class, args)}
 def _adverb-deg(prd, base, comp, sup, class, cc-class, args) {
    word base.-adv-deg:Adv("m-".class, pred=prd) {
      base : s-degree-base x-.class cc-class args;
	  comp : s-comparative x-.class cc-class comparative args;
	  sup  : s-superlative x-.class cc-class superlative args;
    }
  }

 # for those adverbs with arguments (now only dep-clause)
 #
 def adverb+(arg, form, class, cc-class, args) {_adverb+(arg, form, form, class, cc-class, args) } 
 def _adverb+(arg, prd, form, class, cc-class, args) {
    word form."adv+".arg : "Adv+".arg."-"("m-".class, pred=prd)
	{form : x-.class cc-class args;}
  } 

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# The mood of a clause is projected as early as possible. i.e. we don't wait for the verb.
# Instead, the first 'core' element of the clause does this
#   Indicative: a free standing, clause initial NP
#   Imperative: a base form verb wanting a subject (see below for dropped subjects)
#   Interrogative: auxillaries in Y/N & Wh-words in Wh cases
#                 (see udc.ccg , verb-finite.ccg and verb-copula.ccg for more)  
# See documentation for more information.

# This file contains the mood rules for:
#    1) indicatives 
#          -standard: I gave the ball to GJ
#          -fronted object: the mug I took myself but 'the ball I gave to GJ'
#          - ellided subject:  I walked in  'gave the ball to GJ'
#    2) standard positive imperatives: 'come here' 
#    3) and dependent clauses: I said that 'I wanted it'


  def SUBJECT(args)         { <Subject>(S:entity args) }

  rule {
    
     no typeraise;  # b/c rules handle the building of standard indicative and subordiante clauses, no need for type-raise
                    # (from another perspective, the rules below at semantics to this standard syntatic rule)

     no sub;        # THIS ADDED TO KILL STUPID COLLAPSED ARG READINGS 'put this on the table' with this & table co-indexed.
  
  
     # These rules create indicative clauses out of any old NP, either as the subject (in Systemic Functional Grammar sense)
     # or as a Fronted-object as in 'this one I dont like'
     #   
     typechange: subj() $1     => 
                 from-s(s-ind ) /  ( s(VFORM:fin-clause s-minor) +subj() )  $1   
                 : EVENT( IND() SUBJECT() )             ; 
    
  #   typechange: np<12>[F acc nf-real] $1    =>
  #               from-s(s-ind)  /  ( s(VFORM:fin-clause s-minor) +subj(nf-real) / np<12>[F]) /^ subj()  $1 
  #               : EVENT( IND() SUBJECT() <Fronted>(F) ); 
    
     # this rule creates a dependent, moodless clause with MOOD=s-dependent (the form mimics that of ind above)
     # It can be marked by 'that', 'if', 'whether', etc or not as in 'I hope you come'
     #
   #  typechange: subj() $1  =>  
   #              from-s(s-dependent ) /  ( s(VFORM:fin-clause s-minor) +subj() )  $1      
   #              : EVENT( SUBJECT() ) ;
     
   } # end rule

   # These rules turn verbs wanting subjects into 1) imperatives and 
   #                                              2) verbs with contextually 'ellighted' (i.e. dropped) subjects
   # In verbs.ccg, each family makes a 'call' to this rule, creating a separate rule for that argument 
   # structure/configuration 
   # 
   def imp-rule(args){ 
        rule { typechange: s(vf-to-imp) +subj(nf-real) args     =>
                           from-s(fin-full s-imp) args      : EVENT( IMP() SUBJECT(addressee) );  

 #             typechange: s(fin) +subj(nf-real) args           => 
 #                          from-s(fin-ell s-ind-ell) args   : EVENT( IND() SUBJECT(context) )  ;    
             } 
   }						 

   def imp-set-rule(args){ 
        rule { typechange: s(vf-to-imp) +subj(nf-real) {args}     =>
                           from-s(fin-full s-imp) {args}      : EVENT( IMP() SUBJECT(addressee) );  

 #             typechange: s(fin) +subj(nf-real) {args}           => 
 #                          from-s(fin-ell s-ind-ell) {args}   : EVENT( IND() SUBJECT(context) )  ;    
             } 
    }						 
 
   # Modifications:
   # JULY 24  ADDED restriction that nf-real to block presentational, clefts, etc from getting contextualized missing 'dummy' subject readings
   # AUG  5   ADDED vf-to-imp value, this allows verbs to  lexically select whether or not they receive an imp 
   #                (see verb and verb-no-imp dictionary macros below)         
   #
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains everything necessary for standard verbs, and some
# special verbs (thanks, it is made out_of metal, etc), but not for the copula
# and aux/modal verbs.

# It also contains verbal and sentential coordination.

#################################
# VERB ARGUMENTS: SLOTS & ROLES # 
#################################

  # These are the syntactic slots and corresponding semantic roles
  # used for verbal arguments(compliments)
  
  # Semantic Role cats are, like all semantic cats, written in CAPS.
  
  # The general format for syn-cat names is type_slot# (args) for the bare compliment itself.
  # For the comp plus its slash, +type_slot# (args)
  
  # The slots are numbered based on their left to right position after the verb itself, so
  #	_SUBJ_	 VERB		_1_			_2_				_3_
                          
  # 1)	  I      slept  
  # 2)	  I      hit		the ball
  # 3)	  I      gave		him			the ball
  # 4)	  I	 gave		it			to  him
  # 5)	  I	 picked		it			up
  # 6)	  I	 put		it			on the table
  # 7)    I	 want								        to run
  # 8)	  I	 want		him                     				to run
  		 
  # As you can see, the slot position is independent of the category (or kind) of the compliment.
  # So in 3, 4, 5, 6 we have a NP, an OBLIQUE, a PARTICLE and a PP all in slot 3. Thus,
  # the variable name for a given syntactic argument is a combination of category and slot position:
  # Verb(vp) & Sentence comps are an exception, they are always in slot 3.. this was just a pragmatic
  # decision to avoid doubling all of the cats.

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #         Although there are no semantic constraints for entites (animacy, etc)
  #         some of these verb-roles are restricting for modifiers (where-to and location, e.g.)
  #         Changes to the modifier section of ontological hierarchy will need be reflected here
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  


  ## SUBJECT SLOT ##
  
    def ACTOR(args)     { <Actor>(S:entity args) }
  
  ## COMP SLOT 1 ##
  
    def np_1(args)           { np<2>[X acc args] }            def +np_1(args)          { / np_1(args) }
    def +np_1-subj(args)     { \ np<~2>[X nom] }  # this is for 'object-controlled vp comps' like 'I want him to get it'

    def obl_1(frm, args)     { obl<2>[X acc MARK=frm args] }  def +obl_1(frm, args)    { / obl_1(frm, args) }
    def adj_1(args)          { adj<2>[X args] }               def +adj_1(args)         { / adj_1(args) }
    def pp_1(args)           { pp<2>[X args] }                def +pp_1(args)          { / pp_1(args) } 
    def s_1(feats)           { s<2>[X feats] }                def +s_1(feats, args)    { / ( s_1(feats) args ) }
	   
    def PATIENT(args)        { <Patient>(X:entity args) }

    def INSTRUMENT(args)     { <Modifier>(M:m-instrumental ^ with <Arg>(X:entity args) ) }  # used in family for 'use'  you can use the coffee maker to make coffee'

  ## COMP SLOT 2 ##
   
    def np_2(args)           { np<3>[Y acc args] }            def +np_2(args)          { / np_2(args) }
    def +np_2-subj(args)     { \ np<~3>[Y nom] }  
    def obl_2(frm, args)     { obl<3>[Y acc MARK=frm args] }  def +obl_2(frm, args)    { / obl_2(frm, args) }
    def adj_2(args)          { adj<3>[Y args] }               def +adj_2(args)         { / adj_2(args) }
    def pp_2(args)           { pp<3>[Y args] }                def +pp_2(args)          { / pp_2(args) }
    def prt_2(args)          { prt<3>[Y args] }               def +prt_2(args)         { / prt_2(args) }

    def RECIPIENT(args)      { <Recipient>(Y:entity args) }
    def PARTICLE(args)       { <Particle>(Y args) }
	
    # These are all given dependecy <Result>, but have different semantic resrictions on their arg
    #
    def R-LOC(args)            { <Result>(Y:m-location args) }
    def R-WHERETO(args)        { <Result>(Y:m-dynamic args) }
    def R-QUALITY(args)        { <Result>(Y:quality args) }
	
    def R-MODIFIER(args)       { <Result>(Y:modifier args) }
    def R-ENTITY(args)         { <Result>(Y:entity args) }

 ## COMP SLOT 3 ## 

    def s_3(feats)              { s<4>[Z feats] }     
    def +s_3(feats, args)       { / ( s_3(feats) args ) }
    def +verb-subj-cont(feats)  { +s_3(feats, +subj() ) }
    def +verb-obj-cont(feats)   { +s_3(feats, +np_1-subj() ) }

    def ECOMP(args)          { <Event>(Z:event args) }


##############
## FAMILIES ##
##############

  #   There is currently an issue which must be resolved concerning extracting
  # of 'internal' arguments for verbs with multi arguments, e.g. questionging IT
  # in 'I put IT on the table'
  #   One possible solution is to use SETARG for all, but 
  # TYPE CHANGING RULES (here, imp-rules) DON'T WORK WITH SET-ARG (Jason confirmed this) 
  #   The current solution is to give two reading, i.e. /np/pp & /pp/np,
  # We get stupid double-bound readings for put on# (>S operator does it). This was
  # solved by shutting of sub rules ( by adding 'no sub;', see mood-rules.ccg)
  # Note, however, that this also leads to OVERGENERATION. We should eventually sort out
  # a way of 'blocking' these readings from combining via ind and imp rules. 
  # This could be done perhaps by adding another layer of mood features.


  #--------------------------------
  #---  Family Building Macros ----
  #--------------------------------
  
 
  def vcat(args, sem)             {  s(s-minor) +subj(nf-real)   args    : EVENT(* ACTOR() sem)  }
  def vcat-set(args, sem)         {  s(s-minor) +subj(nf-real) { args }  : EVENT(* ACTOR() sem)  } 
    # for those with sets of args, currently not used, see above

  # Creates a family with a single entry including given args and sem, plus creates relevant
  # mood rules (for imp and ellided subj) (see mood-rules.ccg)
  #
  def vfam(name, args, sem){ 
        
           family name (V)  { entry: vcat(args , sem);  }
           imp-rule(args)   
  }

  # In addition to its use in 'real' switchables (e.g. I picked up the ball, I picked the ball up)
  # giving verbs with multiple arguments  a second entry with inverted, or switched, ordering allows
  # 'extraction' of their patient np, e.g. for questioning. See above.
  #
  def vfam-swt(name, arg1, arg2, sem){ 
        
           family name (V)  {
               entry: vcat( arg1 arg2 , sem); 
               entry: vcat( arg2 arg1 , sem);
           }
           imp-rule(arg1 arg2)   
           imp-rule(arg2 arg1)   
  }

  # This is used for two entry families where only difference is the syn-cat of one argument
  # See, e.g. , v+dep-clause (that CLAUSE vs. CLAUSE )
  #
  def vfam-alt(name, arg1, arg2, sem){ 
        
           family name (V)  {
               entry: vcat ( arg1 , sem); 
               entry: vcat ( arg2 , sem);
           }
           imp-rule(arg1)   
           imp-rule(arg2)   
  }

  #------------------------------
  #--- The Standard Families ----
  #------------------------------
  
  vfam    ( iv              ,                   ,           )
  vfam    ( tv              , +np_1()           , PATIENT() ) 		
  vfam    ( v+Rec-np        , +np_2()           , RECIPIENT() )

  def vfam-obl(word){ vfam( "v+".word."-np"  ,   +obl_1(word,)   ,   PATIENT() ) }
   vfam-obl(of)
   vfam-obl(with)
   vfam-obl(for)
   vfam-obl(to)
   vfam-obl(from)
	  
  vfam    ( v+pp-whereto    , +pp_2()             , R-WHERETO()  )
  vfam    ( v+pp-loc        , +pp_2()             , R-LOC()      )
  vfam    ( v+pp            , +pp_2()             , R-MODIFIER()   )   
              		            
  vfam    ( v+adj           , +adj_2()            , R-QUALITY()   )  

  vfam-swt( v+np+prt        , +prt_2() , +np_1()  , PATIENT() PARTICLE() ) 								  
  vfam-swt( v+np+pp-whereto , +pp_2()  , +np_1()  , PATIENT() R-WHERETO() ) 
  vfam-swt( v+np+pp-loc     , +pp_2()  , +np_1()  , PATIENT() R-LOC()     )
  vfam-swt( v+np+adj        , +adj_2() , +np_1()  , PATIENT() R-QUALITY()   )

  vfam    ( dtv            , +np_1() +np_2()    , PATIENT() RECIPIENT()   )
  def vfam-dtv(word){ vfam-swt( "dtv-".word     ,   +obl_1(word,) , +np_2()  ,   PATIENT() RECIPIENT() ) }
   vfam-dtv(for)
   vfam-dtv(to)
  						     

  vfam    ( v+sent          , +s_3(fin,)                      , ECOMP()  )
  vfam-alt( v+dep-clause    , +s_3(s-dependant,) 
                            , +s_3(s-dependant MARK=that,)    , ECOMP()  )
  vfam    ( v+deictic-event , +s_3(fin-deictic,)              , ECOMP()  )
  vfam    ( v+verb-ing      , +verb-subj-cont(ing)            , ECOMP()  )
  vfam    ( v+verb-inf      , +verb-subj-cont(inf)            , ECOMP()  )


  vfam    ( v+np+sent       , +s_3(fin,) +np_1()                    , PATIENT() ECOMP()  )
  vfam-alt( v+np+dep-clause , +s_3(s-dependant,) +np_1()
                            , +s_3(s-dependant MARK=that,) +np_1()  , PATIENT() ECOMP()  )
  vfam    ( v+np+verb-ing   , +verb-obj-cont(ing) +np_1()           , PATIENT() ECOMP()  )
  vfam    ( v+np+verb-inf   , +verb-obj-cont(inf) +np_1()           , PATIENT() ECOMP()  )
  vfam    ( v+np+verb-base  , +verb-obj-cont(vf-base) +np_1()       , PATIENT() ECOMP()  )

  #-----------------------------
  #--- Specialized Families ----
  #-----------------------------
  

  # I made it from plastic, it is made of plastic, etc.
  # 
  def vfam-obl-result(word){ vfam-swt( "v+np+".word."-np-result" , +np_1(), +obl_2(word,) , PATIENT() R-ENTITY()   ) }
   vfam-obl-result(of)
   vfam-obl-result(from)
   vfam-obl-result(out_of)  
	  
  # you use this to pick up balls
  #
  vfam   ( v+instrumental-np+verb-inf , +verb-subj-cont(inf) +np_1()      , PATIENT() ECOMP( INSTRUMENT() )  )
  
  # thank you for helping me  
  #
  vfam   ( v+Rec-np+for-verb-ing      , +verb-obj-cont(for-ing) +np_1()   , RECIPIENT() ECOMP()              )   

  # don't be silly
  family imp-do(V)               { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity addressee) ) ;}
  family imp-lets(V)             { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity speaker+addressee) ) ;}

  family Thanks(V)  { entry: s(s-ind) +s_3(for-ing, \ np_2(nom) )  : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ECOMP() ) ;
                      entry: s(s-ind)                              : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ) ;  
                      entry: s(s-ind) +obl_1(for,)                 : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) PATIENT() ) ;  
  }

  ##################################
  ## VP & Sentential Coordination ##
  ##################################
    
  # First entry handles coordinated vps, i.e. subject controlled vp chains.
  # Every syn feature except for modifier class must be identical. If this weren't allowed to differ, 
  # couldnt handle I walked in and picked it up, cuz walk and pick have dif m-classes. 
  
  # NOTE: Open question: what should the m-class of the result be? 
  #          As it stands, we get multiple readings for all coordinated clauses involving modifiers,
  #          one with mod of 2nd conjunct, one with result
  
  # Second entry handles general sentence coordination. The conjuncts must be mooded-clauses, 
  # the result is of general s-major mood and 'fin' verb form (if you don't give it a verb form
  # then some rules will grap a hold of it and make silly readings (e.g. see rules around imperatives)
  #   NOTE: May 15 restricted these to being ind or int, not dropped subject ind (s-ind-ell) or imp.
  #         This is because we want those to be handled using the vp-chains. This reduces number of parses
  #         and looks more sexy, like Givon's(1995)   S[subj vp vp vp vp vp ...] treatment
		   
  def coord-s-entry(res, next, first) {
         entry:    s<10>[R res fin COM=yes] /^ s<11>[N  next fin  ] \* s<12>[F first fin COM=no]  : COORD(*) ;  
  } 

  family Coord-s-  { 
      entry:   ( s<10>[R VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=yes] +subj() ) 
                 / (s<11>[N VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS] +subj() ) 
	   	 \ (s<12>[F VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=no] +subj() ) : COORD(*) ; 
       coord-s-entry(s-ind, s-ind, s-ind)
       coord-s-entry(s-int, s-int, s-int)
       coord-s-entry(s-dependent, s-dependent, s-dependent)
       coord-s-entry(s-mood-mixed, s-ind, s-int)
       coord-s-entry(s-mood-mixed, s-int, s-ind)
       coord-s-entry(s-mood-mixed, s-int, s-imp)
       coord-s-entry(s-mood-mixed, s-ind, s-imp)
       coord-s-entry(s-ind, s-ind, s-ind)
   }

   # Added sept 18 to allow incremental parsing of coordinated imperatives. 
   #    go and ...  walk over there and ...
   # Is currently 'over generating' by also applying to pre-placable adverbs to receive
   # an 'imp waiting for verb' reading

   imp-rule ( / (s<11>[N VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS] +subj() ) )

#######################
## DICTIONARY FORMS  ##
#######################


  # This handles verbs which are perfectly regular ex. jump -> jumps, jumping, jumped (past), jumped (past participle)
  #
  def verb-reg(stem, mod, class, props)       {  verb(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg(prd, stem, mod, class, props) { _verb(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }

  # This handles verbs whose 3rd person present form is regular, but whose past and past particle aren't
  #
  def verb(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }

  # This handles irregular verbs, i.e. each form must be fully specified
  #
  def verb-basic(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.-verb-.class.mod:props(class, pred=prd) {
      stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
      3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
      stem:      mod fin-full pres s-pos do         s-pl  ;
      pasttense: mod fin-full past s-pos do               ;
      pastpart:  mod pp                                   ;
      ving:      mod ing                                  ;
      stem:      mod vf-base                              ;
      stem:      mod vf-to-imp                            ;   # This entry gets turned into an imp via rule (see above)

    }
  }

  # This set is identical but DOES NOT have a to-imp reading
  # Use these if you don't want this verb to receive an imperative reading.
  #
  #
  def verb-reg-no-imp(stem, mod, class, props)       {  verb-no-imp(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg-no-imp(prd, stem, mod, class, props) { _verb-no-imp(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def verb-no-imp(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic-no-imp(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb-no-imp(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic-no-imp(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def verb-basic-no-imp(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic-no-imp(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic-no-imp(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.prd.-verb-.class.mod:props(class, pred=prd) {
	  stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
          3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
          stem:      mod fin-full pres s-pos do         s-pl  ;
          pasttense: mod fin-full past s-pos do               ;
	  pastpart:  mod pp                                   ;
	  ving:      mod ing                                  ;
	  stem:      mod vf-base                              ;
    }
  }


 def adjectival-verb(stem, mod, class, props) {_adjectival-verb(stem, stem, mod, class, props) }
 def _adjectival-verb(prd, stem, mod, class, props) {
     word stem.-be-adj-to: props (class, pred=prd)
     {stem: vf-be mod;}
 }

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 
 
# This file contains the families for various markers, including
# nominal markers (obliques), verbal markers (infintival to) ,
# and dependent clause markers (that/if etc)

#########################
# Obliques (NP markers) #
#########################
 
   family NP-marker (indexRel="*NoSem*")     { entry: obl<~55>[T MARK=*] /^ np<55>[T CASE=acc NUM PERS] ; 
                                               entry: obln<~55>[T MARK=*] /^ n<55>[T NUM PERS] ; }

#####################
# Dep-clause markers  #
#####################
   
   # Should we add semantics??

   family Dep-clause-marker  { entry:  from-s(MARK= *) / s<10>[G s-dependent MARK=none]: EVENT( * <Scope>(G) ) ; }   
   family Dep-clause-marker-no-sem (indexRel="*NoSem*")   { entry:  from-s(MARK= *) / s(s-dependent MARK=none) ; }

#########################
# Infinitive Marking To #
#########################
  
   # Two Entries: 1st takes a vf-base vp and the second doesn't, adding context pred to this event 
   #       If this turns out to be too promiscous. Add another VFORM value  inf-ctxt, i.e. this
   #       allows whatever chooses inf vps to choose whether or not its inf can be contextualized
   #
   #
   family Infinitive-to (indexRel="*NoSem*") {  entry: ( from-s(inf) +subj() ) / ( s(vf-base) +subj() ) ; 
                                                entry: s(inf) +subj()          : EVENT(context)         ;   } 
   # I am ready for verb+ing   
   #
   family For-verb-ing     (indexRel="*NoSem*") { entry: ( from-s(for-ing) +subj() ) / ( s(ing) +subj() ) ; } 



  















  
 
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 
 
# This file contains the stuff for the copular and presentational 
# uses of 'be'. 

# NOTE: see modifiers.ccg for compliment and modifier definitions 
#       due to DotCCG ORDERING ISSUES, they had to be put there


##############
## FAMILIES ##
##############

  
  #---  Family Building Macros ----
  
  # These reduce redundancy of following families
  # Note that cop-sem doesnt include the <Cop-Scope>, this is added below
  # to allow the proper semantic subcategorization
  #
  def cop-sem(sem)  { EVENT(* <Cop-Restr>(S:entity) sem ) } 
  def pres-sem(sem) { EVENT(* <Presented>(S:entity) sem ) }

  def cop-entry(arg, sem){
  
       entry: s(s-minor) +subj(nf-real) arg      : cop-sem(                 sem )  ; # used in ind, imp, etc.
       entry: s(s-int) arg / subj(nf-real)       : cop-sem( INT() SUBJECT() sem )  ; # used in y/n-int
       entry: cop<10>[E] arg / subj(nf-real)     : cop-sem(       SUBJECT() sem )  ; # used in wh-int
  }
     # NOTE: doing (cop item) and allowing the cop entry to handle its own subject allows
     #      'who is he with', 'what is he on', i.e. the subject comes after the unit is built.
     # NOTE: this is NOT INCREMENTAL! (**sigh**)
 
   #---  Families ----

   family Copular(V){   
    
    # Need to sort out a way of having super semantic type 'm-mod-entity'
    # which will then be subspecified when filled in
    #
    cop-entry( +cop-pp()  , <Cop-Scope>(X:m-benefactor) )  
    cop-entry( +cop-pp()  , <Cop-Scope>(X:m-accompaniment) )  
    cop-entry( +cop-pp()  , <Cop-Scope>(X:m-comparison) )
  
    cop-entry( +cop-adj() , <Cop-Scope>(X:quality) )  
    
    # To avoid 'what is that' or 'what is a ball' getting 2 READINGS (in <Cop-Restr> and <Cop-Scope>), 
    # we must block the subj from being questionable for entity scopes
    #
    entry: s(s-minor) +subj(nf-real Questionable=no) +cop-np()    : cop-sem(                 <Cop-Scope>(X:entity) )  ; 
    entry: s(s-int) +cop-np() / subj(nf-real)                     : cop-sem( INT() SUBJECT() <Cop-Scope>(X:entity) )  ; 
    entry: cop<10>[E] +cop-np(no-q) / subj(nf-real)               : cop-sem(       SUBJECT() <Cop-Scope>(X:entity) )  ;   # USED IN OPEN-QUESTIONS
  }

  # A second family to control locational modifiers (i.e. I am hungry at work, but I am in the kitchen at work, will combine)
  #
  family Copular-location(V) { cop-entry( +cop-pp()  , <Cop-Scope>(X:m-location) ) }
 
 		
  family Presentational(V){

       entry: s(s-minor) \! np[D dummy-there] / subj()         : pres-sem(                      );
       entry: s(s-int)/ subj() / np[D dummy-there]             : pres-sem( INT() ^ <Subject>(D) ); 
       entry: cop<10>[E] / subj() / np[D dummy-there]          : pres-sem(         <Subject>(D) );
  } 
									   
  family Presentational-inverted(V){ 
       
       entry: s(s-ind) / subj(nf-real) \ pp_1(CC-TYPE:post-n)  : pres-sem( IND() ^ <Modifier>(X:m-location) )  ;
  }

 family Cop-negation (indexRel=Polarity) {
      
      entry: pre-cop-pp  (s-neg, s-prov-pos, )  ;  # This syn-cat is defined in modifiers.ccg
      entry: pre-cop-np  (s-neg, s-prov-pos, )  ;
      entry: pre-cop-adj (s-neg, s-prov-pos, )  ;
  }					

####################################
# Wh-Interrogatives and the Copula #
####################################
 
  # The actual wh-cats are built in udc.ccg, i.e.
  # the resquired entries are added to appropriate wh families defined there

  # Questioning the <Cop-Scope>
  # 
  def wh-copular-entry(item, syn, sem)  {
  	  entry: from-s(s-int)  /^ ( cop<10>[E] item  ) syn
                 : E:state( INT() <Wh-Restr>(sem) ); 
  } 

  # Handling Questions like 'when were you big' and 'where was there a ball',
  # i.e. 's-modifier questions' for copula and presentational
  #
  def be-wh-sent-mod-entry(item){
       entry: from-s(s-int) item  /^ subj() / vp-extr(be, item )
            : E:state( INT() SUBJECT() WH-RESTR(V * <Scope>(E:event)) ); 
  }
 
  def be-wh-sent-mod-entries(){
     be-wh-sent-mod-entry( +cop-pp() ) 
     be-wh-sent-mod-entry( +cop-adj() ) 
     be-wh-sent-mod-entry( / np() )    # either predicative np or presented

  }

 # Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 
 
# This file contains the stuff for: 
#    1) auxillaries : do, have, be (as progr, passive and predictival verb)
#    2) modals      : can, should, will, etc.

###########################
## SYNTACTIC DEFINITIONS ##
###########################

  def aux(args)           { aux<11>[E NUM:NUM PERS:PERS VFORM:VFORM FIN:FIN POL:POL args] }

##############
## FAMILIES ##
##############

  #  NOTE: currently, contextualized predicates (e.g. I am, I can, can you, etc)
  #        are restricted to m-class-4. 
  #        This SHOULD be taken out (c.f. A: are you running? B: yeah 'I am, on the table'
  #        but now done to block getting such readings (instead of just copular reading)
  #

  #--------------------------------
  #---  Family Building Macros ----
  #--------------------------------

  # With semantics, i.e. <Modifier> (see modal family below)
  #
  def fin-entry+sem(arg, sem){
      
      entry:  ( s(fin-full MCLASS:MCLASS POL:POL) +subj() ) 
	   /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=arg] +subj() )  : EVENT(sem);  
      entry:  s(fin-ctxt m-class-4 POL:POL) +subj()                 : EVENT(context sem) ;	  
	 
      entry: aux( VFORM=arg)                                        : EVENT(sem) ;
      
      entry: from-s( s-int fin-full) / ( s(arg) +subj() ) /^ subj() : EVENT(INT() SUBJECT() sem) ;              
      entry: s( s-int m-class-4 fin-ctxt) /^ subj()                 : EVENT(INT() SUBJECT() context sem) ;              
  }

  ## With no semantics, must separate Y/N indicatives from others because 
  #  only finite forms of auxs receive this i.e. I have BEEN sleeping but not BEEN I sleeping
  #
  def fin-entry-no-int(arg){
  
      # indicative, with vp and context    
      #  
      entry:    ( s(fin-full MCLASS:MCLASS POL:POL) +subj() ) 
	     /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=arg] +subj() )       ; 
      entry:  s(fin-ctxt m-class-4 POL:POL) +subj()	  : EVENT(context) ;
      
      # aux cat used (selected) by, e.g. wh-questions
      #   
      entry: aux( VFORM=arg)      ; 
		  
  }

  def fin-entry(arg){
  
      fin-entry-no-int(arg)
  
      # the Y-N question versions: with vp and context ##
      #
      entry: from-s( s-int fin-full ) / ( s(arg) +subj() ) /^ subj()  : EVENT(INT() SUBJECT() ) ;              
      entry: s( s-int m-class-4 fin-ctxt) /^ subj()		      : EVENT(INT() SUBJECT() context) ;              
  }

  # For Passives
  #
  # In theory could create rule which changes passive vp's into vp / by-subj
  # this would require a syntactic voice feature 
  # This may be attractive cuz right now we're gonna need to duplicate this in Wh-forms anyway.. sigh.
  
  def pass-ind()       { ( s(fin-full MCLASS:MCLASS POL:POL) \! np[X] ) /^ ( s<14>[E MCLASS:MCLASS POL:POL VFORM=pp] +subj() / np[X] )  }
  def pass-yn()        { s(fin-full s-int) / ( s<14>[E VFORM=pp] \! np[S] / np[X] ) /^ np<9>[X NUM:NUM PERS:PERS nom]  }  	   
 
  def pass-ind-by()    { ( s(fin-full MCLASS:MCLASS) \! np[X] ) /^ obl[S MARK=by] /^ ( s<14>[E MCLASS:MCLASS VFORM=pp] +subj() / np[X] )    }
  def pass-yn-by()     { s( s-int fin-full) /^ obl[S MARK=by] / ( s<14>[E VFORM=pp] \! np[S] / np[X] ) /^ np<9>[X NUM:NUM PERS:PERS nom]  }  	   
 
     
  #-----------------------
  #---  The Families  ----
  #-----------------------

  family Modal-vf-base                       { fin-entry+sem(vf-base, MODIFIER(*) ) }
  
  family Aux-vf-base (indexRel=Tense)        { fin-entry(vf-base ) }
  family Aux-no-int-vf-base (indexRel=Tense) { fin-entry-no-int(vf-base ) }
  
  family Aux-pp (indexRel=Aspect)            { fin-entry(pp) }
  family Aux-no-int-pp (indexRel=Aspect)     { fin-entry-no-int(pp) }
  
  family Aux-ing (indexRel=Aspect)           { fin-entry(ing) }
  family Aux-no-int-ing (indexRel=Aspect)    { fin-entry-no-int(ing) }
  
  family Aux-vf-be (indexRel=Tense)          { fin-entry(vf-be) }
  family Aux-no-int-vf-be (indexRel=Tense)   { fin-entry-no-int(vf-be) }

  # Should add 'context' readings here.
  family Aux-no-int-passive(indexRel=Voice){
           entry: pass-ind()      : S(context);        # the actor is markerked as 'unexpressed'
       	   entry: pass-ind-by()   ; 
           entry: aux( VFORM=pp)  ; 
   }

  family Aux-passive (indexRel=Voice){						  
           entry: pass-ind()      : S(context);        # the actor is markerked as 'unexpressed'
       	   entry: pass-ind-by()   ; 
           entry: aux( VFORM=pp)  ; 
           entry: pass-yn()     : EVENT( INT() <Subject>(X))  S(context) ;
           entry: pass-yn-by()  : EVENT( INT() <Subject>(X) ) ;
  }

 # Could be cleaned up by making defs for these categories (since repetition of above)
 #
 family Aux-negation (indexRel=Polarity) {
    
    # Standard, indicative and Y-N Int
    #
    entry:     ( (from-s(s-neg) +subj() ) / (s<14> +subj() ) )
             \ ( s(s-prov-pos) +subj()    / (s<14> +subj() ) ) ;  
    entry:     ( from-s(s-neg) / ( s<14> +subj() ) )
             \ ( s( s-int s-prov-pos) / ( s<14> +subj() ) ) ;     
	   
    # Passive, indicative and Y-N with and without 'by actor'
    # 
    entry:     ( (from-s(s-neg) \! np[X] ) / (s<14> +subj() / np[X] ) ) 
             \ ( (s(s-prov-pos) \! np[X] ) / (s<14> +subj() / np[X] ) ) ;  # Pass Ind
    entry:     ( (from-s(s-neg) \! np[X] )  /^ obl[S MARK=by] / (s<14> +subj() / np[X] ) )
             \ ( (s(s-prov-pos) \! np[X] ) /^ obl[S MARK=by] / (s<14> +subj() / np[X] ) ) ;  # Pass Ind-by
    entry:     ( from-s(s-neg) / ( s<13> \! np[S] / np[X] ) )
             \ ( s( s-int s-prov-pos)  / ( s<13> \! np[S] / np[X] ) ) ;     
    entry:     ( from-s(s-neg)  /^ obl[S MARK=by] / ( s<13> \! np[S] / np[X] ) )
            \ ( s( s-int s-prov-pos) /^ obl[S MARK=by] / ( s<13> \! np[S] / np[X] ) ) ;     
 }


#######################
## DICTIONARY FORMS  ##
#######################

  # The auxillary verbs be, have, do are done 'by-hand' in dictionary-closed.ccg

  def modal(form, class, args)  { modal-irr(form, form."n't", class, args) }

  def modal-irr(pos-form, neg-form, class, args) {
      word pos-form.-auxev : Modal-vf-base(class, pred=pos-form){
	     pos-form : pos-form s-prov-pos args; 
	     neg-form : pos-form s-neg neg args;
	  }
  }

 
 
 # Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains various 'discourse related' families (e.g. Discourse Markers)
# and also rules handling discourse phenomena like discourse 'fragments', 
# Pre-NPs, Refernt-Negotiations(appositions), etc.

# NOTE: these rules can easily be shut off by commenting them out

 ######################
 # Discourse Markers  #
 ######################

  def dm-entries(args, sem){
      entry: du[A COM=no] args                                     :  A(* sem) ; 
   #   entry: du[R COM=yes ] / du[N] args                           :  R:d-units(list <First>(F * sem) ^ <Next>(N:marker) ) ;
   #   entry: du[R COM=yes ] / s<10>[N MOOD:s-major] args           :  R:d-units(list <First>(F * sem) ^ <Next>(N:event) ) ;
    
   }
  
  
  family DM(du)  { 
     dm-entries( , )
  } 
  family DM+np(du)  { 
     dm-entries( / np() , <Addressee>(T:entity) )
  } 


  def _dis-marker(prd, form, class) {
      word form."xx"."-du" : DM (class, pred=prd) {form ;}
   }
  def dis-marker(form, class) { _dis-marker(form, form, class)}

  def _dis-marker+(prd, form, class, args) {
      word form."xx"."-du" : DM (class, pred=prd) {form: args ;}
   }
  def dis-marker+(form, class, args) { _dis-marker(form, form, class)}


  def dis-marker+np(form, class) {
      word form."-du+np" : DM+np (class, pred=form) {form ;}
   }


 ##################### 
 # DICTIONARY ENTRY  #
 #####################

    def discourse-marker(form, class) {
      word form."-dis-marker" : Discourse-marker(class, pred=form) {form ;}
    }




 
###################
# Discourse Rules #
###################


# Discourse units
# 
# Some, i.e. markers, begin their life as DUs... they have no scope. This could be changed.
# The rest are 'created' by converting various 'full' syntactic units (np, s, adj, etc) into du.
# There is one rule which linearly attaches all these chunks together.
# Hence, it allows.   The ball the big one um get it for me ok Robot 

def du-rule(from, to)  { rule { typechange: from $1                   =>  to $1   ; } }

#du-rule( np(full)   , du[T COM=no])
#du-rule( s(s-major) , du[E COM=no])
#du-rule( adj()      , du[M COM=no])

#rule { typechange: du[F COM=no]                 =>  du[F COM=yes] / du[N]             :       F( <Next>(N) )              ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] / du[N]              :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] / s(s-major)         :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no]                 =>  du[R COM=yes] \* s(s-major)         :       COORD( sequence)            ; } 


 

#family DUU(du)  { entry: du<50>[A COM=no] : A(*) ; }
#family DUU+np(du)  { entry: du<50>[A COM=no]/np() : A(* <Anchor>(T) ) ; }

#family DUU(du)     { entry: s<> / s() : EVENT( MODIFIER(*) ); }
#family DUU+np(du)  { entry: du<50>[A COM=no]/np() : A(* <Anchor>(T) ) ; }


#def _disc-unit(prd, form, class) {
#      word form."-du" : DUU (class, pred=prd) {form ;}
#   }
#def disc-unit(form, class) { _disc-unit(form, form, class)}

#def disc-unit+np(form, class) {
#      word form."-du+np" : DUU+np (class, pred=form) {form ;}
#   }



# These were rules playing around with the idea of handling 'aborted' units, i.e. repair sequences.
# Problem with the general one is it allowed the 'abortion' of completed units....
# Also, it would give readings like  <I> <want the ball>
#
# Perhaps this should be a parser meta-rule. If you get something you don't expect, hack off
# the args of previous. i.e. it should be backward looking!


#du-rule( np()/n()   , du[T COM=no] : T(abort) )
#rule { typechange: np() / n()                      =>   du[T COM=no] : T(abort)    ; } 
#rule { typechange: du[F COM=no] $1                     =>  du[F COM=no]             :       F(abort <ABORTED>yes )    ; } 

#rule { typechange: du[F COM=no] $1                 =>  du[R COM=yes] $1 / du[N COM=rep]            :       COORD( sequence)            ; } 
#rule { typechange: du[F COM=no REP=no] $1            =>  du[R COM=no] / du[N COM=no REP=yes]      :   R(abort <ABORTED>(F) <Next>(N) )   ; } 


# MAY 8: A lot of this should be done at the DISCOURSE LEVEL. I need to implement utt units which get sequentially concatinated.


  # These handle extra-syntactic phenomena 'floating' phrases, pre and post nps.


# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

#   Wh-Words for questions ( WHO is he,  WHERE did you go, etc)
#   Role-Defined Constituents  ( I picked up 'WHAT you wanted', I don't know 'WHO he is', etc)
#   Relative Clauses (the ball THAT you picked up)   

# For the sake of incremental parsing and early projection, all of these are treated 
# as the semantic and syntactic head of their respective constituents. 

###############
### WH-WORDS ##
###############

  # There are two entries for most of the question words, one for copulars, 'Who am I' 
  # and one for other verbs which must use an auxillary, 'What did you see'

  # They assign mood (both syntactic and semantic), select for the clauses Subject, 
  # and properly distribute the features dictated by the specifics of the question word

  #--------------------------------
  #---  Family Building Macros ----
  #--------------------------------


  def vp-extr(arg, item)  { ( s(VFORM:VFORM FIN:FIN POL:POL arg) +subj() item ) }
  def WH-RESTR(arg)       { <Wh-Restr>(arg) }

  # The first entry is for cases where the 'extracted' element is in the main clause (what did you want X), 
  # The second is for when it is embedded (e.g. who did he want me to see X)
  # 
  def wh-auxe-entry(item, syn, sem)  {
      entry: from-s(s-int fin-full)  / vp-extr(,item) /^ subj(nf-real) /  aux() syn                   
		   : EVENT( INT() SUBJECT() WH-RESTR(sem) ); 
      entry: from-s(s-int fin-full) / (s<13>[G] $1 item) / vp-extr(, / (s<13>[G] $1) ) /^ subj(nf-real) /  aux() syn                   
		   : EVENT( INT() SUBJECT() WH-RESTR(sem) ); 
  } 

	 
  # For cases where the subject is being questioned.
  # Note that the copular entry with /np is blocked so as to not allow subject questioning, 
  # this means what is it only gets 1 instead of '2' question forms
  #
  def wh-subj-entry(syn, sem){
            entry: from-s(s-int)  / ( s(fin) \ np[F nom 3rd s-sg nf-real Questionable=yes] ) syn   
                 : EVENT( INT() <Subject>(F) WH-RESTR(sem) );   
  }
 
  # The following three collect the appropriate entry defns to reduce redundancy below
  # NOTE:  wh-copula-entry defined in verb-copula.ccg
  # 
  def wh-comp-entries(item, syn, sem){
         wh-auxe-entry ( item, syn, sem )
         wh-copular-entry( item, syn, sem )
  } 
 

  def wh-all-entries(item, syn, sem) {
         wh-auxe-entry ( item, syn, sem )
         wh-copular-entry( item, syn, sem )
   	 wh-subj-entry(  syn, sem )         
  }

  def wh-no-copular-entries(item, syn, sem) { 
         wh-auxe-entry ( item, syn, sem )
         wh-subj-entry(  syn, sem ) 
  }

    
  #---------------------
  #--- The Families ----
  #---------------------

   # NOTE: 'extracted' constituent set to ^ slash mode, 
   #        this allows, e.g. 'what object did I put on the table' to parse incrementally,
   #        using default > mode doesnt
    
   family Wh-np- (Wh)              { wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , F:entity * ) }
    
   family Wh-np-spec- (Wh)         { wh-all-entries ( /^ np<~12>[F Questionable=yes]   , / n<12>[F s-sg]            , V * <Scope>(F:entity SG() SPECIFIC() UNIQUE() ) ) 
				     wh-all-entries ( /^ np<~12>[F Questionable=yes]   , / n<12>[F s-pl-unsp]       , V * <Scope>(F:entity PL() UNSPECIFIC() UNIQUE() ) )  }
	
   family Wh-np-spec-ctxt- (Wh)    { wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V * <Scope>(F:entity context UNIQUE() ) )  }   
     #
     # Note: Two spec fams separated because we want 'what ball' = 'which ball', but 'which' != 'what' 	
							   								   
   family Wh-np-quant-count- (Wh)  { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-pl]             , V *  <Scope>(F:entity         PL() UNSPECIFIC() VARIABLE() )          )
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V *  <Scope>(F:entity context PL() UNSPECIFIC() VARIABLE() ) ) }
   
   family Wh-np-quant-mass- (Wh)   { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-mass]           , V *  <Scope>(F:entity          VARIABLE() UNCOUNTABLE() ) ) 
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   ,                             , V *  <Scope>(F:entity context  VARIABLE() UNCOUNTABLE() ) ) }
    
   family Wh-np-qclass- (Wh)       { wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-sg no-q]  /qclass<13>[Q]        , V * <Scope>(Q <Scope>(F:entity SG() SPECIFIC() UNIQUE()) )  )
                                     wh-all-entries ( /^ np<12>[F Questionable=yes]   , / n<12>[F s-pl-unsp no-q]  /qclass<13>[Q]   , V * <Scope>(Q <Scope>(F:entity PL() UNSPECIFIC() UNIQUE()) )  ) }
	

   family Wh-pp- (Wh)              { wh-comp-entries ( /^ pp<12>[F]  ,                             , F:modifier * )  }
   
   family Wh-sent- (Wh)            { wh-auxe-entry ( /^ s<12>[F]      ,                            , F:event *)          # for sentences (what did I say)
                                     wh-auxe-entry ( /^ (s<12>[F inf] +subj())      ,              , F:event *)    }     # for inf-vp (what did I want)
   
   family Wh-adj- (Wh)             { wh-comp-entries ( /^ adj<12>[F] ,                             , F:quality * ) }
   family Wh-adj-qclass- (Wh)      { wh-comp-entries ( /^ adj<12>[F] , / qclass<12>[F]             , V * <Scope>(F:quality)  ) }
   family Wh-adj-degree- (Wh)      { wh-comp-entries ( /^ adj<12>[F] , / adj<12>[F]                , V * <Scope>(F:quality)  ) }
  
   # This use for special quality words used in questions 'which color/size/shape...'
   # 
   family Quality-class            { entry: qclass<10>[C] : C(*) ; } 
   

   # This is for handling the questioning of modifiers (i.e. optional adjuncts, like location, manner, etc)
   # There are three entries: 
   #     The first is specifically for the copula, e.g. 'when was I happy'.
   #     The second is for scoping on the main (top level) event of other verbs, e.g. 'where am is sitting' 
   #     The third is for embedded events , e.g. 'where did I want to sit'
   #
   # Attachment of these modifiers is controlled by restricting the mclass of the scoped over (i.e. the 'questioned' event)
   # This is handled lexically, i.e. 'where' specifies that the sentence must unify with s-location
   # (note this fact explains the messiness of the 2nd entry, id 10, the typical sentence id must be associated
   #  with the embedded, scoped over, sentence)
   #
   # Note: (June 17) Since we added s-no-mood, had to change top s to <~13> instead of <13>
   #                 b/c the mood gets changed from s-no-mood to s-int
   #
   family Wh-sent-modifier- (Wh) {

          be-wh-sent-mod-entries()   # defined in verb-copula.ccg
          wh-auxe-entry( , , V *  <Scope>(E:event) ) 
          entry: s<~13>[E s-int]   / (s<~10>[F] $1 )                                                     # the 'internal' s arg#
 	                           / ( s<13>[E VFORM:VFORM FIN:FIN POL:POL] +subj() / (s<10>[F] $1 )  ) 
	                           /^ subj(NUM:NUM PERS:PERS nf-real)
			           /  aux()
               : EVENT( INT() SUBJECT() WH-RESTR(V *  <Scope>(F:event)) ); 
   }




#################################
## 'Role-Defined' Constituents ##
#################################

  #  put it 'WHERE I told you to put it __' 
  #  I picked up 'WHAT you wanted __'
  #  I don't know 'WHO he is'
  #  I am going 'WHERE GJ is sleeping'
  #  'WHAT I got __' you got to give it to your mama  
  #   (this is assuming Left-dislocation is handled )
  #
  # Each of these is semantically and syntactically the entity which would be placed in the __
  # So, in the first case, this is a pp [M:m-location], the second  np[T:entity]   
 
  #--------------------------------
  #---  Family Building Macros ----
  #--------------------------------

  def extr-subj(rslt, syn, sem) { 
  
     entry: rslt    / ( s(fin s-minor) \ np[F 3rd s-sg nf-real] ) syn   
		  : F( sem ^ <Scope-in>(E:event <Subject>(F) ) ) ; 
  }

  # The first one is for cases where the fronted element is in the main clause, 
  # The second is for when it is embedded (e.g. who he wanted me to see X)
  #
  def extr-comp(rslt, item, syn, sem) { 
  
     entry: rslt  / (s<13>[G] $1 item) / vp-extr(fin-full s-minor, / (s<13>[G] $1)) /^ subj(nf-real)  syn                   
	      :  F( sem ^ <Scope-in>(E:event SUBJECT() ) ) ; 
     entry: rslt  / vp-extr(fin-full s-minor, item) /^ subj(nf-real)  syn                   
	      :  F( sem ^ <Scope-in>(E:event SUBJECT() ) ) ; 
   }

  def extr-both (rslt, item, syn, sem)  {

	  extr-subj(rslt, syn, sem) 
	  extr-comp(rslt, item, syn, sem)
  } 

  #---------------------
  #--- The Families ----
  #---------------------

   # The indices are chosen based on underlying POS (e.g. 15 for n/np, 25 for pp)
   # This is because we need to lexically select features (i.e. via macros)
   # Also, the Semantic Index is always F to allow a systematic def (see above) and 
   # also to handle subject 'extraction' properly (all set to F)   

   # QUESTION: FOR EACH FAMILY, how much do we want the 'extracted' item to inherit.
   #   e.g. should an extracted direct object be accusitive...no.
  
   #  What you picked up
   #
   family Extr-np- (Wh)              { extr-both (np<15>[F],  /^ np<16>[F Questionable=yes] ,                      , F:entity *                      ) }
   
 	       
   # which (ball) you picked up
   #
   family Extr-np-spec- (Wh)         { extr-both (np<15>[F ], /^ np<~16>[F Questionable=yes] , / n<16>[F s-sg]           ,  F:entity <Restr>(V * ) SG() SPECIFIC() UNIQUE()   ) 
                                       extr-both (np<15>[F ], /^ np<~16>[F Questionable=yes] , / n<16>[F s-pl-unsp]      ,  F:entity <Restr>(V * ) PL() UNSPECIFIC() UNIQUE() ) }

   family Extr-np-spec-ctxt- (Wh)    { extr-both ( np<15>[F ]  ,  /^ np<16>[F Questionable=yes]   ,    ,  F:entity  context ^ <Restr>(V * ) UNIQUE()  )  }   
 
									   
   # how many (balls) you picked up								   								   
   #
   family Extr-np-quant-count- (Wh)  { extr-both (np<15>[F ], /^ np<16>[F Questionable=yes] , / n<16>[F s-pl]      ,  F:entity <Restr>(V * ) UNSPECIFIC() VARIABLE()            )
                                       extr-both (np<15>[F ], /^ np<16>[F Questionable=yes] ,                      ,  F:entity context ^ <Restr>(V * ) UNSPECIFIC() VARIABLE()  ) } 

   family Extr-np-quant-mass- (Wh)  { extr-both  (np<15>[F ], /^ np<16>[F] , / n<16>[F s-mass Questionable=yes]    ,  F:entity ^ <Restr>(V * ) VARIABLE() UNCOUNTABLE()          )
                                      extr-both (np<15>[F ], /^ np<16>[F] ,                                        ,  F:entity context ^ <Restr>(V * ) VARIABLE() UNCOUNTABLE()  ) } 


   # what color/shape/size (ball) you picked up
   #
   family Extr-np-qclass- (Wh)       { extr-both (np<15>[F ], / np<16>[F] , / n<16>[F]/ qclass<13>[Q]  , F:entity ^ <Restr>(V * <Scope>(Q) )               ) 
                                       extr-both (np<15>[F ], / np<16>[F] , / qclass<13>[Q]            , F:entity context ^ <Restr>(V * <Scope>(Q) )     ) }

   # where you put it
   #
   family Extr-pp- (Wh)              { extr-comp (pp<25>[F] ,  /^ pp<26>[F] ,                    , F:modifier *              )}

  
   # what he says,  what you are doing
   # NOTE: B/C we are using <10>, i.e. 'main s' for the vp-extr, using lexical macros to set vf-deictic would also change that.
   #       so instead, we do it here.
   # 
   family Extr-sent- (Wh)            { extr-comp (s<20>[F VFORM=fin-deictic], /^ s<21>[F] ,     , F:event *      )}  # MARK ME!!!
  
   # how did you make it (big, small, etc) 
   #  
   family Extr-adj- (Wh)             { extr-comp (adj<25>[F],  / adj<16>[F] ,                   , F:quality *    )}
   
   # what size did you make it
   #
   family Extr-adj-qclass- (Wh)      { extr-comp (adj<25>[F],  / adj<16>[F] , / qclass<13>[Q]   , F:modifer <Restr>(V * <Scope>(Q) )    )}
   
   # how big did you make it
   #
   family Extr-adj-degree- (Wh)      { extr-comp (adj<25>[F],  / adj<16>[F] , / adj<16>[F]      , F:modifer <Restr>(V *)        )}
  
  
  # where I was walking, i.e. when there is no missing arg.
  #
  # Two entries and controlled by event's modifier class
  # See above in Wh-questions, or docs, for more info
  # 
  family Extr-pp-sent-modifier- (Wh)    { 
  
      entry: pp<25>[F] /^ ( s(fin s-minor) +subj() ) /^ subj()                            
             :  F( * ^ <Scope>(E) <Scope-in>(E:event SUBJECT() ) )  ;

      entry: pp<25>[F]  /^ (s<~10>[E] $1 )                                                       # the 'internal' s arg
 		        /^ ( s<13>[G fin NUM:NUM PERS:PERS s-minor] +subj() /^ (s<10>[E]$1 )  )  # the external 'main sentence' wanting an s arg
	                /^ subj()
             :  F( * <Scope>(E:event) <Scope-in>(G:event SUBJECT() ) ) ;  
  }

  family Extr-adv-sent-modifier- (Wh)    { 
  
      entry: adv<25>[F] /^ ( s(fin s-minor) +subj() ) /^ subj()                            
             :  F( * ^ <Scope>(E) <Scope-in>(E:event SUBJECT() ) )  ;

      entry: adv<25>[F] /^ (s<~10>[E] $1 )                                                       # the 'internal' s arg
 		        /^ ( s<13>[G fin NUM:NUM PERS:PERS s-minor] +subj() /^ (s<10>[E]$1 )  )  # the external 'main sentence' wanting an s arg
	                /^ subj()
             :  F( * <Scope>(E:event) <Scope-in>(G:event SUBJECT() ) ) ;  
  }


#################################
## Relative Clause Modifiers   ##
#################################

  #        the ball 'THAT I put on the table'   
  #
  #  basically uses the extracted-NP from above (c.f. what I put on the table) and 'sticks' it in 
  #  a post-noun modifier  n / ABOVE SYNTAX \ n : T( <Scope-in>(ABOVE SEMANTICS) )
  #
  #        the room 'WHERE books can be found'  ,   the place 'WHERE I put it earlier'
  # 
  #  this is actually handled 'automatically' from the role-defined stuff above.
  #  these are turned into pps, which then get run through the pp -> post-n modifer rule (see prep.ccg)
  #  If we decide this isn't the right kind of semantics, we will have to put a syntactic feature
  #  on the rules above 'shutting off' this rule (basically extend CC-TYPE feature) and then
  #  add a comparible rule here.

  family Rel-Clause-np- (indexRel=Scope-in)  { 
	
    entry: post-n(n-2 , /^ vp-extr(fin-full s-minor, / np<16>[T 3rd] ) /^ subj() ) # blocked form being 1st part of compound
	   : T( <Scope-in>(E  SUBJECT() ) ) ; 
    entry: post-n( , /^ ( s(fin-full s-minor) \ np[T 3rd s-sg] ) ) 																 
           : T( <Scope-in>(E <Subject>(T) ) ) ;
  }

 	   
#######################
## DICTIONARY FORMS  ##
#######################

  
  def  wh-word (form, class, props) { _wh-word(form, form, class, props) } 
  def _wh-word (prd, form, class, props) {
    word form.-wh-word.class: props(class, pred=prd) { form ; }
  }

  def  wh-word+feat (form, class, props, args )  { _wh-word+feat(form, form, class, props, args )  } 
  def _wh-word+feat (prd, form, class, props, args )  {
    word form.-wh-word.class.props: props(class, pred=prd)  { form: args ; }
  }

  def  extr (form, class, props, args )  { _extr(form, form, class, props, args )  } 
  def _extr (prd, form, class, props, args )  {
    word form.-wh-comp.class.props: props(class, pred=prd)  { form: args ; }
  }

  def  quality-class (form) { _quality-class(form, form) } 
  def _quality-class (prd, form) {
    word form.prd.-quality-class: Quality-class(quality, pred=prd) { form; }
  }


# This contains the dictionary items and testbed for 
# the COMSYS-DEVIL release

# to run the testbed use the command ccg-test

# NOTE:  the " " around single quotes are NOT IN THE GRAMMAR
#        but simply required by DotCCG

#############
## Testbed ##
#############

# You will get 3 readings for the bulk of these:
#         the np reading
#         the type-raised np as subject reading
#         the np as fronted object reading
# For 'the square' and 'the green square' you will get 9
# because square has an adjectival entry ( see X dictionary-open.ccg )


testbed {

  ########## 
  ## Demo ##
  ##########

  the triangle: 3 ;
  the circle: 3 ;
  the square: 9 ;        
  the star: 3 ;
  the red triangle: 3 ;
  the blue circle: 3 ;
  the green square: 9 ;
  the yellow star: 3 ;
  the red thing: 3 ;
  the blue thing: 3 ;
  the green thing: 3 ;
  the yellow thing: 3 ;
  
  a yellow flag: 3 ;
  a car: 3;
  
  ############
  ## Part 1 ##
  ############
   
	### Recognition of complex action sequences ##
	
	I am playing a game: 1 ;
    which game am I playing : 1 ;
	I do not know : 1 ;
	the shape game or the colour game: 1 ;
	which game am I playing : 1 ;
	you are playing the shape game : 1 ;
	
	### Ability to verbalise rules ##
	
	# to distinguish 'he goes to the table' from 'it goes on the table'
	# I gave the latter the pred go-loc
	
	where should the blue triangle go: 1;
	it should go next to the left flag: 1 ; # next to is treated as a mwe, hence underscore
	now I am playing the colour game : 1 ;
	where does the blue square go: 1 ;
	it should go next to the blue flag: 1;
	where is the blue flag: 1;
	it is on the right: 1;
	it is on the right of the red flag: 1;
	
	### Ability to apply context specific game rules
	
	### Ability to play the game
	
	play the colour game: 1;
	play the shape game: 1;
	
  ############
  ## Part 2 ##
  ############

	this is a car: 1;
	where is the car: 1;
	behind the wall: 1;
	what is behind the wall: 1;
	I see a car and a blue thing: 1;
	what is the blue thing: 1;
	it is a ball: 1;

  ######################
  ## Part 3: Explorer ##
  ######################

	could you go and find the Borland book please: 1;
	#I will go and look for it in a library where books are normally found: 1;
	do you know where the Borland book is: 1;
	I believe it is in GJ "'s" office: 1;
	the book is in GJ  "'s" office near the Starbucks mug: 1;
	
        I am sorry but could you help me: 1;
        could I ask you a question: 1;
        would you know where the Borland book is: 1;
        could you tell me where the Borland book is: 2;
        I would like to know something: 1;
        I would like to ask you something: 1;
        would you happen to know where the Borland book is: 1;
        I would need to kill you now: 1;
        I would need your help: 1;
        so_long and thanks for all the fish: 1;
	
}  

# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# The vast majory of dictionary entries are in dictionary-open.ccg. 
# Also, see this file for general info on adding dictionary items.

# This file contains the 'core vocabulary' or 'closed class' words:
#    Pro-forms  (pronouns, pro-verb 'do', pro-sentences (I said it), pro-locations (here, there) )
#    Adjective related function words (more, most, bigger THAN) 
#    Markers (obliques, infinitival to, subordinate-sentential clause markers, etc)
#    Determiners, Possessive 's, Deictics, 'Group'-words, Numbers (ordinal & cardinal)
#    Wh-words
#    Auxillary & Modal Verbs

# NOTE: MUST CLEAN UP WH and EXTR SECTION

##############
## PROFORMS ##
##############

  
  #-- Nominals --#    
 
  # pronoun(pers, sg-nom, sg-acc, pl-nom, pl-acc, posessed, class,)
  #
  pronoun(I,    1st, sg, I    , me   , my   , mine   , person,)
  pronoun(I,    1st, pl, we   , us   , our  , ours   , person,)
  pronoun(you,  2nd, sg, you  , you  , your , yours  , person,)
#  pronoun(you,  2nd, pl, you  , you  , your , yours  , person,) 
  pronoun(he,   3rd, sg, he   , him  , his  , his    , person,)
  pronoun(she,  3rd, sg, she  , her  , her  , hers   , person,)
  pronoun(it,   3rd, sg, it   , it   , its  , its    , thing,)
  pronoun(they, 3rd, pl, they , them , their, theirs , entity,)

  word it-pro-3rd-sg:Bare-np(thing, pred=it) { that :  3rd s-sg acc pro sg asr-correction; }
 

  context-np(someone,  person, s-sg sg existential specific full)   _context-np(someone, somebody, person, s-sg sg existential specific full)
  context-np(anyone,   person, s-sg sg variable    specific  full)   _context-np(anyone, anybody, person, s-sg sg  variable    specific full) 

  context-np(something,  thing, s-sg sg existential  specific  full)   
  context-np(anything,   thing, s-sg sg variable     specific  full)  

  # deictics 'this' and 'that' defined with determiners below  


  #-- Events --# 
  
  context-s(this, proximal specific unique)
  context-s(that, distal   specific unique)
  context-s(it, )
  context-s(something, existential  specific )   
  context-s(anything,  variable     specific )  

  verb(do, doing, did, done, m-class-all, event,                v+deictic-event )


  #-- Locations --#
 
  _prp+(no-arg, context, there, location, prep-1 m-distal)
  _prp+(no-arg, context, there, whereto,  prep-2 m-distal)
  _prp+(no-arg, context, here,  location, prep-1 m-proximal)
  _prp+(no-arg, context, here,  whereto,  prep-2 m-proximal)

  # these are used as contexualized anchors for prepositions: 'I went in there', 'walk over to here'
  # these use case loc-acc that only prepositions can accept

  context-np(here, e-location, sg s-sg acc-loc proximal specific unique full) 
  context-np(there, e-location, sg s-sg acc-loc distal specific  unique full)  
    
  prp+(no-arg, somewhere, location, prep-1 )  _prp+(no-arg, somewhere, anywhere, location, prep-1 )
  prp+(no-arg, somewhere, whereto, prep-2 )  _prp+(no-arg, somewhere, anywhere, whereto, prep-2 )

  #-- Temporal --#
  
  context-np(then, e-time, sg s-sg acc-loc specific unique full)  
     

#######################
## ADJECTIVE RELATED ##
#######################

  word more : More-adj: comparative;
  word most : Most-adj: superlative;
  word than : Adj-er-than(m-comparison);

################################################
## MARKER (including dep and relative clauses ##
################################################

  word of  : NP-marker;
  word by  : NP-marker;
  word at  : NP-marker;
  word to  : NP-marker;
  word for : NP-marker;
  word from : NP-marker;
  word out_of : NP-marker;


  word infinitive-to: Infinitive-to {to;}
  word for-verb-ing: For-verb-ing {for;}
  word that: Dep-clause-marker-no-sem;
  word if: Dep-clause-marker;
  word whether: Dep-clause-marker;

  word that-RCn : Rel-Clause-np- {that ;}
  word who-RCn  : Rel-Clause-np- {who ;}

####################
## DET and GROUPS ##
####################
  
  word possessive-s: Det-poss-s { 
		"'s": unique specific sg s-sg; 
		"'s": unique specific pl s-pl; 
  }	
  
  # These are higher order dictionary-entry macros
  # which collect other dict-macros together to reduce redundancy in the grammar
  #  
  def det+context-np (form, args)  {
      det(form, args) 
      context-np(form,"entity",  args) 
  }

  def det+context-np+group-np  (form, args) {
      det+context-np(form, args) 
      group-np(form, args)
  }

  def sdet+context-np  (form, class, args) {
      sdet(form, class, args)
      context-np+modifier(form, class, args) 
  }

  def sdet+context-np+group-np (form, class, args) {
        sdet+context-np(form, class,args) 
	sgroup-np(form, class,args)
  }

  det                      (the,   s-sg      sg  unique      specific   )
  det                      (the,   s-pl-sp   pl  unique      specific   ) 
  det                      (the,   s-pl-unsp pl  unique      unspecific ) 
  
  det                      (a,     s-sg      sg  existential specific   )   
  det                      (some,  s-sg      sg  existential specific   ) 
  det+context-np+group-np  (some,  s-pl-unsp pl  existential unspecific )
  det+context-np           (any,   s-sg      sg  variable    specific   )
  det+context-np+group-np  (any,   s-pl-unsp pl  variable    unspecific )
    
  det+context-np           (this,  s-sg      sg  unique      specific   proximal)
  det+context-np           (these, s-pl-unsp pl  unique      unspecific proximal)
  det                      (these, s-pl-sp   pl  unique      specific   proximal)
  det+context-np           (that,  s-sg      sg  unique      specific   distal  )
  det+context-np           (those, s-pl-unsp pl  unique      unspecific distal  )
  det                      (those, s-pl-sp   pl  unique      specific   distal  )

  sdet+context-np+group-np (more, comparative, s-pl-unsp pl variable unspecific)
  sdet+context-np+group-np (less, comparative, s-pl-unsp pl variable unspecific)
  sdet+context-np+group-np (all,  quantity,    s-pl-sp      unique   unspecific)
      sgroup-np-no-of      (all,  quantity,    s-pl-sp      unique   unspecific)
   
  sdet+context-np+group-np (both,     quantity, s-pl-sp    pl unique      specific)
  sdet+context-np+group-np (another,  quantity, s-sg       sg existential specific)
  sdet+context-np+group-np (the_rest, quantity, s-pl-unsp  pl unique      unspecific)
  sdet+context-np+group-np (enough,   quantity, s-pl-unsp  pl variable    unspecific)
  sdet+context-np+group-np (none,     quantity, s-pl-sp       variable    unspecific)
  sdet+context-np+group-np (a_few,    quantity, s-pl-unsp  pl existential unspecific)  # FIX
  sdet+context-np+group-np (several,  quantity, s-pl-unsp  pl existential unspecific)
 
  sdet(No, quantity, s-sg    sg  variable specific   )
  sdet(No, quantity, s-pl-sp pl  variable unspecific )
  
  sdet(every, quantity, s-sg     variable specific)

#############
## NUMBERS ##
#############


  # These dictionary entry macros handle the various uses of numbers
  # Note that both numeric and "written out" versions are created 
  # for both cardinal (1, 2, 3 ...) and ordinal numbers (1st, 2nd, 3rd ...)
  #
  def number(card, r-card) {number-irr (card, card."th", r-card, r-card."th") }
  def number-irr(card, ord, r-card, r-ord) { number-basic (card, ord, r-card, r-ord, pl, s-pl-sp) }  
  def number-basic (card, ord, r-card, r-ord, num, s-num) {
		
      	# CARDINAL		
      	un-to-spec-det      (card,         "number-cardinal" ) # num s-num feat just repeated to fill slot
      	un-to-spec-det      (r-card,       "number-cardinal" )
      	_un-to-spec-det     (card, r-card, "number-cardinal" )
  	_un-to-spec-det     (r-card, card, "number-cardinal" )
      	
      	sdet                (card,         "number-cardinal"  , num s-num existential specific)
      	sdet                (r-card,       "number-cardinal"  , num s-num existential specific)
      	_sdet               (card, r-card, "number-cardinal"  , num s-num existential specific)
      	_sdet               (r-card, card, "number-cardinal"  , num s-num existential specific) 
      	
      	sgroup-np           (card,         "number-cardinal"  , num s-num existential specific)
        sgroup-np           (r-card,       "number-cardinal"  , num s-num existential specific)
        _sgroup-np          (card, r-card, "number-cardinal"  , num s-num existential specific)
        _sgroup-np          (r-card, card, "number-cardinal"  , num s-num existential specific)

      	context-n+modifier  (card,         "number-cardinal"  , s-num )
      	context-n+modifier  (r-card,       "number-cardinal"  , s-num )
      	_context-n+modifier (card, r-card, "number-cardinal"  , s-num )
      	_context-n+modifier (r-card, card, "number-cardinal"  , s-num )
      	
      	context-np+modifier  (card,         "number-cardinal"  , num s-num  existential specific)
      	context-np+modifier  (r-card,       "number-cardinal"  , num s-num existential specific)
      	_context-np+modifier (card, r-card, "number-cardinal"  , num s-num existential specific)
      	_context-np+modifier (r-card, card, "number-cardinal"  , num s-num existential specific)
      	
        number-id  (card )
      	number-id  (r-card)
      	_number-id (card, r-card)
      	_number-id (r-card, card)

	# ORDINAL (The predicate for ordinals is always the corresponding cardinal)
      	
        _adj-none           (card, ord,     "number-ordinal"   ,  ) 
      	_adj-none           (r-card, r-ord, "number-ordinal"   ,  ) 
      	_adj-none           (card, r-ord,   "number-ordinal"   ,  ) 
      	_adj-none           (r-card, ord,   "number-ordinal"   ,  ) 
      	
      	_context-n+modifier (card, ord,     "number-ordinal"   , s-sg  )  
      	_context-n+modifier (r-card, r-ord, "number-ordinal"   , s-sg  )  
      	_context-n+modifier (card, r-ord,   "number-ordinal"   , s-sg  )  
      	_context-n+modifier (r-card, ord,   "number-ordinal"   , s-sg  )  
      	
      	_sgroup-n            (card, ord,      "number-ordinal"   , s-sg  ) 
        _sgroup-n            (r-card, r-ord,  "number-ordinal"   , s-sg  ) 
  	_sgroup-n            (card, r-ord,    "number-ordinal"   , s-sg  ) 
      	_sgroup-n            (r-card, ord,    "number-ordinal"   , s-sg  ) 
  
      	
   
 }
  
  number-basic(one, first, "1", "1st", s-sg, sg)
     # This gives a reading equivalent to 'a ball'
     det+context-np+group-np  (one,   s-sg sg  existential specific)        
     # This is for handling the dummy noun for the contextual 'the ones on the table'
	 context-n(ones, entity, s-pl full)  
	 context-n(one, entity, s-sg full)

  number-irr(zero, zeroth, "0", "0th")  
  number-irr(two, second, "2", "2nd")
  number-irr(three, third, "3", "3rd")
  number(four, "4")
  number-irr(five, fifth, "5", "5th")
  number(six, "6")
  number(seven, "7")
  number-irr(eight, eighth, "8", "8th")
  number(nine, "9")
  number(ten, "10")
  number(eleven, "11")
  number(twelve, "12")
  number(thirteen, "13")
  number(fourteen, "14")
  number(fifteen, "15")
  number(sixteen, "16")
  number(seventeen, "17")
  number(eighteen, "18")
  number(nineteen, "19")
  number(twenty, "20")
  number(twentyone, "21")
  number(twentytwo, "22")
  number(twentythree, "23")
  number(twentyfour, "24")
  number(twentyfive, "25")
  number(twentysix, "26")
  number(twentyseven, "27")
  number(twentyeight, "28")
  number(twentynine, "29")
  number(thirty, "30")
  number(thirtyone, "31")
  number(thirtytwo, "32")
  number(thirtythree, "33")
  number(thirtyfour, "34")
  number(thirtyfive, "35")
  number(thirtysix, "36")
  number(thirtyseven, "37")
  number(thirtyeight, "38")
  number(thirtynine, "39")
  number(forty, "40")
  number(fortyone, "41")
  number(fortytwo, "42")
  number(fortythree, "43")
  number(fortyfour, "44")
  number(fortyfive, "45")
  number(fortysix, "46")
  number(fortyseven, "47")
  number(fortyeight, "48")
  number(fortynine, "49")
  number(fifty, "50")
  number(fiftyone, "51")
  number(fiftytwo, "52")
  number(fiftythree, "53")
  number(fiftyfour, "54")
  number(fiftyfive, "55")
  number(fiftysix, "56")
  number(fiftyseven, "57")
  number(fiftyeight, "58")
  number(fiftynine, "59")
  number(sixty, "60")
  number(sixtyone, "61")
  number(sixtytwo, "62")
  number(sixtythree, "63")
  number(sixtyfour, "64")
  number(sixtyfive, "65")
  number(sixtysix, "66")
  number(sixtyseven, "67")
  number(sixtyeight, "68")
  number(sixtynine, "69")
  number(seventy, "70")
  number(seventyone, "71")
  number(seventytwo, "72")
  number(seventythree, "73")
  number(seventyfour, "74")
  number(seventyfive, "75")
  number(seventysix, "76")
  number(seventyseven, "77")
  number(seventyeight, "78")
  number(seventynine, "79")
  number(eighty, "80")
  number(eightyone, "81")
  number(eightytwo, "82")
  number(eightythree, "83")
  number(eightyfour, "84")
  number(eightyfive, "85")
  number(eightysix, "86")
  number(eightyseven, "87")
  number(eightyeight, "88")
  number(eightynine, "89")
  number(ninety, "90")
  number(ninetyone, "91")
  number(ninetytwo, "92")
  number(ninetythree, "93")
  number(ninetyfour, "94")
  number(ninetyfive, "95")
  number(ninetysix, "96")
  number(ninetyseven, "97")
  number(ninetyeight, "98")
  number(ninetynine, "99")

 
###############
## ADVERBS   ##
###############

  # Purpose ascribing to, i.e. I went in to see him, I picked it up to play with it.

  word to-purpose: Adv+verb-base- (m-purpose, pred=to)    {to: s-purpose ;}


###############
## PARTICLES ##
###############

  word up : Particle;

  word cup: Particle (pred=up) {
    cup: asr-correction ;
  }

###########
## COORD ##
###########

  coord+(and, np,   entity, s-pl pl)
  #coord+(and, n,    entity, s-pl pl)
  coord+(then, np,   entity, s-pl pl) 
#_coord+(then, and_then, np,   entity, s-pl pl)
  #coord+(then, n,    entity, s-pl pl) 
#_coord+(then, and_then,  n,   entity, s-pl pl)
  
  coord+(before, np,   entity, s-pl pl) 
  #coord+(before, n,    entity, s-pl pl)
  
  coord+(after, np,   entity, s-pl pl) 
  #coord+(after, n,    entity, s-pl pl)


  coord+(or, np,   entity, s-sg)
  #coord+(or, n,    entity, s-sg)

  coord(and, s, event)
  coord(but, s, event)
  coord(then, s, event)   _coord(then, and_then, s, event)    
  coord(or, s, event) 

#  coord(and, prep, modifier)
#  coord(but, prep, modifier)
#  coord(then, prep, modifier) 
# _coord(and, and_then, prep, modifier)
#  coord(or, prep, modifier)

  coord(and, adv, modifier)
#  coord(but, adv, modifier)
#  coord(then, adv, modifier)  
#_coord(and, and_then, adv, modifier)
  coord(or, adv, modifier)

  coord(and, adj, quality)
#  coord(but, adj, quality)
#  coord(then, adj, quality) 
# _coord(and, and_then, adj, quality)
  coord(or, adj, quality)


############
# WH-WORDS #
############

  # This only handles a single family, not a list like 
  # the underlying classes. This is due to string formation
  #
  def wh+extr(form, class, item, args) {
    wh-word(form, class, "Wh-".item."-")
  #  extr(form, class, "Extr-".item."-", args)
  #  _extr(form, form."ever", class, "Extr-".item."-", args)  # must add features!
  }
  
  def wh+extrrr(form, class, item, args) {
    wh-word(form, class, "Wh-".item."-")
    extr(form, class, "Extr-".item."-", args)
    _extr(form, form."ever", class, "Extr-".item."-", args)  # must add features!
  }
  
  
  wh+extrrr(who, animate, np , s-sg nf-real)
  
  wh+extrrr(what, entity, np , s-sg nf-real)
  wh+extrrr(what, event, sent, fin)
  
  wh+extrrr(which, specifier, np-spec, nf-real)
  wh+extrrr(which, specifier, np-spec-ctxt, nf-real)
  
  wh-word(which, specifier , Wh-np-spec-ctxt- Wh-np-qclass- Wh-adj-qclass-  )
  #wh-word(which, specifier , Wh-np-spec- Wh-np-spec-ctxt- Wh-np-qclass- Wh-adj-qclass-  )
  wh-word(what , specifier , Wh-np-spec- Wh-np-qclass- Wh-adj-qclass-  )
  
  wh-word(whose, owner , Wh-np-spec- Wh-np-spec-ctxt-)
  
  wh+extrrr(how_much, quantity, np-quant-mass  , s-sg nf-real)
  wh+extrrr(how_many, quantity, np-quant-count , s-sg nf-real)
  
  # Adding degree-base here wasn't really 'intended'. It was to avoid having an
  # empty arg slot in the wh+extr def
  
  wh+extr(how, quality, adj , s-degree-base cc-none)
  wh+extr(how, quality, adj-degree , s-degree-base cc-none)
  wh-word+feat(how, m-manner, Wh-sent-modifier-, s-manner)
  extr(how, m-manner, Extr-adv-sent-modifier-, adv-2 s-manner x-manner)
  
  wh+extrrr(where, m-location, pp , prep-1 x-location )
  wh-word+feat(where, m-location, Wh-sent-modifier-, s-location)
  extr(where, m-location, Extr-pp-sent-modifier-,  prep-1 s-location x-location)
  
  wh+extrrr(where, m-dynamic, pp , x-dynamic prep-2 )
  wh-word+feat(where, m-dynamic, Wh-sent-modifier-, s-dynamic)
  extr(where, m-dynamic, Extr-pp-sent-modifier-,  prep-1 s-dynamic x-dynamic)
  
  # Time Questions
  
  wh-word+feat(when, m-time-point, Wh-sent-modifier-, s-time)
  wh-word+feat(how_long, m-time-interval, Wh-sent-modifier-, s-time)
  
  
  #wh-word(how, degree , Wh-adj-degree Extr-adj-degree )
  #wh-word(how, quality, Wh-adj Extr-adj)
  #wh-word+(how, m-manner, Wh-sent-modifier, s-manner)
  #wh-word+(how, m-manner, Extr-adv-sent-modifier, adv-2 s-manner x-manner)
  
  # Prep-1 allows post-s, post-vp 
  #        and post-n, i.e. it can handle 'the place where I put it', 'the room where I stayed' etc.
   
  #wh-word(where,  m-location, Wh-pp) 
  #wh-word+(where, m-location, Wh-sent-modifier,        s-location)
  #wh-word+(where, m-location, Extr-pp,                  prep-1 x-location)
  #wh-word+(where, m-location, Extr-pp-sent-modifier,    prep-1 s-location x-location)
  
  #wh-word(where,  m-dynamic, Wh-pp)  
  #wh-word+(where, m-dynamic, Wh-sent-modifier,     s-dynamic)
  #wh-word+(where, m-dynamic, Extr-pp,               prep-1 x-dynamic)
  #wh-word+(where, m-dynamic, Extr-pp-sent-modifier, prep-1 s-dynamic x-dynamic)
  
  quality-class(size)
  quality-class(shape)
  quality-class(color) _quality-class(color, colour)
  quality-class(age)
  quality-class(material)
  quality-class(substance)
  quality-class(temperature)
  quality-class(orientation)
  
  
  #wh-s-mod(where, m-location, s-location)
  #wh-s-mod(blah, m-dynamic, s-dynamic)
  #wh-s-mod(how, m-manner, s-manner)
  


############
# BE-FORMS #
############

# These forms of the be verb are used by be as copular & as its various aux forms 
# ( be + v+ing, be + passive )

def be-forms (args) {
    am:        be  pres  1st     s-sg s-prov-pos      args;
	are:       be  pres          s-pl s-prov-pos      args;
        far:	   be  pres          s-pl s-prov-pos  asr-correction;
	are:       be  pres  2nd     s-sg s-prov-pos      args;
	"aren't":  be  pres          s-pl s-neg      neg  args;
	"aren't":  be  pres  2nd     s-sg s-neg      neg  args;
        is:        be  pres  3rd     s-sg s-prov-pos      args;
        "isn't":   be  pres  3rd     s-sg s-neg      neg  args;
	"ain't":   be  pres               s-neg      neg  args;
	was:       be  past  1st     s-sg s-prov-pos      args;
	was:       be  past  3rd     s-sg s-prov-pos      args;
	"wasn't":  be  past  1st     s-sg s-neg      neg  args;
	"wasn't":  be  past  3rd     s-sg s-neg      neg  args;
	were:      be  past  2nd     s-sg s-prov-pos      args;
	were:      be  past          s-pl s-prov-pos      args;
	"weren't": be  past  2nd     s-sg s-neg      neg  args; 
	"weren't": be  past          s-pl s-neg      neg  args; 
}


###########
# COPULAR #
###########

  # The copular and its negation
  # There are two versions of this because the normal locational (I am here)
  # is blocked from allowing additional post-modified locations
  #
  word be-copular: Copular(ascription, pred=be){
  
      be-forms(fin-full m-class-2x)
  
   	been:    pp        m-class-3; 
        being:   ing       m-class-3;
   	be:      vf-base   m-class-3; 
  	be:      vf-to-imp m-class-3; 
  
  }
  
  word be-copular-loc: Copular-location(ascription, pred=be){
  
      be-forms(fin-full m-class-3)
  
      been:    pp        m-class-3; 
      being:   ing       m-class-3;
      be:      vf-base   m-class-3; 
      be:      vf-to-imp m-class-3; 
  
  }
  
  
  word not-cop-neg :Cop-negation{not: neg;}

  word no-cop-neg :Cop-negation{No: neg asr-correction;}
  
  # The presentational there+be
  # There are two versions of this because the inverted version
  # is blocked from allowing additional post-modified locations
  #
  word be-presentational: Presentational(presentational, pred=be){
  
      be-forms(fin-full m-class-2)
  
      been:    pp      m-class-2; 
      being:   ing     m-class-2;
      be:      vf-base m-class-2; 
  
  }
  
  word be-presentational-inverted: Presentational-inverted(presentational, pred=be){
  
      be-forms(fin-full m-class-3)
  
      been:    pp      m-class-3; 
      being:   ing     m-class-3;
      be:      vf-base m-class-3; 
  
  }
  
   word dummy-there : Bare-np(dummy, pred=there){ there: nom dummy-there;}

#####################
## MODAL/AUX VERB ##
#####################

  # Modal Verbs #

  modal(should, modal, pres)
  modal(must,   modal, pres)
  modal(would, modal, )
  modal(could, modal, )
  modal-irr(can,  "can't", modal, pres)
  modal-irr(can,  "cannot", modal, pres)
  modal-irr(will, "won't", modal, fut)
   

  # Auxilliary Verbs #

  word not-aux-neg: Aux-negation {not: neg;}  # syntactic change from s-prov-pos to s-neg in family

  # Note: currently  'I did go' is treated identically to 'I went'
  #       and hence collapse. If we want emphatic do, it'll have to be
  #       treated as a modal, and hence be given its own <Modal> dep reln.

  word do-aux: Aux-vf-base(aux){
    do:        do pres non-3rd s-sg  s-prov-pos     ;
    "don't":   do pres non-3rd s-sg  s-neg      neg ;
    do:        do pres         s-pl  s-prov-pos     ;
    "don't":   do pres         s-pl  s-neg      neg ;
    does:      do pres 3rd     s-sg  s-prov-pos     ;
    "doesn't": do pres 3rd     s-sg  s-neg      neg ;
    did:       do past               s-prov-pos	    ;
    "didn't":  do past               s-neg      neg ;
  }
  
  word do-imp: imp-do {
	do:        do   s-prov-pos     ;
        "don't":   do   s-neg      neg ;
  }

  word lets-imp: imp-lets {
      "let's":   do   s-pos      ;
  }

  word have-aux: Aux-pp(aux){   
	have:      have pres perfect non-3rd s-sg  s-prov-pos      ;
        "haven't": have pres perfect non-3rd s-sg  s-neg       neg ;
	have:      have pres perfect         s-pl  s-prov-pos      ;
        "haven't": have pres perfect         s-pl  s-neg       neg ;
	has:       have pres perfect 3rd     s-sg  s-prov-pos      ;
	"hasn't":  have pres perfect 3rd     s-sg  s-neg       neg ;
	had:       have past perfect               s-prov-pos      ;
	"hadn't":  have past perfect               s-neg       neg ;
  }
  word have-aux-no-int: Aux-no-int-pp(aux){  
     have:   vf-base perfect;   # will have
  }


  word be-aux-vf-be: Aux-vf-be (aux) {
    be-forms()
  }
  word be-aux-vf-be-no-int: Aux-no-int-vf-be (aux) {
    be:       vf-base  ;      # will be going, can be going, etc.
    been:     pp       ;      # have been going
  }

  word be-aux-ing: Aux-ing (aux) {
    be-forms(continuous)
  }
  word be-aux-ing-no-int: Aux-no-int-ing (aux) {
    be:       vf-base  continuous;      # will be going, can be going, etc.
    been:     pp       continuous;      # have been going
  }


  # Currently, no wh-questions can be handled in passsives, as this'll require
  # adding a new 'passive' for for each...

  word be-passive-aux: Aux-passive (aux) {
     be-forms(passive)
  } 
  word be-passive-aux-no-int: Aux-no-int-passive (aux) {
   be:      vf-base passive;       
   being:   ing     passive;       
   been:    pp      passive;            
  } 

 word get-passive-aux: Aux-no-int-passive (aux) {
     get:      fin-full passive pres s-pos do non-3rd s-sg  ;  	
     gets:     fin-full passive pres s-pos do 3rd     s-sg  ;
     get:      fin-full passive pres s-pos do         s-pl  ;
     got:      fin-full passive past s-pos do               ;
     get:      vf-base  passive;       
     getting:  ing      passive;       
     got:      pp       passive;            
  } 
# Authors: Trevor (trevormbenjamin@yahoo.ca) and GJ (GJ@DFKI.de), 2008 

# This file contains most dictionary entries, specifically, the 'open class words' 
#     i.e. nouns, verbs, adjectives, adverbs, prepositions, 
#          discourse-markers, mod-modifiers (VERY big, OVER on the table, etc.)
# It also includes some higher level macros for defining larger clusters of words
# These are marked with --MACRO-- (see documentation)



# The entries have been sorted first by 'Part of Speech' then by ontological sort (person, thing, etc)

# All entries are entered using one of the 'dictionary-entry' macros (defs)
# listed in the various .ccg files in the grammar proper. 

# Although, of course, you must check the apporpriate file for specifics,
# the standard convention for these dictionary-entry macros is 
#
#     macro-name( various forms, 
#                 ontological sort (i.e. class),
#                 other arguments (including feature-macros, family listing)
#                )
#
# For alternate forms/variations, i.e. different entries with the same predicate
# (e.g. forward, forwards) for each additional form, you must add a separate entry
# using the alternate-form macro.
#
#     _macro-name( predicate,
#                  various forms,
#                  ontological sort (i.e. class),
#                  other arguments (including feature-macros, family listing)
#                ) 
#
# This is identical to the standard macro, except, it is prefaced with an underscore _, 
# and the first element is the predicate, then the alternate variation in all of its forms
# 
#  e.g. Here are the entries for the adverbs 'slow' & alternate 'slowly' 
#           adverb(slowly, manner, adv-all,) 
#          _adverb(slowly, slow, manner, adv-all,)

# NOTE:
# There is currently, unlike in moloko.v4, no way of handling Multi-word expressions. 


###########
## NOUNS ##
###########

  # ----MACRO----
  #   This gives every relevant proper name a Discourse Marker reading, 
  #   allowing it to function as a vocative
  #        e.g. GJ could you come here
  #   NOTE: NO CO-INDEXING occurs for this in the grammar
  #
  def name+vocative(form, class) {_name+vocative(form, form, class) }
  def _name+vocative(prd, form, class){
     _name(prd, form, class,)
     _dis-marker+(prd, form, class, fin-full) # blocks from getting 'GJ has a ball'... to parse as contextualized, 'GJ, has a ball been put here recently'
  }

  #-- Person --#

  noun(person, person,)
  noun(boy, person,)
  noun(girl, person,)
  noun(dad, person,)
  noun(mom, person,)  _noun(mom, mamma, person,)
  noun-irr(man, men, person,)
  noun-irr(woman, women, person,)
  noun-irr(child, children, person,)
  noun(guy, person,)
  noun(secretary, person,)
  noun-irr(policeman, policemen, person,)
  noun(janitor, person,)
  noun(student, person,)
  noun(researcher, person,)
  noun(pirate, person,)

  name+vocative(GJ, person,)
  name+vocative(Trevor, person,)	
  name+vocative(Hendrik, person,)	
  name+vocative(Henrik, person,)	
  name+vocative(Pierre, person,)
  name+vocative(Patric, person,)		
  name+vocative(Nick, person,)	
  name+vocative(Michael, person,)	
  name+vocative(Oscar, person,)	
  name+vocative(Daniel, person,)	
  name+vocative(Maria, person,)	  
  name+vocative(Jeremy, person,)	
  name+vocative(Aaron, person,)	
  name+vocative(Chandana, person,)	
   name+vocative(Hans, person,)
   name+vocative(Dennis, person,)

  _noun(Robot, rowboat, animate, asr-correction)


  noun(Borland, entity,) 
  
  #-- Animate --#
 
  name+vocative(Robot, animate) _name+vocative(Robot, robot, animate)
   
  noun(dog, animate,) 
  noun(cat, animate,) 
  noun-irr(fish, fish, animate,) 
  noun(cow, animate,) 
  noun(mouse,animate,)
  noun(animal, animate,) 
  noun(robot, animate,) 
 
  #-- Thing --#
  
  noun(thing, thing,)
  noun(object, thing,)
  noun(entity, thing,)
 
  noun(triangle, thing,) 
  noun(square, thing,) 
  noun(star, thing,) 
  noun(circle, thing,) 
 
  noun(cone,thing,)
  noun(cylinder, thing,)
  noun(boat, thing,)

  noun(cable, thing,)
  noun(fruit, thing,)  
  noun(bed, thing,)
  noun(pen, thing,)
  noun(glue, thing,)
  noun(row, thing,)
  noun(curtain, thing,)
  noun(mattress, thing,)
  noun(mountain, thing,)
  noun(arm, thing,)
  noun(board, thing,)

  noun(flag, thing,) 
   
  noun(game, thing,) 
    
  noun(car, thing,)
  noun(wall, thing,)
    
  noun(pizza, thing,) 
  noun(thing, thing,) 
  noun(book, thing,) 
  noun(ball, thing,) 
  noun(block, thing,) 
  noun(box, thing,) 

  word box2-noun-n:Noun(thing, pred=box) { blocks :  s-sg full asr-correction; }
  word box3-noun-n:Noun(thing, pred=box) { ball :  s-sg full asr-correction; }
word box4-noun-n:Noun(thing, pred=box) { books :  s-sg full asr-correction; }

 
  noun(bucket, thing,) 
  noun(pin, thing,) 
  noun(cube, thing,) 

  noun(trophy, thing,) 
  noun-irr(tooth, teeth, thing,) 
  noun(mug, thing,) 
  noun(cup, thing,) 
  noun(jug, thing,) 
  noun(keyboard, thing,) 
  noun(laptop, thing,) 
  noun(screen, thing,) 
  noun(computer, thing,) 
  noun(mp3-player, thing,) 
  noun(minidisc-recorder, thing,) 
  noun(needle, thing,) 
  noun(thread, thing,) 
  noun-mass(thread, thing,) 
  noun(flower, thing,) 
  noun(phone, thing,) _noun(phone, telephone, thing,)
  noun(mobile, thing,) _noun(mobile, cell, thing,) _noun(mobile, handy, thing,) _noun(mobile, cellphone, thing,)  
  noun(letter, thing,) 
  noun(mailbox, thing,) 
  noun(copier, thing,) 
  noun(fax, thing,) 
  noun(printer, thing,) 
  noun(column, thing,)  _noun(column, pillar, thing,)
  noun-mass(furniture, thing,) 
  noun(floor, thing,) 
  noun(door, thing,) 
  noun(couch, thing,) _noun(couch, sofa, thing,)
  noun(tv, thing,)  _noun(tv, television, thing,)
  noun(oven, thing,) _noun(oven, cooker, thing,) _noun(oven, stove, thing,)
  noun(tabletop, thing,) _noun(tabletop, desktop, thing,)
  noun(fridge, thing,)   _noun(fridge, refridgerator, thing,)
  noun(microwave, thing,)   
  noun-irr(shelf, shelves, thing,) 
  noun(closet, thing,)
  noun(desk, thing,)
  noun(table, thing,)
  noun(chair, thing,)   
  noun(scenery, thing,) 
  noun(fax, thing,)   
  noun(machine, thing,) 
  noun(kettle, thing,) 
  noun-mass(scissors, thing,) 
  noun-mass(food, thing,) 

  # NOTE: How handle 'a water' and 'some water'??
 
  noun(chocolate, thing,)
  noun(tea, thing,) 
  noun(coffee, thing,) 
  noun(water, thing,) 
   
  #-- e-substance --#

  noun-mass(tea, e-substance,)
  noun-mass(coffee, e-substance,)
  noun-mass(chocolate, e-substance,) 
  noun-mass(water, e-substance,) 
  
  noun-mass(tee, e-substance,)
  noun-mass(iron, e-substance,)

  noun-mass(wood, e-material,) 
  noun-mass(metal, e-material,) 
  noun-mass(plastic, e-material,) 
	  
  #-- e-event --#

  noun(event,       e-event,) 
  noun(competition, e-event,) 
  noun(interaction, e-event,) 

  #-- e-location --#

  noun(place, e-place,) 
  noun(office, e-place,) 
  noun(room, e-place,)   
  noun(hall, e-place,)  _noun(hall, hallway, e-place,) _noun(hall, corridor, e-place,)
  noun(bathroom, e-place,) _noun(bathroom, washroom, e-place,) _noun(bathroom, toilet, e-place,) _noun(bathroom, wc, e-place,)
  noun(lab, e-place,)  _noun(lab, laboratory, e-place,) 
  noun(kitchen, e-place,) 
  noun(library, e-place,)
  noun(livingroom, e-place,)
  noun(recreationroom, e-place,)
  noun(library, e-place,)
  
  noun(secretariat, e-place,)
  noun(lobby, e-place,)
  noun(entrance, e-place,)
  noun(lift, e-place,) _noun(lift, elevator, e-place,)
  noun(stairs, e-place,) _noun(stairs, starecase, e-place,)
  noun(floor, e-place,)
  noun(way, e-place,)
  noun(direction, e-place,)
  noun(university, e-place,)
  noun(station, e-place,)   # must handle charging station

  # feature values cc-none and n-1, n-2, n-3 restrict the noun's behaviour in Noun-Noun Compounds
  #
  noun(location, e-place,)   noun+(of-np, location, e-place, n-1)
  noun(area, e-place,)       noun+(of-np, area, e-place, n-1)

  name(DFKI, e-place,)		  noun(DFKI, e-place,)
  name(Starbucks, e-place,) 	  noun(Starbucks, e-place,)

  #-- e-region --#

  noun(side, e-region,)    noun+(of-np, side, e-region, n-1)
  noun(edge, e-region,)    noun+(of-np, edge, e-region, n-1)
  noun(corner, e-region,)  noun+(of-np, corner, e-region, n-1)
  noun(beginning, e-region,)  noun+(of-np, beginning, e-region, n-1)
  noun(start, e-region,)   noun+(of-np, start, e-region, n-1)
  noun(end, e-region,)     noun+(of-np, end, e-region, n-1)	      
  noun(front, e-region,)   noun+(of-np, front, e-region, n-1)
  noun(back, e-region,)    noun+(of-np, back, e-region, n-1)
  noun(top, e-region,)     noun+(of-np, top, e-region, n-1)
  noun(bottom, e-region,)  noun+(of-np, bottom, e-region, n-1)
  noun(middle, e-region,)  noun+(of-np, middle, e-region, n-1)
  noun(section, e-region,) noun+(of-np, section, e-region, n-1)
  noun(part, e-region,)    noun+(of-np, part, e-region, n-1)
  
  #-- e-time --#
  
  noun(time, e-time,)
  noun-mass(time, e-time,)
  
  noun(second, e-time-unit,)    _noun(second, sec, e-time-unit,)  
  noun(minute, e-time-unit,)  
  noun(hour, e-time-unit,)   
  noun(week, e-time-unit,)   
  noun(day, e-time-unit,)   
  noun(month, e-time-unit,)   
  noun(year, e-time-unit,)   

  noun-mass(while, e-time-unit, cc-none)
  noun-mass(bit, e-time-unit, cc-none)


  #-- e-measure --#
  
  noun+(of-np, piece, e-measure, n-2)
  noun+(of-np, set, e-measure, n-2)
  noun+(of-np, pile, e-measure, n-2)
  noun+(of-np, few, e-measure, n-2)
  noun+(of-np, group, e-measure, n-2)
  noun+(of-n, kind, e-measure, n-2) _noun+(of-n, kind, sort, e-measure, n-2) _noun+(of-n, kind, type, e-measure, n-2)

  # ???? #   MUST BE GIVEN PROPER SORTS
 
  noun(name, entity, )  noun+(of-np, name, entity, cc-none )
  noun(case, entity, )  

  noun(color, entity, n-3) noun+(of-np, color, entity, cc-none ) _noun(color, colour, entity, n-3 ) _noun+(of-np, color, colour, entity, cc-none )
  noun(shape, entity, n-3) noun+(of-np, shape, entity, cc-none ) 
  noun(size, entity, n-3)  noun+(of-np, size, entity, cc-none )

  noun(question, entity, )    
  noun(answer, entity, )    
  noun(help, entity, )    
  noun(guidance, entity, ) 
  noun(aid, entity, ) 
  noun(suggestion, entity, ) 

  noun(look, entity, )   # used in 'take a look'
  noun(peek, entity, )

  

################
## ADJECTIVES ##
################


  #-- q-attitude --#

  adj-deg(good, better, best, q-attitude,)
  adj-deg(bad, worse, worst, q-attitude,)
  adj-deg(sorry, sorrier, sorriest, q-attitude,)
  adj-deg(cool, cooler, coolest , q-attitude,)
  adj-deg(guilty, guiltier, guiltiest, q-attitude,)
  adj-deg(happy, happier, happiest, q-attitude,)
  adj-deg(sad, sadder, saddest, q-attitude,)
  adj-deg(nice, nicer, nicest, q-attitude,)
  adj-deg(great, greater, greatest, q-attitude,)
  adj-deg(fine, finer, finest, q-attitude,)
 
  adj-none(sure, q-attitude,)  
  adj-none(ok, q-attitude,)  
  adj-none(important, q-attitude,)  
  adj-none(correct, q-attitude,)  
  adj-none(incorrect, q-attitude,) 
  adj-none(right, q-attitude,) 
  adj-none(wrong, q-attitude,)  
  adj-none(true, q-attitude,) 
  adj-none(false, q-attitude,)  
  
  adj-none(elongated,q-shape,)

  #-- q-size --#
  
  adj-deg(big, bigger, biggest, q-size,) 
  adj-deg(small, smaller, smallest, q-size,)
  adj-deg(tiny, tinier, tiniest, q-size,) 
  adj-deg(huge, huger, hugest, q-size,) 

  #-- q-color --#

  adj-deg(red, redder, reddest, q-color,)
  adj-deg(blue, bluer, bluest, q-color,)
  adj-deg(green, greener, greenest, q-color,)  
  adj-deg(yellow, yellower, yellowest, q-color,)  
    adj-deg(orange, oranger, orangest, q-color,)

  adj-deg(pink, pinker, pinkest, q-color,)
  adj-deg(black, blacker, blackest, q-color,)  
  adj-deg(white, whiter, whitest, q-color,)
  adj-deg(grey, greyer, greyest, q-color,)  
  adj-deg(brown, browner, brownest, q-color,)
  adj-deg(purple, purpler, purplest, q-color,)  

  adj-deg(dark, darker, darkest, q-color,)
  adj-deg(light, lighter, lightest, q-color,)  
  
  #-- q-shape --#
  
  adj-deg(long,longer,longest,q-shape,)
  adj-deg(short,shorter,shortest,q-shape,)
  adj-deg(tall,taller,tallest,q-shape,) 
  adj-deg(narrow,narrower,narrowest,q-shape,)   
  adj-deg(wide,wider,widest,q-shape,) 
  adj-deg(fat,fatter,fattest,q-shape,)   
  adj-deg(thin,thinner,thinnest,q-shape,) 
  adj-deg(round,rounder,roundest,q-shape,)  
  adj-none(oval,q-shape,) 
  adj-none(square,q-shape,)   
  adj-none(triangular,q-shape,)   


  #-- q-physical --#
 
  adj-none(open,q-physical,) 
  adj-none(closed,q-physical,) 
  
  adj-none(cluttered,q-physical,) 
  adj-none(accessible,q-physical,) 
  adj-none(inaccessible,q-physical,) 
  adj-none(reachable,q-physical,) 
  adj-none(unreachable,q-physical,) 
  adj-none(visible,q-physical,) 
  adj-none(invisible,q-physical,) 
  adj-none(graspable,q-physical,) 
  adj-none(ungraspable,q-physical,) 
  
  #-- q-location --#
  
  # NOTE: left & right, near & far are in directions (in prep) below
  
  adj-none(top,q-location,) 
  adj-none(bottom,q-location,) 
  adj-none(middle,q-location,) 
 
  #-- q-age --#
  
  adj-deg(old, older, oldest, q-age,)  
  adj-deg(young, younger, youngest, q-age,)
   
  #-- q-number --#
    
  # Numbers handled in dictionary-closed
  
  #-- q-position --#

  adj-none(first,q-position,) 
  adj-none(last,q-position,)
  adj-none(next,q-position,)
  adj-none(previous,q-position,)
  adj-none(other,q-position,) 
    
  #-- q-state --#
  
  adj-none(empty,q-state,) 
  adj-none(full,q-state,) 
  adj-none(hungry,q-state,)   
  adj-none(thirsty,q-state,)
  adj-none(tired,q-state,) 
  adj-none(finished,q-state,) 
  adj-none(started,q-state,)   
  adj-none(on,q-state,) 
  adj-none(off,q-state,) 
  adj-none(ready,q-state,)   
 	   	   
  # ???? #   MUST BE GIVEN PROPER SORTS

  adj-none(known,quality,)
  adj-none(unknown,quality,)

  adj-none(same,quality,)
  adj-none(raw,quality,)

  adj-none(meeting,q-purpose,)




############
## VERBS  ##
############
  
  # to block a verb from receiving an imperative reading, use ....-no-imp
  # e.g. verb-no-imp or verb-reg-no-imp
  
  #-- action-motion --#
  
  verb(go, going, went, gone, m-class-all, action-motion,                iv )
  verb(come, coming, came, come, m-class-all, action-motion,             iv )
  verb-reg(return, m-class-all, action-motion,                           iv )
  verb-reg(walk, m-class-all, action-motion,                             iv )
  verb-reg(turn, m-class-all, action-motion,                             iv )
  verb-reg(follow, m-class-all, action-motion,                           iv tv )
  verb-reg(pass, m-class-all, action-motion,                             iv )
  verb(move, moving, moved, moved, m-class-all, action-motion,           iv tv v+np+pp-whereto)
  
  verb(bring, bringing, brought, brought, m-class-all, action-motion,    iv )
  
 verb-reg(drive, m-class-all, action-motion,                           iv tv )

    
  #-- action-non-motion --#
  
  verb-reg(play, m-class-1, action-non-motion,                           iv tv) 
     # NOTE: Changed to m-class 1, aug 20, to allow 'how did we play the colour game'. Which how was meant here???
  verb(win, winning, won, won, m-class-2, action-non-motion,             iv tv)  
  verb(lose, losing, lost, lost, m-class-2, action-non-motion,           iv tv) 
  verb-reg(kill, m-class-2, action-non-motion,                           tv) 
  verb-reg(bother, m-class-2, action-non-motion,                         tv)
  
  _verb-no-imp(go-loc, go, going, went, gone, m-class-3, action-non-motion,       v+pp-loc)  # they go on the table. where does this go
  
  verb(buy, buying, bought, bought, m-class-1, action-non-motion,        tv dtv )
  verb(give, giving, gave, given, m-class-1, action-non-motion,          tv dtv dtv-to )
  
  #verb(get, getting, got, got, m-class-1, action-non-motion,             tv dtv dtv-to v+np+pp-whereto )
  #verb(take, taking, took, taken, m-class-1, action-non-motion,          tv v+np+pp-whereto)
  #verb(bring, bringing, brought, brought, m-class-1, action-non-motion,  tv dtv dtv-to v+np+pp-whereto )
  #verb-reg(fetch, m-class-1, action-non-motion,  tv dtv)
  
     verb-reg(remove, m-class-all, action-non-motion,  tv dtv)
     verb-reg(rotate, m-class-all, action-motion,  tv dtv)

  # NOTE: Aug 20, changed to m-class-all to allow parsing 'from', i.e. get me the ball from the table
  # 
  verb(get, getting, got, got, m-class-all, action-non-motion,             tv dtv dtv-to v+np+pp-whereto )
  verb(take, taking, took, taken, m-class-all, action-non-motion,          tv v+np+pp-whereto)
  verb(bring, bringing, brought, brought, m-class-all, action-non-motion,  tv dtv dtv-to v+np+pp-whereto )
  verb-reg(fetch, m-class-all, action-non-motion,  tv dtv)
  
  
  verb(eat, eating, ate, ate, m-class-1, action-non-motion,              iv tv)
  verb(drink, drinking, drank, drank, m-class-1, action-non-motion,      iv tv)
  
  verb(sleep, sleeping, slept, slept, m-class-1, action-non-motion,      iv )
  
  verb(stand, standing, stood, stood, m-class-1, action-non-motion,      iv )
  verb(sit, sitting, sat, sat, m-class-1, action-non-motion,             iv )
  verb-reg(wait, m-class-1, action-non-motion,                           iv v+for-np)
  
  verb(put, putting, put, put, m-class-1, action-non-motion,             v+np+pp-whereto )
  
  verb-reg(pick, m-class-1, action-non-motion,                           v+np+prt )
  verb(make, making, made, made, m-class-1, action-non-motion,           tv v+np+verb-base v+np+adj v+np+of-np-result v+np+from-np-result v+np+out_of-np-result)
  
  verb(find, finding, found, found, m-class-2, action-non-motion,            tv dtv) 
  verb(show, showing, shown, shown, m-class-2, action-non-motion,            tv dtv) 
  verb(explore, exploring, explored, explored, m-class-2, action-non-motion, iv tv) 
  verb-reg(search, m-class-2, action-non-motion,                             iv v+for-np)
     _verb-reg(search, look, m-class-2, action-non-motion,                   iv v+for-np)
  verb(find, finding, found, found, m-class-2, action-non-motion,            iv tv) 
  
  verb-reg(help, m-class-2, action-non-motion,                           tv v+np+verb-base)
  verb(use, using, used, used, m-class-2, action-non-motion,             tv v+instrumental-np+verb-inf) 
  verb-reg(fix, m-class-2, action-non-motion,                            tv)
  verb(break, breaking, broke, broke, m-class-2, action-non-motion,      tv) 
  
  #-- cognition --#
  
  verb(know, knowing, knew, known, m-class-3, cognition, iv tv v+adj v+pp v+dep-clause)
  verb(understand, understanding, understood, understood, m-class-3, cognition, iv tv v+adj v+pp v+dep-clause )
  
  # DO WE NEED TO SEPARATE THESE UP ON THEIR TYPE i.e. Modal vs Not
  
  verb(mean, meaning, meant, meant, m-class-3, cognition,         tv v+verb-inf v+dep-clause)
  
  verb-reg(want, m-class-3, cognition,                                    tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb-reg(need, m-class-3, cognition,                                    tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb(like, liking, liked, liked, m-class-3, cognition,                  tv v+verb-inf v+np+verb-inf v+np+pp-loc v+np+adj) 
  verb(memorize, memorizing, memorized, memorized, m-class-3, cognition,  tv)
  
  verb(assume, assuming, assumed, assumed, m-class-3, cognition,         v+dep-clause)
  verb(hope, hoping, hoped, hoped, m-class-3, cognition,                 v+dep-clause v+verb-inf) 
  verb(suppose, supposing, supposed, supposed, m-class-3, cognition,     v+dep-clause v+verb-inf)
  verb(think, thinking, thought, thought, m-class-3, cognition,          v+dep-clause)
  verb(believe, believing, believed, believed, m-class-3, cognition,     v+dep-clause)
  verb(imagine, imagining, imagined, imagined, m-class-3, cognition,     v+dep-clause)
  verb(bet, betting, bet, bet, m-class-3, cognition,                     v+dep-clause)
  verb-reg(guess, m-class-3, cognition,                                  v+dep-clause)
  verb(figure, figuring, figured, figured, m-class-3, cognition,         v+dep-clause)
  
  #-- communication --#
  
  verb(tell, telling, told, told, m-class-2, communication,              tv v+np+verb-inf v+np+dep-clause dtv dtv-to v+np+pp-loc)
  verb-reg(ask, m-class-2, communication,                                iv tv v+np+verb-inf v+np+dep-clause dtv dtv-to v+np+pp-loc)
  verb(say, saying, said, said, m-class-2, communication,                iv v+dep-clause)
  verb-reg(explain, m-class-2, communication,                            tv dtv dtv-to)
  verb-reg(talk, m-class-2, communication,                               iv v+to-np v+with-np)
  verb(speak, speaking, spoke, spoke, m-class-2, communication,          iv v+to-np v+with-np)
  
  verb (excuse, excusing, excused, excused, m-class-2, communication,    tv dtv-for v+Rec-np+for-verb-ing)
  verb-reg(pardon, m-class-2, communication,                             tv dtv-for v+Rec-np+for-verb-ing)
  verb(thank, thanking, thanked, thanked, m-class-2, communication,      dtv-for v+Rec-np+for-verb-ing)
  word thanks-verb: Thanks(communication, pred=thank) { thanks: m-class-5 fin pres s-pos ; thank_you: m-class-5 fin pres s-pos;}
     # special verb family which creates indicative with <recipient>addressee and <actor>speaker
     # m-class5 blocks all modification but comments
  
  #-- perception --#
  
  def per-fams() {iv tv v+np+verb-base v+np+verb-ing v+deictic-event} 
  
  verb(see, seeing, saw, seen, m-class-2, perception,                   per-fams() )
  verb-reg(watch, m-class-2, perception,                                per-fams() )
  verb-reg(look, m-class-2, perception,                                 per-fams() v+adj )
  verb(observe, observing, observed, observed, m-class-2, perception,   per-fams() )
  
  verb-reg(listen, m-class-2, perception,          iv v+to-np)
  verb(hear, hearing, heard, heard, m-class-2, perception,              per-fams() )
  verb-reg(sound, m-class-2, perception,                                v+adj )
  
  verb-reg(touch, m-class-2, perception,                                tv)
  verb(feel, feeling, felt, felt, m-class-2, perception,                tv v+adj)
  
  #-- symbolic --#
  
  verb-reg(call, m-class-2, symbolic,                           tv )
  verb(name, naming, named, named, m-class-2, symbolic,         tv )
  
  #-- state --#
  
  verb-basic(have, has, having, had, had, m-class-2, ascription,           tv )
  verb(feel, feeling, felt, felt, m-class-2, ascription,                   v+adj )
  verb(get, getting, got, got, m-class-2, ascription,                      v+adj )
  verb(become, becoming, became, become, m-class-2, ascription,            v+adj )
  
  #-- event --#
  
  verb-reg(happen, m-class-2x, event,   iv v+to-np )
  
  #-- modal/aspectual verbs --#
  
  # These verbs have two entries. 1 is for the case where the 'aspectualized' event is
  # explicitly mentioned (e.g. I continued going down the hall). The second receives only
  # an 'implicit' event, (e.g. I continued down the hall)
  # The first is blocked to m-class-3 so that its event comp will receive the modifiers
  # In the second case, since there is no explicit verb here, the aspect verb
  # must be free for any kind of modification (m-class-all)
  
  verb(keep, keeping, kept, kept, m-class-3, modal,                    v+verb-ing v+np+verb-ing) 
  verb(keep, keeping, kept, kept, m-class-all, modal,                  iv)
  
  verb(continue, continuing, continued, continued, m-class-3, modal,   v+verb-inf v+verb-ing ) 
  verb(continue, continuing, continued, continued, m-class-all, modal, iv)
  
  verb(try, trying, tried, tried, m-class-3, modal,                    v+verb-inf v+verb-ing ) 
  verb(try, trying, tried, tried, m-class-all, modal,                  iv) 
  
  verb-reg(start, m-class-3, modal,                                    v+verb-inf v+verb-ing v+np+verb-ing) 
  verb-reg(start, m-class-all, modal,                                  iv)
  
  verb(begin, beginning, began, begun, m-class-3, modal,               v+verb-ing) 
  verb(begin, beginning, began, begun, m-class-all, modal,             iv) 
  
  verb-reg(restart, m-class-3, modal,                                  v+verb-ing v+np+verb-ing) 
  verb-reg(restart, m-class-all, modal,                                iv)
   
  verb-reg(finish, m-class-3, modal,                                   v+verb-ing v+deictic-event) 
  verb-reg(finish, m-class-all, modal,                                 iv) 
  
  verb(stop, stopping, stopped, stopped, m-class-3, modal,             v+verb-ing v+np+verb-ing v+deictic-event) 
  verb(stop, stopping, stopped, stopped, m-class-all, modal,           iv)
   
  verb(quit, quitting, quit, quit, m-class-3, modal,                   v+verb-ing v+deictic-event) 
  verb(quit, quitting, quit, quit, m-class-all, modal,                 iv) 
  
  verb-reg(got, m-class-3, modal,                                      v+verb-inf)
  verb(have, having, had, had, m-class-3, modal,                       v+verb-inf)
  
  verb-reg(happen, m-class-3, modal,                                   v+verb-inf)
  verb-reg(seem, m-class-3, modal,                                     v+verb-inf)

  verb(let, letting, let, let, m-class-4, modal,                       v+np+verb-base)
  
  adjectival-verb(able, m-class-3, modal,    v+verb-inf)
  adjectival-verb(willing, m-class-3, modal, v+verb-inf)
  adjectival-verb(supposd, m-class-3, modal, v+verb-inf)


##################
## PREPOSITIONS ##
##################

#-- Location & Dynamic --#

  prp(at, location, prep-all)

  prp(onto,  whereto, prep-2)
  prp(into,  whereto, prep-2)
  prp(toward,  whereto, prep-2) _prp(toward, towards, whereto, prep-2) 

  prp(from, wherefrom, prep-2) # dynamic event reading      (I went from the office to the kitchen)
 # prp(from, location, prep-3)  # static locational reading  (the girl from the office is nice)
  prp(off, wherefrom, prep-2)
  prp+(of-np, out, wherefrom, prep-2)

  prp(through, through, prep-2)
        prp+(no-arg, through, direction, prep-2)    
  prp(across, through, prep-2)
        prp+(no-arg, across, direction, prep-2)    

  ## Restricts sort of anchor to e-region (i.e. to the right, to the corner)
  prp--(region, to, location, prep-all)   prp(to,  whereto, prep-2)
										      
  prp(on, location, prep-all)        prp(on, whereto, prep-2)
  prp(around, location, prep-all)    prp(around, whereto, prep-2)
       prp+(no-arg, around, direction, prep-2)    
  prp(beside, location, prep-all)    prp(beside, whereto, prep-2)
  prp(over, location, prep-all)      prp(over, whereto, prep-2)
  prp(above, location, prep-all)     prp(above, whereto, prep-2) 
  prp(under, location, prep-all)     prp(under, whereto, prep-2) 
     _prp(under, underneath, location, prep-all)             _prp(under, underneath, whereto, prep-2) 
  prp(below, location, prep-all)     prp(below, whereto, prep-2) 
  prp(by, location, prep-all)        prp(by, whereto, prep-2) 
  prp(behind, location, prep-all)    prp(behind, whereto, prep-2) 
  prp(up, location, prep-all)        prp(up, whereto, prep-2) 
      prp+(no-arg, up, direction, prep-2)    
  prp(down, location, prep-all)      prp(down, whereto, prep-2) 
       prp+(no-arg, down, direction, prep-2)      
  prp(along, location, prep-all)     prp(along, whereto, prep-2)
     _prp(along, alongside, location, prep-all)             _prp(along, alongside, whereto, prep-2)  # alongside
  prp(opposite, location, prep-all)  prp(opposite, whereto, prep-2) 
  prp(between, location, prep-all)   prp(between, whereto, prep-2) 

  prp+(to-np, next, location, prep-all)   prp+(to-np, next, whereto, prep-2) 

  prp+(of-np, in_front, location, prep-all)   prp+(of-np, in_front, whereto, prep-2) 
  prp+(of-np, in_back, location, prep-all)    prp+(of-np, in_back, whereto, prep-2) 
  prp+(of-np, on_bottom, location, prep-all)    prp+(of-np, on_bottom, whereto, prep-2) 
  
  prp(in, location, prep-all)        prp(in, whereto, prep-2) 
      prp+(no-arg, in, direction, prep-2) 
      _prp(in, inside, location, prep-all)             _prp(in, inside, whereto, prep-2) 
      _prp+(no-arg, in, inside, location, prep-all)    _prp+(no-arg, in, inside, whereto, prep-2) 

  prp(out, location, prep-all)        prp(out, whereto, prep-2) 
       prp+(no-arg, out, direction, prep-2)     
      _prp(out, outside, location, prep-all)             _prp(out, outside, whereto, prep-2) 
      _prp+(no-arg, out, outside, location, prep-all)    _prp+(no-arg, out, outside, whereto, prep-2) 

  #----MACRO----
  #
  # This gives 1) right of the table  2) to the left of the table  3) to the right
  #
  def direction-word(loc) {
           prp+(of-np, loc, location, prep-all)    prp+(of-np, loc, whereto, prep-2) 
		   prp+(no-arg, loc, direction, prep-2)  
	 	   noun+(of-np, loc, e-region, cc-none)
		   noun(loc, e-region, cc-none)
   	 	   adj-none(loc, q-location, )
  }

  direction-word(right)
  direction-word(left)
  direction-word(front)
  direction-word(back)

  prp+(no-arg, forward, direction, prep-2)  _prp+(no-arg, forward, forwards, direction, prep-2)
  prp+(no-arg, backward, direction, prep-2) _prp+(no-arg, backward, backwards, direction, prep-2)
  prp+(no-arg, straight, direction, prep-2) 
  prp+(no-arg, aside, direction, prep-2) 
  prp+(no-arg, away, direction, prep-2) 

  #----MACRO----
  #
  # This gives 1) the near ball 2) push it nearer 3) push it nearer to you 4) I am nearest to you
  #  
  def prep-adj(base, er, est, obl-marker) {
           prp-deg+(no-arg, base, er, est, location, prep-2)    prp-deg+(obl-marker."-np", base, er, est, location, prep-all) 
		   prp-deg+(no-arg, base, er, est, whereto, prep-2)     prp-deg+(obl-marker."-np", base, er, est, whereto, prep-2) 
		   adj-deg(base, er, est, q-location, )
  }

  prep-adj(far , farther , farthest, from) 
  prep-adj(near, nearer, nearest, to)  
        prp(near, location, prep-all)      prp(near, whereto, prep-2)  # near the stairs vs. near to the stairs
  prep-adj(close , closer , closest, to)  


  #-- time --#
  
  prp--(time-unit, for, time-interval, prep-4)
  prp--(time-unit, in, time-point, prep-4)

  #-- other --#
  
  prp(for,  benefactor, prep-1)
  prp(with, accompaniment, prep-1)
  prp(with, instrumental, prep-1)
  prp(like, comparison, prep-1)

  

################
## ADVERBS    ##
################

  #-- m-time --#

  #---- time-point
  
  adverb(now, time-point, adv-1,)

  word now2-adv:Adv(m-time-point, pred=now) {
      No : x-time-point adv-1 asr-correction;
    }

  word now3-adv:Adv(m-time-point, pred=now) {
      not : x-time-point adv-1 asr-correction;
    }

  adverb(today, time-point, adv-3,)
  adverb(yesterday, time-point, adv-3,)
  adverb(tomorrow, time-point, adv-3,)
  adverb(yesterday, time-point, adv-3,)
  adverb(tomorrow, time-point, adv-3,)
  adverb+(dep-clause, when, time-point, adv-1,)
  adverb+(dep-clause, until, time-point, adv-1,)
      prp--(time-unit, until, time-sequence, prep-4)  # Time unit Preposition
  adverb(since, time-point, adv-1,)	  
  adverb+(dep-clause, since, time-point, adv-1,)
      prp--(time-unit, since, time-point, prep-4,)
	  
  #---- time-sequence

  adverb(next, time-sequence, adv-1,)
  adverb(first, time-sequence, adv-1,)
  adverb(then , time-sequence, adv-5,)

  adverb(after , time-sequence, adv-4,) _adverb(after, afterwards, time-sequence, adv-1,)
     adverb+(dep-clause, after, time-sequence, adv-1,)
     adverb+(verb-ing, after, time-interval, adv-6,)   
     prp--(time-unit, after, time-sequence, prep-4)
  adverb(before , time-sequence, adv-4,) _adverb(before, previously, time-sequence, adv-1,)
     adverb+(dep-clause, before, time-sequence, adv-1,)
     adverb+(verb-ing, before, time-interval, adv-6,)
     prp--(time-unit, before, time-sequence, prep-4)
      

  #---- time-interval

  adverb+(dep-clause, while, time-interval, adv-1,)
     adverb+(verb-ing, while, time-interval, adv-6,)
 
  #---- other time

  adverb-deg(soon, sooner, soonest, time, adv-all,)
  adverb-deg(early, earlier, earliest, time, adv-3,)
  adverb-deg(late, later, latest, time, adv-3,)

  adverb(still, time, adv-all,)
  adverb(already, time, adv-all,)
  adverb(just, time, pre-vp,)
  adverb(yet, time, adv-4,)
  adverb(ever, time, adv-6,)

  #-- m-manner --#
 
  adverb(quickly, manner, adv-all,) _adverb(quickly, quick, manner, adv-all,) _adverb(quickly, fast, manner, adv-all,)
  adverb(slowly, manner, adv-all,)  _adverb(slowly, slow, manner, adv-all,)

  adverb(go, manner , adv-5,)
  adverb(run, manner , adv-5,)
  adverb(come, manner , adv-5,)  
  
  
  #-- m-probability --# 

  adverb(maybe, probability, adv-all,)
  adverb(possibly, probability, adv-all,)
  adverb(probably, probability, adv-all,)
  adverb(perhaps, probability, adv-all,)
  adverb(certainly, probability, adv-all,)
  
  #-- m-frequency --#
  
  adverb(normally, frequency, adv-all,)
  adverb(usually, frequency, adv-all,)
  adverb(occasionally, frequency, adv-all,)
  adverb(often, frequency, adv-all,)
  adverb(seldom, frequency, adv-all,) 
  adverb(rarely, frequency, adv-all,)  
  adverb(always, frequency, adv-all,)
  adverb(never, frequency, adv-all,)
  adverb(sometimes, frequency, adv-all,)
  
  adverb(again, frequency, adv-all,)
  
  #-- m-comment --#

  adverb(please, comment, adv-7,)
  adverb(kindly, comment, adv-7,)
  adverb(actually, comment, adv-all,)
  adverb(really, comment, adv-3,) 
  adverb(also, comment, adv-all,) _adverb(also, too, comment, adv-2,)

  #-- m-relational --#
 
  adverb+(dep-clause, if, condition, adv-1,)
  adverb+(dep-clause, because, cause, adv-1,)
 # adverb+(dep-clause, so, result, adv-1,)
      

#######################
## DISCOURSE MARKERS ##
#######################


  dis-marker(right, marker)
  dis-marker(yes, marker)
  dis-marker(ok, marker) _dis-marker(ok, okay, marker)
  dis-marker(No, marker)
  dis-marker(sure, marker)
  dis-marker(alright, marker)
  dis-marker(alrighty, marker)
  dis-marker(okidokey, marker)
  dis-marker(okido, marker)
  dis-marker(well, marker)
  dis-marker(huh, marker)
  dis-marker(um, marker)
  dis-marker(but, marker)
  dis-marker(and, marker)
  dis-marker(so, marker)

 # dis-marker(now, marker)

  _dis-marker+(and, then,marker,asr-correction)

  dis-marker(fine, marker)

  dis-marker(good, marker)
  dis-marker( "," , marker)
  dis-marker( sorry , marker)
  dis-marker( hi , greeting)  dis-marker+np( hi , greeting)
  dis-marker( hello , greeting)  dis-marker+np( hello , greeting)
  dis-marker( bye , closing)  dis-marker+np( bye , closing)
  dis-marker( ciao , closing)  dis-marker+np( ciao , closing)
  dis-marker( good_bye , closing)  dis-marker+np( good_bye , closing)
  dis-marker( so_long , closing)  dis-marker+np( so_long , closing)
  

###################
## MOD-MODIFIERS ##
###################

  modifier(really, adj, pre, intensity )
  modifier(really, adv, pre, intensity )
  modifier(too, adj, pre, intensity )
  modifier(too, adv, pre, intensity )
  modifier(very, adj, pre, intensity )
  modifier(very, adv, pre, intensity )

  modifier(much, adj-comparative, pre, intensity)

  modifier(over, prep, pre, direction )
  modifier(away, prep, pre, direction )
  modifier(up, prep, pre, direction )
  modifier(down, prep, pre, direction )
  modifier(straight, prep, pre, direction )
  
  modifier(right, prep, pre, manner )
  modifier(up, prep, pre, manner )





# NOTE: In some of the cases below, the 'expected' number of parses will be incorrect
#       This is because as new features get added, old ones removed, these numbers fluxuate
#       this is especially true with various 'discourse phenomena' and 'complex constructions'

testbed {

  # And now on to the show....

  ####################################
  # The 3 moods & INCREMENTAL PARSES #
  ####################################

  # Indicative #

  # Indicative mood is no longer attributed to an utterance by its verb.
  # Instead, it is handled by type-changing rule which, essentially, adds
  # some semantics to your standard np type-raising rule.
  # Any 'floating' np can become the <Subject> of an indicative clause waiting for its verb+args (vp)

  # Motivation: 1) early projection. When we 'see' an NP in first position in the clause we know it is
  # either the 'Subject' of indicative, or it is a fronted object, or pre-np. See end of this for 
  # these cases. Thus, there is no reason to 'wait' for the verb to explicitly represent this info
  #             2) semantic integration. By placing the subject in a semantic slot, we now can avoid
  # multiple un-integrated semantic fragments in simple sentences. Specifically 'I really' now recieves
  # an integrated reading, which 'knows' it is part of a yet unspecified event.
  #

  # An example 

  the: 6 ;                                            # free-np, subj-np of ind-clause, fronted-np of ind-clause, etc      x 2 for 2 readings of the
  the pizza: 3 ;                                      # lose the plural readings of the
  the pizza on: 3;                                    # "
  the pizza on the: 6;                                # 2 readings of the
  the pizza on the big: 6;                            # "
  the pizza on the big red: 6;                        # "
  the pizza on the big red table: 3;                  # lose the plural reading of the
  the pizza on the big red table makes : 4;           # 4 readings of make ( make dinner, make me run, make me hungry (this one has 2 readings see verbs.ccg) ) 
  the pizza on the big red table makes me : 3;        # "
  the pizza on the big red table makes me hungry: 1;  # 
  
  
  # Interrogatives #
  
  # Wh-questions are controlled by their Wh-word, i.e. the first word projects the structure of the clause.
  # Moreover, to allow fully integrated incrental parsing, they 'select for' (i.e. have syn and/or sem slots for)
  # the auxillary (which then fills in tense, aspect, verbal-agreemnt, polarity, etc), the 'Subject' and then
  # the 'verb missing an arg' 
	
  # Note: Currently, only arguments, not modifiers, can be wh questioned. We can't handle 'extracted optional elements'
  #       Of course, you can question pp args, like 'who did you walk with', b/c once they 'attach' to the verb, their
  #       argument is treated as any old missing arg.
  #       As a hack to handle where questions for motion verbs, I added to each a verbal family with an explicit <Dynamic>
  #       argument. So you can now ask  Where are you going?  BUT NOT where are you playing?
  		  
  # An example (note increase of readings in 4 -> 5)
    
  what: 4;                              # aux-obj, aux-sent-comp, subj, copular-obj
  what did: 4;                          # aux-obj, aux-sent-comp, subj (with did as aux), subj (with did as proverb, e.g. What did it )
  what did GJ: 2;                       # aux-obj, aux-sent-comp
  what did GJ see: 1;                   # aux-obj (transitive reading of see)  
  what did GJ see under: 2;                # aux-obj (transitive reading of see), prep-arg (intranstive reading of see)  
  what did GJ see under the: 2;         # aux-obj (transitive reading of see) with 2 readings of the
  what did GJ see under the table: 1;   # aux-obj (transitive reading of see)

  # Y-N Questions

  # Here, the aux, as first element, controls the mood.
  # Much like Wh-words, it selects for subject & then vp.
  
  are: 32;            # yeah... it's the be-verb and this english, whaddya expect
  are you: 22;        # still loads of possibilities
  are you coming: 4;  # sg/pl for you, with/out dynamic (see above)
 
  # Imperatives (and alighted Subjects) 

  # as the verb is the first element in an imperative clause, it controls the clause.
  # this should be done as it was in moloko, i.e. with a separate verbal category and hence lexical family for each verb.
  # HOWEVER, b-c it would lead to sheer messiness under Dot-CCG, I've added type-changing rules for this...sigh....
    
  # Also, by building verbs like this s\np /args instead of s /args \np  we will necessarily get all of the 'missing subject'
  # readings. I did, however, shut off the subject slot (via !), so we don't see them in other places.
  # A simple way to prune these silly readings is to check the mood. If it is un-specified, prune it. All readings that we 
  # want will have a mood specified somehow (via rule, or via lexical items)
  # For this reason, I added an 'alighted subject' reading as well. (see verbs.ccg for arguments for this.. can still of course remove)
	
  # NOTE: what should we 'call' the alighted subj & imperative actor (currently have em as context, see context entities below)
  #       what about the tense of imperatives? obviously its a silly question, and answering it gets into silly philosophical discussions.
  #       I left it out, is that ok?	
	
  go: 4;                        # imp-parse, 3 moodless parses (base, pl, 2nd-singular, see above)
  go over: 30;                  # ummmmm... as it stands, with so many independent dep reln names being used for modifers (location, dynamic, etc) 
                                # mod-modifiers like over lead to an explosin in readings 
  go over to: 5;                # lose all but <dynamic>, get 1 imp and 4 moodless...
  go over to your: 10;          # x2 b/c of sg-pl versions of your
  go over to your station: 10;  # "

   
  #########################################
  # Participant Roles/Argument Structures #
  #########################################
  
  I slept: 1;                   # iv
  
  I want it: 4;                 # tv

  give me the ball: 4;          # dtv
  give the ball to GJ: 4;     

  I picked it up: 1;  # object + particle 
  I picked up the ball: 1;
 
  I want it bigger: 1;          # resultant 'state'
  make it black: 4;

  I want it on the table: 2;    # 'goal'  (second reading is a post-np, see below)
  put it on the table:    4;  

  I want to sleep: 1;              # event compliment (subj controlled inf)
  I want the robot to sleep: 2;    #                  (obj controlled inf)
  I made it move off the table: 1; # base
  keep moving: 16;                 # ing  (1 of these many parses is the simple s imperative                  
  stop moving: 16;
  I said I wanted to sleep: 1;     # s
   	    	   
  # Special
  
  # 'use X to do Y' Subj controlled inf-verb with patient as instrument

  # Note: These kinds of specialized arg structures are actually quite easy to add
  #       So if anyone think of anymore similar ones they'd like to add... 
  
  you use it to make coffee: 6;                  # open readings for make
  you can use them to pick things up: 2; 


  #############
  # Modifiers #
  #############
 
  ## Modifiers themselves ## 
 
  # Modifiers begin as atomic cats with a semantic index of their own
  # via type-changing rules, the can be 'transformed' into complex cats for use in modifying
  #     the combinatorial possibilities are lexically specified via CC-TYPE (complex-cat type)
  #     see types-features.ccg   
      
  on the table: 8; # Prep-it can modify an entity as <Location>, or event as <Location> or <Dynamic> in multiple syntactic positions  
  big: 2;          # Adj-it can only modify entities as <Property>
  
   
  ## Modifying Modifiers ##
  
  # because modifiers always begin as atomic cats, 'before' they are transformed they can be modified
  # thse mod-modifiers latch onto the atomic cat's index.
  
  over on the table: 8;   
  really big: 2;


  ## Using the Modifiers ##

  # As modifiers (the rule-generated complex cat is used) #

  the ball: 3;
  the ball on the table: 3;
  the ball over on the table: 3;
  
  the big ball: 3;
  the really big ball: 3; 
   	 
  I slept: 1; 
  I slept on the table: 1;
  I slept over on the table: 1;
      
  # As compliments to verbs (the original atomic cat form used) #
  
  the ball is big: 1;
  the ball is really big: 1;

  I want it big: 1;
  I want it really big: 1;
	    
  the ball is on the table: 1;
  the ball is over on the table: 1;
		
  I want it on the table: 1;
  I want it over on the table: 1;

  ## Blocking Modifiers ##

  ## Each verb has the right to choose its own 'potential modifiers', i.e., semantically restrict what kinds 
  ## of things it can take. See the m-class in types-features.ccg for list of restriction classes.
  
  # Although Nouns, nor Modifiers are doing this right now, could in theory be implemented quite naturally.
  
  I am happy to the the table: 0;  # copulars can't take dynamics
  I want it to the table: 0;       # neither can 'want' like modal/cog verbs
  I went to the table: 1;          # motion verbs can
  
  I want it on the table: 1;       # this is a <goal> participant of want, but still blocks dynamic on.
  I walked on the table: 3;           # currently motion verbs like this accept <location> (static) and <dynamic> readings
  								   # Note: 3rd reading is due to hack handling of where questions..... 
		
			   
    ## NOTE: A Suggestion ##
  
  # As it stands, we are using quite a few different dependency relations for 'optional modifiers'
  #   ex. <Dynamic>  <Location>  <Time>  <Property> as well as the more general <Modifer>

  # Instead, I suggest a single dependency relation (call it whatever you want to, <Modifer> is as good as any)
  # which is used for each and every semantic relation. 
  # The nature of the relation is specified by the ontological sort of the relation only.
  #      so <Modifier>(m:color green)  <Modifier>(m:location on ...) <Modifier>(m:where-to onto <Arg> ...)
  # The hierarchical information, i.e. that where-to is a dynamic, that color is a physical-property which is a property
  # will be handled exclusively in the ontological sort hierarchy. Hence, external use will need to look this up
  # instead of merely checking the dep-reln name.
  #
  # In the case of these same 'modifiers' playing sem-roles in arg structure, then we would need either one or more
  # different names (like <Goal> or whatever) to handle these. This has the added benefit of allowing post-processing
  # to know whether a locational was selected for and hence playing a core role, or was merely a 'modifier'
  #     e.x.
  # 'I want it on the table'  should not be interpreted as a want event located on the table, but instead like 'put' with a 
  #  'goal' type locational argument.
  #
   
  # Here are some reasons for why I think the single modifer dep-reln is a good idea:
  
  # 1) Uniformity:
  #       -we are already using the type hierarchy to handle the vast majority of different kinds
  #        of dep-relns, e.g. instrument, accompaniment, comment, etc
  #       -this would allow me to clean up some of the grammar by removing multiple 'checks'
  #	       i.e. if you are a location modifier, then become <Location>, if dynamic.....
  #              else <Modifier>		
  #       -modification of the dependency-relation hierarchy would have much less impact on the grammar
  #        as it stands, if we decide to add 'instrument' as dep-reln (instead of say sub-type of modifier)
  #        this would require going in and building a family. If we unify, just have to add to sort-hierarchy
  #        and then to the new dictionary items.
  #
  # 2) Information Redundancy:
  #       As it stands, we have readings like this <Location>(m:location on ...) & <Time>(m:time before ...) 
  #       And as mentioned above, even in cases like <Dynamic>(m:where-to onto...) the sub-type info provided
  #       here is already available in the sort-hierarchy
  #
  # 3) Parse reduction:
  #       We currently get crap loads of readings for 'pre-modifier modifiers' like 'over on the table' or 'really'
  #       The reason, is that as 'over' doesn't know if it is modifying a dynamic, a location, or whatever, then
  #       it gets a reading for each possibility. Even if we eventually 'restrict' these modifiers to only modify 
  #       the correct kinds, we'll still get one reading for each of these dependency-reln 'ambiguities'.
  #       Compare this to if we had a different 'category' for animates and inanimates, then big would be ambiguous
  #       to these two readings and have to generate both readings
  # 
  # 4) Simplification of the Copular
  #       By returning to a uniform treatment of 'things which modify nouns', I could then revert to the much
  #       cleaner copular which takes adj and pps instead of the complex ugliness we had in older moloko
  #       This would mean much easier uniform handling of questions, among other things.
  #             (note: I actually have this simpler version of copulars implemented, but could change back
  #                    to the more complex version from old moloko)
  # 
  
					   
						   	   
  ###############
  # The Copular #
  ###############

  # Adj 
  it is big: 1;
  it "isn't" big: 1;
  is it big: 1;
  what is big: 1;
  how is it: 2;    # 2nd reading with is as aux-verb

  # With NP
  it is a ball: 1;
  is it a ball: 1;
  what is a ball: 4; # question subj, obj & two other readings with is as aux-verb 
  what is it:     4;   
 
  # with PP
  it is under the table: 1;
  is it under the table: 1;
  where is it: 4; 

  # verbal-adjectives
  
  I am able to walk:    2;
  am I able to walk:    2;

  # inverted locational
  under the table is a ball: 4;  # 1 inverted locational, 3 y-n with fronted locataional , e.g. under the table is there a cat?

  # presentationals
  
  there is a ball: 2; # normal and inverted locational
  there were some balls: 2;
  there are a ball: 0;
  there is a ball on the table: 2;
  is there a ball: 1;  
  is there a ball on the table: 2;
  what is there: 1;
  where is there a ball: 1;
  
  # note that dummy subj doesn't overgenerate
  there walked in: 0;
  there is big: 0;


   


  
  #######################################################
  # Entities: Context Entities, Determiners and Groups  #
  #######################################################
							   		    	  
  # Context Entities #
  
  # I have modified and extended the old Moloko treatment of context nps. Before, we were
  # handling them in two ways:
  # 1) by attaching a dependency relation containing the entities semantic features
  # with some sort of outside 'Shell' 
  #   e.g.    one      @entity(one <Context> (<num, spec, delim>) )
  # 2) with a ontological type of 'discourse-deictic'
  #   e.g.    this     @discourse-deictic(this <proximity, spec, det, num> )
  #
  # I have unified these two types of contextual entities together with a few others (more below)
  # and given them a simpler and more info-rich representation. First, some issues with these
  # two old treatments
  
  # First, 1) was quite difficult to pull off, in the sense, it required gerry-rigging a lot 
  # of extra categories, and as I wanted to expand the idea of contextual entities, it was a pain
  # As well, when these shell nps were modifed 'big one', the 'semantic head' was the outside entity
  # and hence the modifying information was separate from the lexically specified features.
  # Second, 2) has the problem of loosing the ontological info that it is an entity. Furthermore, if
  # we eventually want more semantically refined types of context nps, then this info wouldn't
  # be visible (see also Context Events below)

  # New represenation:  A context entity is exactly like any other entity except its propisition is 
  # the word context. i.e. all of its 'grounding features' (num, spec, prox, etc) are there, along
  # with any modifiers, the only thing that needs to be contextually found is the 'head', or the info
  # that would be given in the 'nominal class'.
  
  # So....  this (as deictic entity)
  #         @entity(context <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  # what is nice is that now it has exactly the same semantics as 'determiner' this, except 'head' is filled in by context
  # i.e. compare with
  #			this       np/n
  #         @entity(     <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)       
  #         this ball  np
  #         @entity(ball <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  # and further, this as 'event deictic' only differs in its ontological sort.
  #         @event(context <Proximity>proximal <Num>sg <Quantification>specific_singular <Delimination> unique)
  #
  
  # Besides context being used in deictics, it is also used with
  #   1)'discourse one' 
  #   2) numbers (both cardinal and ordinal) 
  #   3) in some Wh-questions (see below)
  #
  #  NOTE: We could extend this to cover other things like some adjectives ('colors' I want the green, etc)
 
  # GROUPS #
    
  # In addition, I have added the handling of 'subgroups' of specified groups.
  #  e.x. one of the balls,   some of GJ's money,   the first of the three balls.
  # 
  # The basic semantics is:    @entity(group
  #                                    'subset specifying info'									
  #                                    <Set>(info specifying the set)
  #
  # subset specifying info is handled by the 'pre-of' stuff (one, some, first, etc)
  # and the set info, by the 'post-of' stuff.
  # So in the cases, like some, where there is no propositional info attached, then only features 
  # at top level. In other case, like numbers, it is contained in a <Modifier>() at this level.  
		
  this: 11;  # 'this' can be det, context-np, context-event from above. Multiply for each slot
  this ball: 5;
  the this ball: 0;
  this of the balls: 0;
  
  some: 20;  # 'some' can be det (sg, pl), context-np(pl), and set-selector(pl)
  some balls: 9;
  the some balls: 0;
  some of the balls: 9;

  two: 22;  #  cardinals can be a det, context-np, context-n set-selector and simple modifier
  two balls: 19;
  the two balls: 9;
  two of the balls: 5;
  those two: 26;

  the third: 20;  # ordinals can be context-n, set-selector, and simple modifier
  the third ball: 5; 
  the third of the three balls: 9; 
  third ball is big:0 ;  # but they can't be dets
  
  the green ones: 5; # ones is a generic plural context-n
 	  
  # Left to do: What about nothing, none, etc... how should we handle these?	  

  ##################
  # Context Events #
  ##################
    
  I "didn't" say that: 6;   # 1 of these readings is an s, the rest are treating 'that' as 
                            # the subj/front np (or its det) of the sent comp
 
  who said it:  3;        # similar, but no det readings
  what did he say: 1;

  # pro-verb do #
  
  # NOTE: what should the prop be for this?  
  
  I "didn't" do it: 1;
  I do I went: 0;                # the event compliment to accept context-events, so         
  who did this: 1;
  what is he doing: 1; 
  what is he doing with the ball: 1; 

  # Subj+Aux with context main events.
  
  I will: 2;
  I do : 2;
  I can not: 2;
  will I: 2;
  "won't" I: 2;
  can I: 1;
  
  # contextualized inf comps
  
  I want to:  2;
  I want him to: 2;
  I hope to: 2;
  do you want me to: 2;
  
  ###############################
  # Context Locations and Anchors #
  ###############################

   I walked there: 1;  # full pro-pp location
   I was here: 1;
   I put it in there: 1 ; # anchor only
   I picked up there: 0;    # here/there don't overgenerate (uses CASE = acc-loc)
   
  
   
  ################
  # WH-QUESTIONS # 
  ################

  ## Questioning a complement (i.e. extracted argument) ##

  # In some of these cases, context entities are used.
  # For example, how much do you want. This is questioning the amount of a contextually defined
  # entity playing the patient role in want.
  
  what should I pick up: 1;
  
  which ball should I pick up: 1;
  what color ball should I pick up: 1;  
  which color should I pick up: 1;
  
  how is it: 2;
  how do you want it: 2;
  
  what color is it: 8;            # gotta look at this. Getting too many readings (both restr & scope (i.e. subj & obj) readings.)
  what size should I make it: 1; 

  how big is it: 2;
  how big should I make it: 1; 
  how much bigger should I make it: 1; 
  how hungry do you want me to be: 1; 
  
  how_much coffee should I make for him: 1;
  how_much should I make for him: 1;	   
  how_many balls do you want me to pick up: 2;  # 2 readings you
  
  how_many coffee do you want: 0;
  how_much balls do you want: 0;

  ## Questioning a Modifier (i.e. no extracted argument) ##  

  # These questions are handled semantically, i.e. the wh-word defines its own modifer type
  # and this is then used to restrict it's scoped event by checking that it has a compatible 
  # m-class
  
  where is he sleeping: 1;    # loc only
  where is he going: 2;       # static & dynamic
  where does he want it: 3;   # 1 the compliment reading, 2 scoping over Event comp since want can't take loc or dyn modifiers	  
  where does he want it to sleep: 1;
  
  how does he sleep: 1;       # manner reading 
  how did he make it: 2;      # manner reading + result-comp reading 
  
  ######################################
  # Tense, Aspect, Modality & Polarity #
  ######################################
 
  
  he sleeps: 1;
  he does sleep: 1;
  he "didn't" sleep: 1;  
  does he sleep: 1;

  he slept: 1;
  he did sleep: 1;
  he "didn't" sleep: 1;
  did he sleep: 1;

  he will sleep: 1;
  he "won't" sleep: 1;
  will he sleep: 1;

  he is sleeping: 1;
  he "isn't" sleeping: 1;
  is he sleeping: 1;

  he has slept: 1;
  he "hasn't" slept: 1;
  has he slept: 1;
 
  he can sleep: 1;
  he "can't" sleep: 1;
  can he sleep: 1;

  he is able to sleep: 1;
  he "isn't" able to sleep: 1;
  is he able to sleep: 1;  

  # Combinations

  he will have slept: 1;
  will he be sleeping: 1;
  
  he will be sleeping: 1;
  will he  be sleeping: 1;
  
  he has been sleeping: 1;
  has he been sleeping: 1;

  he "can't" have slept: 1;
  he "can't" be sleeping:  1;

  # Correctly Rejected #

  I will can sleep: 0;
  will he sleeps:  0;
  he will sleeps:  0;
  I am sleep:       0;
  I have sleep:   0;
   
      
  #########
  # Voice #
  #########
   
  # Currently no 'get form' (will require combining with aux 'do' for neg & questions)
  # Currently can't handle wh-questions
    
  he "wasn't" seen: 3;
  he "wasn't" seen by GJ: 6;    # 3 by Actor readings, 3 locational readings
  
  was he seen by anyone: 4; 
   
  ##################################
  # Fronted NPs, Pre-NPs, Post-NPs #
  ##################################
  
  
  # THIS WILL ALL BE REPLACE via discourse-units

  # Though certainly not the most important, or interesting feature of the new grammar
  # I figured I should put it first. When you start looking at parses, you'll no doubt 
  # be wondering 'What is all this crap?'

  # Right.
  # People like to place NPs outside clauses, both before and after. 

  # Reasons? task separation (i.e. separating finding/building description of the referent from predicating it), 
  #          info struc, mark logical relations (comparison, listing, etc) 
  #          various interpersonal functions, discourse segmentation, 'repairing' reference etc.
  #
  # Of course all of these tasks are 'extra sentential' and mostly interactive (e.g. only add a 2nd description if
  # they don't seem to get it after the first) but until we handle em in dialogue model, can have it here.
  # clearly will involve some 'post processing' as they do not sub-categorize for these functions, nor does it 
  # make any co-indexing proposals, i.e., treated as separate, i.e. as 'discourse anaphor'(ugh)
    
  # In any case, if you want to shut them off, go to discourse.ccg and comment out the lines.
  
  # there is often some sort of intonational break between clause and np, but not always, and
  # its not like speech rec is going to give us that info anyway...
  
#  the ball I picked it up: 1;
#  the ball I picked up: 2;
#  put it on the table the big ball: 1;
#  the big ball pick it up: 1;
#  who is he that guy there: 1;
    
  # Also, of course, as Vocatives
#  Robot I want you to go away: 2;
#  I want you to go away Robot: 2;
	
	  
        
}

rule { typechange: np[D x2du]  =>  du[D]  :  ; } 

rule { typechange: n[D x2du]  =>  du[D] :  ; } 

rule { typechange: adj[D x2du]  =>  du[D]  :  ; } 

rule { typechange: adv[D x2du]  =>  du[D]  :  ; } 

rule { typechange: s[D x2du]  =>  du[D]  :  ; } 

rule { typechange: pp[D x2du]  =>  du[D]  :  ; } 


rule { typechange: du[A disclevelcomp] => du[B]/^du[C] : B:d-units (list <First>(A) ^ <Next>(C) ) ; }


rule { typechange: np[B correction] => np[A]/^np[A]: A ( <Deleted>(B) ) ; }

#rule { typechange: adj[B correction] => adj<99>[A]/^adj<99>[A]: A ( <Deleted>(B) ) ; }

rule { typechange: n[B correction] => n<99>[A]/^n<99>[A]: A ( <Deleted>(B) ) ; }

#rule { typechange: np[B correction]/^n => np<100>/^n<100>[A] /^ (np<100>/^n<100>[A]) : A ( <Deleted>(B) ) ; }

#rule { typechange: pp[B correction]/^np => pp<100>/^np[A] /^ (pp<100>/^np[A]) : A ( <Deleted>(B) ) ; }
