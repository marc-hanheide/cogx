/**
 * @file Math.ic
 * @author Richtsfeld Andreas, Michael Zillich
 * @date 2004, 2010
 * @version 0.1
 * @brief Math definitions and inline functions.
 * 
 * TODO Doxygen description
 **/

#include <stdlib.h>
#include <math.h>
#include <cstdio>

namespace Z
{

using namespace std;

static const double eps = 1e-12;
static const double pi = M_PI;
static const double two_pi = 2*M_PI;

/*
  unsigned int grayencode(unsigned int g)
  {
    return(g^g>>1);
  }
  unsigned int graydecode(unsigned int b)
  {
    b^=b>>1; b^=b>>2; b^=b>>4; b^=b>>8; return(b^(b>>16));
  }
*/
// gray code conversion table for 4 bit numbers
static const unsigned gray[16] = {
  0x0,  // 0000
  0x1,  // 0001
  0x3,  // 0011
  0x2,  // 0010
  0x6,  // 0110
  0x7,  // 0111
  0x5,  // 0101
  0x4,  // 0100
  0xc,  // 1100
  0xd,  // 1101
  0xf,  // 1111
  0xe,  // 1110
  0xa,  // 1010
  0xb,  // 1011
  0x9,  // 1001
  0x8   // 1000
};

/**
 * @brief Returns true if the value is near zero (+/- epsilon)
 * Our epsion is 1e-12
 */
inline bool IsZero(double d)
{
  return fabs(d) < eps;
}

/**
 * @brief Returns true if the values are equal (+/- epsilon)
 * Our epsion is 1e-12
 */
inline bool IsEqual(double a, double b)
{
  return fabs(a - b) < eps;
}

/**
 * @brief Return whether value is a 'reasonable' number
 */
inline bool IsReasonable(double d)
{
  return islessequal(-1e9, d) && islessequal(d, 1e9);
}

template <class Num>
inline Num Sqr(Num x)
{
  return x*x;
}

template <class Num>
inline Num Max(Num a, Num b)
{
  return (a >= b ? a : b);
}

template <class Num>
inline Num Min(Num a, Num b)
{
  return (a <= b ? a : b);
}

template <class Num>
inline int Sign(Num x)
{
  if(x < (Num)0)
    return -1;
  else if(x > (Num)0)
    return 1;
  else
    return 0;
}

template <class T>
inline void Swap(T &a, T &b)
{
  T t = a;
  a = b;
  b = t;
}

template <class Num>
inline bool Between(Num x, Num l, Num u)
{
  return l < x && x < u;
}

template <class Num>
inline bool BetweenEq(Num x, Num l, Num u)
{
  return l <= x && x <= u;
}

inline int RandInt()
{
  return rand();
}

/**
 * @brief Scale angle to [0..2pi[
 */
inline double ScaleAngle_0_2pi(double a)
{
  while(a >= two_pi) a -= two_pi;
  while(a < 0.) a += two_pi;
  return a;
}

/**
 * @brief Scale angle to [-pi..pi[
 */
inline double ScaleAngle_mpi_pi(double a)
{
  while(a >= pi) a -= two_pi;
  while(a < -pi) a += two_pi;
  return a;
}

/**
 * @brief Scale angle to [0..pi[
 */
inline double ScaleAngle_0_pi(double a)
{
  while(a >= pi) a -= pi;
  while(a < 0.) a += pi;
  return a;
}

/**
 * @brief Difference of two angles b - a. The resulting angle is scaled to [-pi..pi[
 */
inline double DiffAngle_mpi_pi(double b, double a)
{
  return ScaleAngle_mpi_pi(b - a);
}

/**
 * @brief Difference of two angles b - a. The resulting angle is scaled to [0..2pi[
 */
inline double DiffAngle_0_2pi(double b, double a)
{
  return ScaleAngle_0_2pi(b - a);
}

/**
 * @brief Angles between (undirected) lines. The result is scaled to [0..pi/2[
 * The difference is always positive and the smaller of the two possible
 * differences is returned, i.e. diff is [0..pi/2[
 * Note that we never return a difference of 0 but rather the angular
 * resolution.
 */
inline double AngleBetweenLines(double b, double a)
{
  // note: lines are undirected, i.e. their orientation is [0..pi[
  double c = ScaleAngle_0_pi(b) - ScaleAngle_0_pi(a);
  if(c < 0)
    c = -c;
  if(c >=  M_PI_2)
     c = M_PI - c;
  if(IsZero(c))
     // HACK: atan(1/image_width) with image width = 640
     c = 0.0015625;
  return c;
}

/**
 * @brief Scale an integer angle to [0..8[
 */
inline int ScaleIntAngle_0_8(int a)
{
  while(a >= 8) a -= 8;
  while(a < 0) a += 8;
  return a;
}

/**
 * @brief Return the given binary number in gray code.
 * Note: only converts 4 bit numbers, i.e. 0 - 15
 */
inline unsigned BinaryToGray(unsigned b) throw(std::runtime_error)
{
  if(b > 15)
    throw std::runtime_error("Math.ic::BinaryToGray: accept only numbers 0 - 15");
  return gray[b];
}

inline int CityblockDistance(int x1, int y1, int x2, int y2)
{
  return abs(x2 - x1) + abs(y2 - y1);
}

/**
 * @brief V = 4 pi r^3 / 3
 */
inline double SphereVolume(double r)
{
  static double f = 4.*M_PI/3.;
  return f*pow(r, 3.);
}

/**
 * @brief A = pi r^2
 */
inline double CircleArea(double r)
{
  return M_PI*r*r;
}

/**
 * @brief Return squared distance between two keypoint descriptors.
 */
inline float DistSqr(float *desc1, float *desc2, unsigned size)
{
    register unsigned i;
    float dif;
    float distsq = 0;

    for (i = 0; i < size; i++) {
      dif = *desc1++ - *desc2++;
      distsq += dif * dif;
    }
    return distsq;
}

/**
 * @brief Bivariate Gaussian (Normal) probability density function.
 * Note that: sigma_x = sigma_y = s, rho = 0
 */
inline double BivariateGaussianPDF(double mx, double my, double s,
 double x, double y)
{
  x -= mx;
  y -= my;
  s *= s;
  return exp(-(x*x/s + y*y/s)/2.)/(2.*M_PI*s);
}

/**
 * @brief Returns a pseudo random number in [0.0, 1.0]
 */
inline float FRand()
{
  return RandInt()/((float)RAND_MAX + 1.);
}

inline float ExpPdf(float lambda)
{
  float dum;
  do
    dum = FRand();
  while (dum == 0.);
  return -log(dum)/lambda;
}


inline int ExpSelect(int max)
{
  int i;
  /* we want 99% probability of getting with expdev() a number smaller max
   * this requires a lambda of the exponential distribution:
   * lambda = -log(0.01)/max;    (-log(0.01) = 4.6) */
  float lambda = 4.6/(float)max;
  do
    i = (int)(ExpPdf(lambda));
  while(i > max);
  return i;
}

}

