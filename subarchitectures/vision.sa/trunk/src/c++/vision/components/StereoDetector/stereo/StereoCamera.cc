/**
 * @file StereoCamera.cc
 * @author ???
 * @date ???
 * @version 0.1
 * @brief StereoCamera calculation class
 */

#include <assert.h>
#include <math.h>
#include <sstream>
#include <iostream>
#include <float.h>
#include "CDataFile.h"
#include "StereoCamera.hh"

namespace Z
{

static void ReadMat33(istream &s, double M[3][3])
{
  s >> M[0][0] >> M[0][1] >> M[0][2]
    >> M[1][0] >> M[1][1] >> M[1][2]
    >> M[2][0] >> M[2][1] >> M[2][2];
}

static void ReadMat34(istream &s, double M[3][4])
{
  s >> M[0][0] >> M[0][1] >> M[0][2] >> M[0][3]
    >> M[1][0] >> M[1][1] >> M[1][2] >> M[1][3]
    >> M[2][0] >> M[2][1] >> M[2][2] >> M[2][3];
}

StereoCamera::StereoCamera()
{
  maxDistortion=.5;
}

/**
 * @brief Read calibration from a file generated by SVS.
 * @param calibfile Calibration file
 */
void StereoCamera::ReadSVSCalib(const string &calibfile)
{
  CDataFile file(calibfile);
 
  cam[LEFT].width = file.GetInt("pwidth", "left camera");
  cam[LEFT].height = file.GetInt("pheight", "left camera");
  cam[LEFT].fx = file.GetFloat("f", "left camera");
  cam[LEFT].fy = file.GetFloat("fy", "left camera");
  cam[LEFT].cx = file.GetFloat("Cx", "left camera");
  cam[LEFT].cy = file.GetFloat("Cy", "left camera");
  cam[LEFT].k1 = file.GetFloat("kappa1", "left camera");
  cam[LEFT].k2 = file.GetFloat("kappa2", "left camera");
  cam[LEFT].k3 = file.GetFloat("kappa3", "left camera");
  cam[LEFT].t1 = file.GetFloat("tau1", "left camera");
  cam[LEFT].t2 = file.GetFloat("tau2", "left camera");

  string str1 = file.GetString("proj", "left camera");
  istringstream sstr1(str1);
  ReadMat34(sstr1, cam[LEFT].proj);

  string str2 = file.GetString("rect", "left camera");
  istringstream sstr2(str2);
  ReadMat33(sstr2, cam[LEFT].rect);

  cam[RIGHT].width = file.GetInt("pwidth", "right camera");
  cam[RIGHT].height = file.GetInt("pheight", "right camera");
  cam[RIGHT].fx = file.GetFloat("f", "right camera");
  cam[RIGHT].fy = file.GetFloat("fy", "right camera");
  cam[RIGHT].cx = file.GetFloat("Cx", "right camera");
  cam[RIGHT].cy = file.GetFloat("Cy", "right camera");
  cam[RIGHT].k1 = file.GetFloat("kappa1", "right camera");
  cam[RIGHT].k2 = file.GetFloat("kappa2", "right camera");
  cam[RIGHT].k3 = file.GetFloat("kappa3", "right camera");
  cam[RIGHT].t1 = file.GetFloat("tau1", "right camera");
  cam[RIGHT].t2 = file.GetFloat("tau2", "right camera");

  string str3 = file.GetString("proj", "right camera");
  istringstream sstr3(str3);
  ReadMat34(sstr3, cam[RIGHT].proj);

  string str4 = file.GetString("rect", "right camera");
  istringstream sstr4(str4);
  ReadMat33(sstr4, cam[RIGHT].rect);
}

/**
 * @brief Point (X,Y,Z) is given in coor sys of left camera.
 * @param X 3D-coordinate ?
 * @param Y 3D-coordinate ?
 * @param Z 3D-coordinate ?
 * @param u 2D-coordinate ?
 * @param v 2D-coordinate ?
 * @param side Left or right side of stereo rig.
 */
void StereoCamera::ProjectPoint(double X, double Y, double Z, double &u, double &v, int side)
{
  assert(Z != 0.);
  u = cam[side].proj[0][0]*X + cam[side].proj[0][2]*Z + cam[side].proj[0][3];
  v = cam[side].proj[1][1]*Y + cam[side].proj[1][2]*Z;
  // w = Z;
  u /= Z;
  v /= Z;
}

/**
 * @brief Given a point in the left image and its disparity, return the reconstructed 3D point.
 * @param u 2D-coordinate ?
 * @param v 2D-coordinate ?
 * @param d distance ?
 * @param X 3D-coordinate ?
 * @param Y 3D-coordinate ?
 * @param Z 3D-coordinate ?
 */
void StereoCamera::ReconstructPoint(double u, double v, double d, double &X, double &Y, double &Z)
{
  // NOTE: somewhere in the calib file and my code there is a confusion with mm
  // and m. For the time being, just multiplying the disparity by 1000 here
  // seems to correct for that. Further investigations are necessary!!!
  d*=1000.;  // HACK
  // NOTE: actually tx = -proj[0][3]/proj[0][0] because:
  // proj[0][3] = -fx*tx  (where fx = proj[0][0])
  // but there seems to be an error in the SVS calib file:
  //   [external]
  //   Tx = -202.797
  //   [right camera]
  //   proj = 640 ... -1.297899e+05  (this should be positive!)
  // This should be further investigated!!!
  double tx = cam[RIGHT].proj[0][3]/cam[RIGHT].proj[0][0];
  X = u - cam[LEFT].proj[0][2];
  Y = v - cam[LEFT].proj[1][2];
  Z = cam[LEFT].proj[0][0];
  double W = -d/tx + (cam[LEFT].proj[0][2] - cam[RIGHT].proj[0][2])/tx;
  X /= W;
  Y /= W;
  Z /= W;
}

/**
 * @brief Distort point from the image plane.
 * @param u Image point (x-coordinate) ? 
 * @param v Image point (y-coordinate) ? 
 * @param ud Image point distorted (x-coordinate) ? 
 * @param vd Image point distorted (y-coordinate) ? 
 * @param side Left or right side of the stereo rig.
 */
void StereoCamera::DistortPoint(double u, double v, double &ud, double &vd, int side)
{
  double x = (u - cam[side].cx)/cam[side].fx;
  double y = (v - cam[side].cy)/cam[side].fy;
  double x2 = x*x;
  double y2 = y*y;
  double two_xy = 2.*x*y;
  double r2 = x2 + y2;
  double r4 = r2*r2;
  double r6 = r4*r2;
  double t = (1. + cam[side].k1*r2 + cam[side].k2*r4 + cam[side].k3*r6);
  double xd = x*t + two_xy*cam[side].t1 + cam[side].t2*(r2 + 2.*x2);
  double yd = y*t + two_xy*cam[side].t2 + cam[side].t1*(r2 + 2.*y2);
  ud = xd*cam[side].fx + cam[side].cx;
  vd = yd*cam[side].fy + cam[side].cy;
}

/**
 * @brief Gradient based method for undistortion.
 * @param ud Image point distorted (x-coordinate) ? 
 * @param vd Image point distorted (y-coordinate) ? 
 * @param u Image point (x-coordinate) ? 
 * @param v Image point (y-coordinate) ? 
 * @param side Left or right side of the stereo rig.
 */
bool StereoCamera::UndistortPoint(double ud, double vd, double &u, double &v, int side)
{
  const unsigned MAX_ITER = 100;
  double error = DBL_MAX;
  double gradx = 0, grady = 0;
  double currentx, currenty;
  unsigned z;
  u = ud;
  v = vd; 

  for(z = 0; z < MAX_ITER && error > maxDistortion; z++)
  {
    u += gradx;
    v += grady;
    DistortPoint(u, v, currentx, currenty, side);
    gradx = ud - currentx;
    grady = vd - currenty;
    error = gradx*gradx + grady*grady;
  }
  if(u < 0)
    u = 0;
  if(u >= cam[side].width)
    u = cam[side].width - 1;
  if(v < 0)
    v = 0;
  if(v >= cam[side].height)
    v = cam[side].height - 1;
  if(z < MAX_ITER)
    return true;
  return false;
}


/**
 * @brief Undistort and rectify point.
 * @param ud Image point distorted (x-coordinate) ? 
 * @param vd Image point distorted (y-coordinate) ? 
 * @param ur Image point rectified (x-coordinate) ? 
 * @param vr Image point rectified (y-coordinate) ? 
 * @param side Left or right side of the stereo rig.
 */
void StereoCamera::RectifyPoint(double ud, double vd, double &ur, double &vr, int side)
{
  double u, v;
  UndistortPoint(ud, vd, u, v, side);
  //u = ud;  // HACK: no undistortion
  //v = vd;
  double x = (u - cam[side].cx)/cam[side].fx;
  double y = (v - cam[side].cy)/cam[side].fy;
  double xr = cam[side].rect[0][0]*x + cam[side].rect[0][1]*y + cam[side].rect[0][2];
  double yr = cam[side].rect[1][0]*x + cam[side].rect[1][1]*y + cam[side].rect[1][2];
  double wr = cam[side].rect[2][0]*x + cam[side].rect[2][1]*y + cam[side].rect[2][2];
  xr /= wr;
  yr /= wr;
  ur = xr*cam[side].proj[0][0] + cam[side].proj[0][2];
  vr = yr*cam[side].proj[1][1] + cam[side].proj[1][2];
}

}

