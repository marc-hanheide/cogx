%%
% Originally a part of: Maggot (developed within EU project CogX)
% Author: Matej Kristan, 2009 (matej.kristan@fri.uni-lj.si; http://vicos.fri.uni-lj.si/matejk/)
% Last revised: 2009
%%
function [ pdf2, stateComponents ] = compressPdf( pdf, varargin )

minNumberOfComponentsThreshold = 0 ;
debugForceCompress = [] ;
approximateCost = 0 ;
otherClasses = [] ;
memorylimitUseNumComps = 0 ;
useWeightedHellinger = 1 ;
memorylimit = [] ;
compressionDirection = 'topDown' ; %'bottomUp' ;
applyProjectionToSubspace = 0 ;
useLocalDistanceEvaluation = 0 ; 
useMargHellingerCompression = 1 ;
useSMOprunning = 0 ;
threshOnSplitMethods = inf ;       
granularity_cell_num = 50 ; 
typeNoiseDetermination = 'inflation' ; % 'granularity'      
typeCompression = 'hierarchical' ; % 'affinity, hierarchical'
costFunction = 'hellinger' ;
costThreshold = 0.01 ;
numberOfSamples = [] ;

% process arguments
args = varargin;
nargs = length(args);
for i = 1:2:nargs
    switch args{i}        
        case 'typeCompression', typeCompression = args{i+1} ; 
        case 'costFunction', costFunction = args{i+1} ;
        case 'costThreshold', costThreshold = args{i+1} ;   
        case 'numberOfSamples', numberOfSamples = args{i+1} ;  
        case 'granularity_cell_num', granularity_cell_num = args{i+1} ;  
        case 'typeNoiseDetermination', typeNoiseDetermination = args{i+1} ; 
        case 'threshOnSplitMethods', threshOnSplitMethods = args{i+1} ;
        case 'useSMOprunning', useSMOprunning = args{i+1} ;
        case 'useMargHellingerCompression', useMargHellingerCompression = args{i+1} ;
        case 'useLocalDistanceEvaluation', useLocalDistanceEvaluation = args{i+1} ; 
        case 'applyProjectionToSubspace', applyProjectionToSubspace = args{i+1} ; 
        case 'compressionDirection', compressionDirection = args{i+1} ; 
        case 'memorylimit', memorylimit = args{i+1} ; 
        case 'useWeightedHellinger', useWeightedHellinger = args{i+1} ; 
        case 'memorylimitUseNumComps', memorylimitUseNumComps = args{i+1} ; 
        case 'otherClasses', otherClasses = args{i+1} ;
        case 'approximateCost', approximateCost = args{i+1} ;
        case 'debugForceCompress', debugForceCompress = args{i+1} ;    
        case 'minNumberOfComponentsThreshold', minNumberOfComponentsThreshold = args{i+1} ;     
    end
end

% otherClasses = [] 

if ~isempty(otherClasses)
    costFunction = 'hellinger' ;
    compressionDirection = 'bottomUp' ;
end
 
if applyProjectionToSubspace == 1
   minEigenEnergy = 1e-5 ; 
   output = subspacePrewhitenTransform( 'pdf', pdf, 'minEigenEnergy',minEigenEnergy, ...
                                        'transDirection', 'forward',...
                                        'allLayers', 1 ) ;    
   pdf = output.pdf ;
   
   if ~isempty(otherClasses) 
     % regularize input pdf within the selected subspace  
     for i_other = 1 : length(otherClasses.pdfs)         
         t_ret = subspacePrewhitenTransform( 'pdf', otherClasses.pdfs{i_other}, 'minEigenEnergy', minEigenEnergy, ...
             'transDirection', 'forward', ...
             'allLayers', output.allLayers,...
             'regularize', 'subRegularize',...
             'svdRes', output.svdRes ) ;
         otherClasses.pdfs{i_other} = t_ret.pdf ;
     end
     % merge other classes if accessible 
     otherClass_pdf.pdf = mergeOtherClasses( otherClasses ) ; 
     otherClass_pdf.priors = otherClasses.priors ;
%      MaxV = 3 ;
%      otherClass_pdf.pdf.sigmaPoints = precalculateSigmaPoints( otherClass_pdf.pdf, MaxV ) ;
   end
end
 
switch(typeCompression)
    case 'meanshift'
        [ pdf2 ] = meanshiftCompression( pdf, 'costFunction', costFunction,...
                                        'costThreshold', costThreshold,...
                                        'numberOfSamples', numberOfSamples,...
                                        'threshOnSplitMethods', threshOnSplitMethods,...
                                        'useSMOprunning', useSMOprunning,...
                                        'useMargHellingerCompression', useMargHellingerCompression,...
                                        'useLocalDistanceEvaluation', useLocalDistanceEvaluation,...
                                        'memoryLimit',  memorylimit,...
                                        'useWeightedHellinger', useWeightedHellinger ) ;
        stateComponents0 = [] ;
    case 'hierarchical'
        if isequal(costFunction,'MDL')          
            stateComponents0 = [] ;
            pdf2 = hierarchicalCompression_BestFirst( pdf, ...
                                        'costFunction', costFunction,...
                                        'costThreshold', costThreshold,...
                                        'numberOfSamples', numberOfSamples,...
                                        'granularity_cell_num', granularity_cell_num,...
                                        'typeNoiseDetermination', typeNoiseDetermination,...
                                        'threshOnSplitMethods', threshOnSplitMethods,...
                                        'useSMOprunning', useSMOprunning,...
                                        'useMargHellingerCompression', useMargHellingerCompression,...
                                        'useLocalDistanceEvaluation', useLocalDistanceEvaluation,...
                                        'memoryLimit',  memorylimit,...
                                        'useWeightedHellinger', useWeightedHellinger,...
                                        'memorylimitUseNumComps', memorylimitUseNumComps,...
                                        'debugForceCompress', debugForceCompress, ...
                                        'minNumberOfComponentsThreshold', minNumberOfComponentsThreshold) ;
            
%             [ pdf2, stateComponents0 ] = hierarchicalCompression_MDL( pdf, ...
%                                         'costFunction', costFunction,...
%                                         'costThreshold', costThreshold,...
%                                         'numberOfSamples', numberOfSamples,...
%                                         'granularity_cell_num', granularity_cell_num,...
%                                         'typeNoiseDetermination', typeNoiseDetermination,...
%                                         'threshOnSplitMethods', threshOnSplitMethods,...
%                                         'useSMOprunning', useSMOprunning,...
%                                         'useMargHellingerCompression', useMargHellingerCompression,...
%                                         'useLocalDistanceEvaluation', useLocalDistanceEvaluation,...
%                                         'memoryLimit',  memorylimit,...
%                                         'useWeightedHellinger', useWeightedHellinger,...
%                                         'memorylimitUseNumComps', memorylimitUseNumComps ) ;  
        
        elseif isequal(costFunction,'hellinger') 
            switch compressionDirection
                case 'bottomUp'
                    [ pdf2, stateComponents0 ] = hierarchicalCompression( pdf, ...
                                        'costFunction', costFunction,...
                                        'costThreshold', costThreshold,...
                                        'numberOfSamples', numberOfSamples,...
                                        'granularity_cell_num', granularity_cell_num,...
                                        'typeNoiseDetermination', typeNoiseDetermination,...
                                        'threshOnSplitMethods', threshOnSplitMethods,...
                                        'useSMOprunning', useSMOprunning,...
                                        'useMargHellingerCompression', useMargHellingerCompression,...
                                        'useLocalDistanceEvaluation', useLocalDistanceEvaluation,...
                                        'otherClasses', otherClass_pdf, ...
                                        'approximateCost', approximateCost) ;   
                case 'topDown'
                    [ pdf2, stateComponents0 ] = hierarchicalCompression_New( pdf, ...
                                        'costFunction', costFunction,...
                                        'costThreshold', costThreshold,...
                                        'numberOfSamples', numberOfSamples,...
                                        'granularity_cell_num', granularity_cell_num,...
                                        'typeNoiseDetermination', typeNoiseDetermination,...
                                        'threshOnSplitMethods', threshOnSplitMethods,...
                                        'useSMOprunning', useSMOprunning,...
                                        'useMargHellingerCompression', useMargHellingerCompression,...
                                        'useLocalDistanceEvaluation', useLocalDistanceEvaluation,...
                                        'useWeightedHellinger', useWeightedHellinger) ;            
                otherwise
                    msg = sprintf('Unknown compression direction: %s', compressionDirection) ;
                    error(msg) ;
            end
        end
    otherwise
        error('Affinity not implemented here!') ;
end

if applyProjectionToSubspace == 1    
   output = subspacePrewhitenTransform( 'pdf', pdf2, 'minEigenEnergy', minEigenEnergy, ...
                                        'transDirection', 'backward',...
                                        'allLayers', output.allLayers,...
                                        'svdRes', output.svdRes ) ;    
    pdf2 = output.pdf ;     
end

if nargout == 2
    stateComponents = stateComponents0 ;
else
    stateComponents = [] ;
end

% ---------------------------------------------------------------------- %
function otherClass_pdf = mergeOtherClasses( otherClasses )

if isempty(otherClasses)
    otherClass_pdf = [] ;
    return ;
end
otherClass_pdf = otherClasses.pdfs{1} ;  

for i = 2 : length(otherClasses.pdfs)
    prrs = [sum(otherClasses.inner_priors(1:i-1)) , otherClasses.inner_priors(i) ] ;
    prrs = prrs / sum(prrs) ;
    otherClass_pdf =  mergeDistributions( otherClass_pdf, otherClasses.pdfs{i}, prrs ) ;
end

% ---------------------------------------------------------------------- %
function sigmaPoints = precalculateSigmaPoints( pdf, MaxV ) 

    % calculate sigma points for posModel only
    [X, sigPointsPerComponent, w, k ] = getAllSigmaPointsOnMixture( pdf, MaxV ) ;
    W = repmat(pdf.w,sigPointsPerComponent,1) ;
    W = reshape(W,1,length(pdf.w)*sigPointsPerComponent) ;
    w2 = repmat(w,1,length(pdf.w)) ;
    W = W.*w2 ;
    sigmaPoints.W_final = W ;
    sigmaPoints.X_final = X ;
 
