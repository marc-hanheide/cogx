#------------------------------------------------------------------
# OWL ABox reasoning
# 
# OWL reasoning for ABox individuals
#
# author: Hendrik Zender, zender@dfki.de
# date: 2008-04-17
#------------------------------------------------------------------

@prefix test: <http://test.hz.owl#>
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix owl: <http://www.w3.org/2002/07/owl#>.
@prefix xsd: <http://www.w3.org/2001/XMLSchema#>.



#------------------------------------------------------------------
# Tabling directives
#------------------------------------------------------------------

#-> tableAll().

#-> table(rdf:type).
#-> table(owl:sameAs).
#-> table(owl:differentFrom).

#------------------------------------------------------------------
# OWL rules
#------------------------------------------------------------------

[sameRoomRuleDirect:
  (?a test:adjacent ?b),
  noValue(?a rdf:type test:Doorway),
  noValue(?b rdf:type test:Doorway)
  ->
  (?a test:sameRoomAs ?b)]
  
[sameRoomRuleTransitive:
  (?a test:adjacent ?c),
  (?b test:sameRoomAs ?c),
  noValue(?a rdf:type test:Doorway),
  noValue(?b rdf:type test:Doorway),
  noValue(?c rdf:type test:Doorway)
  ->
  (?a test:sameRoomAs ?b)]
  
[sameRoomReflexive:
  (?a rdf:type test:Place),
  noValue(?a rdf:type test:Doorway)
  ->
  (?a test:adjacent ?a)]

[removeDoorwaySameRoomAs:
  (?x test:sameRoomAs ?y),
  (?x rdf:type test:Doorway),
  noValue(test:tweety test:isa test:Bird)
  ->
  (test:tweety test:isa test:Bird),
  doorcleaner(?x)]
  
[possiblySameRoomRuleBaseCase:
  (?a test:sameRoomAs ?b),
  ->
  (?a test:possiblySameRoomAs ?b)]

[possiblySameRoomRule:
  (?a test:possiblySameRoomAs ?c),
  (?b test:possiblySameRoomAs ?c),
  ->
  (?a test:possiblySameRoomAs ?b)]
 
[possiblySameRoomRuleTransitive:
  (?a rdf:type test:Unknown),
  (?b rdf:type test:Unknown),
  (?a test:possiblySameRoomAs ?c),
  ->
  (?b test:possiblySameRoomAs ?c)]
  
[bottomUpRoomFormation:
  (?x rdf:type test:Place),
  (?y rdf:type test:Place),
  (?x test:sameRoomAs ?y),
  (?r rdf:type test:PhysicalRoom),
  (?x test:constituentOf ?r)
  ->
  (?y test:constituentOf ?r),
#  roomcleaner(?x)
]

# temp 2009 09 23  
#[doorwaysBelongToAllRooms:
#  (?x rdf:type test:Doorway),
#  (?x test:adjacent ?y),
#  (?y test:constituentOf ?r),
#  (?r rdf:type test:PhysicalRoom)
#  ->
#  (?x test:constituentOf ?r)]

# this one works -- it creates new blank nodes
#[bottomUpRoomCreation:
#  (?x rdf:type test:Place),
#  noValue(?x rdf:type test:Doorway),
#  noValue(?x test:constituentOf ?a),
#  makeTemp(?newRoom)
#  ->  
#  (?x test:constituentOf ?newRoom),
#  (?newRoom rdf:type test:PhysicalRoom)]
##  (test:tweety test:isa test:Bird),
##  doorcleaner(?x)]

# this one works as well -- it creates new named nodes instead
[bottomUpRoomCreation:
  (?x rdf:type test:Place),
  noValue(?x rdf:type test:Doorway),
  noValue(?x test:constituentOf ?a),
  gensym(?newRoom,"http://test.hz.owl#room")
  ->  
  print(bottomUpRoomCreation rule fired; created new instance ?newRoom),
#  roomcleaner(?x),
  (?x test:constituentOf ?newRoom),
  (?newRoom rdf:type test:PhysicalRoom)]

#[roomCleanerRule:
#  (?node1 test:sameRoomAs ?node2),
#  (?node1 test:constituentOf ?area1),
#  (?node2 test:constituentOf ?area2),
#  (?area1 ?a ?b), (?area2 ?x ?y),
#  (?c ?d ?area1), (?z ?zz ?area2),
#  gensym(?newroom,"room"),
#  notEqual(?node1,?node2),
#  notEqual(?area1,?area2)
#  noValue(test:tweety test:isa test:Bird)
#  ->
#  print(roomCleanerRule rule fired; created new instance ?newroom),
#  (test:tweety test:isa test:Bird),
#  (?node1 test:constituentOf ?newroom),
#  (?node2 test:constituentOf ?newroom),
#  drop(1), drop(2), drop(3), drop(4), drop(5), drop(6)
#]

# used alone, this rule works fine
#[makeEquivalentRoomsCoextensive:
#  (?r1 rdf:type test:PhysicalRoom),
#  (?r2 rdf:type test:PhysicalRoom),
#  (?x test:constituentOf ?r1),
#  (?x test:constituentOf ?r2),
#  noValue(?x rdf:type test:Doorway),
#  notEqual(?r1,?r2),
#  noValue(?r1 owl:sameAs ?r2)
#  ->
#  (?r1 owl:sameAs ?r2)]


# seems to work only when loading a populated ontology
# in case of facts added later, the rule engine goes
# into an endless loop.
# (maybe this rule is never called when loading a populated ontology...)
#[dropRedundantRooms:
#  (?r1 rdf:type test:PhysicalRoom),
#  (?r2 rdf:type test:PhysicalRoom),
#  (?r1 owl:sameAs ?r2)
#  (?r2 ?a ?b),
#  (?x ?y ?r2)
#  ->
#  drop(3),drop(4)]

##now for functional regions -- still leads to overgeneration
#[createKitchenRegions:
#  (?p rdf:type test:Place),
#  (?o rdf:type test:KitchenObject),
#  (?o test:in ?p),
##  noValue(?r rdf:type test:KitchenRegion),
#  noValue(?p test:constituentOfRegion ?r),
#  makeTemp(?newRegion)
#  ->
#  (?p test:constituentOfRegion ?newRegion), 
#  (?newRegion rdf:type test:KitcheRegion)]
  
## this one leads to a heap space overflow :-(
#[joinAdjacentKitchenRegions:
#  (?r1 rdf:type test:KitchenRegion),
#  (?r2 rdf:type test:KitchenRegion),
#  notEqual(?r1,?r2),
#  (?p1 test:constituentOfRegion ?r1),
#  (?p2 test:constituentOfRegion ?r2),
#  notEqual(?p1,?p2),
#  (?p1 test:adjacent ?p2)
#  ->
#  (?r1 owl:sameAs ?r2)
#  drop(1), drop(4)]
##  (?p1 test:constituentOfRegion ?r2),
##  (?p2 test:constituentOfRegion ?r1)]

##[dropRedundantRegions:
##  (?r1 rdf:type test:KitchenRegion),
##  (?r2 rdf:type test:KitchenRegion),
##  (?r1 owl:sameAs ?r2)
##  (?r2 ?a ?b),
##  (?x ?y ?r2)
##  ->
##  drop(3),drop(4)]

## overgeneration stopped!
#[dropRedundantRegions:
#  (?r1 rdf:type test:KitchenRegion),
#  (?r2 rdf:type test:KitchenRegion),
#  notEqual(?r1,?r2),
#  (?p1 test:constituentOfRegion ?r1),
#  (?p1 test:constituentOfRegion ?r2)
#  ->
#  drop(1),drop(4)]
  
  
#[cleanTweety:
#  (test:tweety test:isa test:Bird)
#  ->
#  drop(0)]


#[worldSubsumptionRule:
# (?x rdf:type oe:Entity)
# ->
# (?x oe:topoIncluded oe:world)]

#[prepositionSelectionRule1:
# (?x rdf:type oe:Floor),
# (?x rdf:topoContains ?y),
# notEqual(?x,?y)
# ->
# (?y oe:on ?x)]

#[prepositionSelectionRule2:
# (?x rdf:type oe:Area),
# (?x rdf:topoContains ?y),
# notEqual(?x,?y)
# ->
# (?y oe:in ?x)]

#[topoNeighborRule:
# (?x oe:near ?y),
# (?y oe:in ?z)
# ->
# (?x oe:in ?z) ]
 
#[topoNeighborRule2:
# (?x oe:near ?y),
# (?y oe:on ?z)
# ->
# (?x oe:on ?z) ]


#[hasObjectRule:
# (?x oe:in ?y),
# (?y rdf:type oe:Area)
# ->
# (?y oe:hasObject ?x) ]
 
## with this rule we raise objects dominated by other objects to area level
#[hasObjectRule:
# (?x oe:topoIncluded ?y),
# (?y rdf:type oe:Object),
# (?y oe:in ?z),
# (?z rdf:type oe:Area)
# ->
# (?z oe:hasObject ?x)]

# with this rule we raise topological adjency of nodes to area level
#[hasObjectRule:
# (?node1 oe:topoIncluded ?area1),
# (?node2 oe:topoIncluded ?area2),
# notEqual(?area1, ?area2),
# (?node1 oe:accessibleFrom ?node2)
# ->
# (?area1 oe:topoAdjacent ?area2)]


#[testWriteDirectClass:
#  (?ind rdf:type ?dummy),
#  (?ind rdf:type owl:Thing),
#  noValue(?ind rdfs:subClassOf owl:Thing),
#  notBNode(?ind),
#  noValue(?ind, oe:DIRECT),
#  ->
#  print(first rule),
#  writedirectclasses(?x,?ind)]

#[testWriteDirectClass2:
#  (?ind rdf:type ?dummy),
#  (?ind rdf:type owl:Thing),
#  noValue(?ind rdfs:subClassOf owl:Thing),
#  notBNode(?ind),
#  (?ind oe:DIRECT ?olddirect),
#  notEqual(?olddirect, ?dummy),
#  noValue(?dummy owl:equivalentClasses ?olddirect),
##  noValue(?olddirect rdfs:subClassOf ?dummy)
#  ->
#  print(second rule),
#  writedirectclasses(?x,?ind)]


#[detectDirectTriples:
#  (?ind oe:DIRECT ?y),
#  (?ind oe:DIRECT ?z),
#  notEqual(?y,?z),
#  noValue(?y owl:equivalentClass ?z),
#  noValue(?y rdfs:subClassOf ?y),
#  notBNode(?ind),
##  print(remove ?z)
##  (?z rdfs:subClassOf ?y)
#  ->
#  print(rule2)
#  remove(0),
##  writedirectclasses(?x, ?ind)
#]


#[removeSpuriousDirectsRule:
#  (?ind oe:DIRECT ?x),
#  (?ind oe:DIRECT ?y),
#  notEqual(?x, ?y),
#  noValue(?x owl:equivalentClass ?y),
##  noValue(?y rdfs:subClassOf ?x),
#  (?y rdfs:subClassOf ?x)
#  ->
#  print(removal rule ?ind ?x ?y)
##  <-
##  (?x rdfs:subClassOf ?y)]
##  remove(2)
#]





#[testDirectClass:
#  (?ind rdf:type ?dummy),
#  (?ind rdf:type owl:Thing),
#  noValue(?ind rdfs:subClassOf owl:Thing),
#  notBNode(?ind),
#  getdirectclass(?x,?ind)
#  ->
#  (?ind oe:DIRECT ?x)]

#[testSubsumptionRule:
#  (?ind rdf:type owl:Thing),
#  noValue(?ind rdfs:subClassOf owl:Thing),
#  (?ind rdf:type ?x),
#  notBNode(?ind),
#  notBNode(?x),
#  (?x rdfs:subClassOf owl:Thing),
#  (?y rdfs:subClassOf ?x),
#  notEqual(?y, ?x),
#  notBNode(?y),
#  (?ind rdf:type ?y)
#  ->
#  (?ind oe:DIRECT ?x)]

#[testRule1:
#  (?x rdf:type ?y),
#  notBNode(?x),
#  noValue(?z, rdfs:subClassOf, ?y)
#  ->
#  (?x oe:DIRECT ?y)]

#[testSubsumptionRule:
#  (?ind rdf:type owl:Thing),
#  noValue(?ind, rdfs:subClassOf, owl:Thing),
#  (?ind rdf:type ?x),
#  notBNode(?ind),
#  notBNode(?x),
#  (?x rdfs:subClassOf owl:Thing),
#  (?y rdfs:subClassOf ?x),
#  notEqual(?y, ?x),
#  notBNode(?y),
#  noValue(?ind, rdf:type, ?y)
#  ->
#  (?ind oe:DIRECT ?x),
#  (?ind oe:NON ?y)]


#[testSubsumptionRule:
#  (?ind rdf:type owl:Thing),
#  noValue(?ind rdfs:subClassOf owl:Thing),
#  (?ind rdf:type ?x),
#  notBNode(?ind),
#  notBNode(?x),
#  (?x rdfs:subClassOf owl:Thing),
#  (?y rdfs:subClassOf ?x),
#  notEqual(?y, ?x),
#  noValue(?ind rdf:type ?y),
#  (?z rdfs:subClassOf ?x),
#  (?ind rdf:type ?z),
#  notEqual(?y, ?z),
#  unbound(?z)
#  ->
#  (?ind oe:DIRECT ?x),
#  (?ind oe:NON ?y)]


#[aggregateRegionsRule:
# (?node1 rdf:type oe:NavGraphNode),
# (?node2 rdf:type oe:NavGraphNode),
# (?node1 oe:accessibleFrom ?node2),
# (?node1 rdf:type ?areaType),
# (?node2 rdf:type ?areaType),
# (?areaType rdfs:subClassOf oe:Area),
# (?node1 oe:topoIncluded ?region1),
# (?node2 oe:topoIncluded ?region2),
# (?
