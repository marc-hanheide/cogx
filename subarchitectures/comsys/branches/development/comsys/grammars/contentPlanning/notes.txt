Starting the utterance planning debugger standalone:

korbay:[~/CogX/cogx-svn/dfki] % java comsys.processing.uttplan.UPDebugger

With arguments:

java comsys.processing.uttplan.UPDebugger -grammar subarchitectures/comsys/grammars/contentPlanning/grammar.xml -ccg subarchitectures/comsys/grammars/openccg/moloko.v6/grammar.xml -redux subarchitectures/comsys/grammars/contentPlanning/modelredux.rdx -ngrams subarchitectures/comsys/grammars/contentPlanning/ngram-corpus.txt 


Utterance Planner Debugger v.0.25

Loading the planning grammar from [subarchitectures/comsys/grammars/contentPlanning/grammar.xml]
Loading a CCG grammar from URL: file:/Users/korbay/Work/Projects/CogX/cogx-svn/code/comsys/branches/comsys.mk5/subarchitectures/comsys/grammars/openccg/moloko.v6/grammar.xml

<debug>




@dvp1:dvp(c-goal  ^ <SpeechAct>somesa  ^ <Content>somecontent)
--> traversal screwed up

@dvp2:dvp(c-goal  ^ <SpeechAct>assertion  ^ <Content>(b1:physical ^ ball ^ <InfoStatus>familiar))       


------------------
Communicative acts
------------------
greeting, thanking, acknowledging
  @h1:greeting(hello)
  @b1:closing(bye)

  @o1:marker(ok) 
  @n1:marker(yes)
  @n1:marker(No)

  thanking is a sentence

DAMSL BLF --> relation
agreement ...
understanding ...
answer
info-rel

I wonder if it would work to flatten agreement and understanding:

accept
accept part
(maybe)
reject part
reject
hold

ackn
repeat-rephrase
completion
correction
non-understanding

answer

Anyway, these are too many categories, who would make these distinctions for me?

Let's try this classification:
Accept (part): there is a plan to start/continue executing, even if further info/help needed
Reject (part): no plan
Hold: further info/help needed before a plan can be found/constructed (can this even happen? maybe with an ambiguity...)
Acknowledge: utterance understood but no commitment (yet) --how does this differ from hold?
Answer: special category, if antecedent was a "question"; can perhaps also just be accept+assertion? 

Linguistic level only:
Signal-understanding: utterance (partially) understood -- further classification
Signal-nonunderstanding


And here is what Michael is doing:
Acknowledgment of a goal:
  yes = accept
  no  = reject
  already-true = presupposition failure = trivial (accept)

Note: Signaling acceptance purely by OK/Yes seems insufficiently informative. But, repeating the request, e.g., "Yes/OK, I'll bring you a cup of coffee" sounds weird. What would be a natural "rich" but nontrivial response? Adding some info? E.g., "OK, I'm going to the kitchen to fetch you a cup of coffee". (BTW, note the second mention remains indefinite. It's all about Var determination, no Ex. Also note: a cup vs. a cup of coffee ... )


-----------------
Spatial Relations
-----------------
      --> desired output:            
          <Modifier>(n1:m-location ^ left/right/near ^ 
              <Anchor>(b2:thing ^ ball ^ 
                        <Delimitation>unique ^ 
                        <Num>sg ^ 
                        <Quantification>specific))
          "... left of / right of / near the ball"
          OR:
            <Modifier>(o1:m-location ^ on/to ^ 
                       <Anchor>(l1:e-location ^ left ^ 
                                <Delimitation>unique ^ 
                                <Num>sg ^ 
                                <Quantification>specific ^ 
                                <Owner>(b2:thing ^ ball ^ 
                                        <Delimitation>unique ^ 
                                        <Num>sg ^ 
                                        <Quantification>specific))))
           "... on/to the left of the ball"

"Relative" location: "the box on the left (of something)"
  @b1:thing(box ^ 
            <Delimitation>unique ^ 
            <Num>sg ^ 
            <Quantification>specific ^ 
            <Modifier>(o1:m-location ^ on ^ 
                       <Anchor>(l1:e-location ^ left ^ 
                                <Delimitation>unique ^ 
                                <Num>sg ^ 
                                <Quantification>specific ^ 
                                <Owner>(c1:entity ^ context))))
recursive: "the box on the table on the left"
  @b1:thing(box ^ 
            <Delimitation>unique ^ 
            <Num>sg ^ 
            <Quantification>specific ^ 
            <Modifier>(n1:m-location ^ near ^ 
                       <Anchor>(t1:thing ^ table ^ 
                                <Delimitation>unique ^ 
                                <Num>sg ^ 
                                <Quantification>specific ^ 
                                <Modifier>(o1:m-location ^ on ^ 
                                           <Anchor>(l1:e-location ^ left ^ 
                                                    <Delimitation>unique ^ 
                                                    <Num>sg ^ 
                                                    <Quantification>specific)))))

"Absolute" location: "the box on the left" (like: the box on the table)
  @b1:thing(box ^ 
            <Delimitation>unique ^ 
            <Num>sg ^ 
            <Quantification>specific ^ 
            <Modifier>(o1:m-location ^ on ^ 
                       <Anchor>(l1:e-location ^ left ^ 
                                <Delimitation>unique ^ 
                                <Num>sg ^ 
                                <Quantification>specific)))

--------------
Mood and tense
--------------
Should do mood only if it's a sentence. Same for tense.

Probably need multiple systems. Greetings aren't sentences with mood. Also ok/yes/no are just markers.


-----------
Speech acts
-----------

Searle's speech acts: representative, directive (incl. quest.), commissive, expressive (incl. thanks and greetings), declarative (=performatives)



----------
Ascription
----------

Ascription vs description: 
"the ball is red", "the ball has red color" = ascription
"a/the red ball" = description

Planner input for ascription could/should be something like
ascription(referent,property):

@e1:ascription(<Target>(b2:thing ^ box ^ ...)  ^ <Property>(b3:q-color ^ red)

the planner needs to come up with a uniquely identifying description for the target referent to which the property is to be ascribed

"the box is big"
  @b1:ascription(
                 <Restr>(b2:thing ^ box ^ 
                  <Scope>(b3:q-size ^ big) ^ 
                )

  @b1:ascription(be ^ 
                 <Mood>ind ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ box ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific ^ 
                 <Cop-Scope>(b3:q-size ^ big) ^ 
                 <Subject>b2:thing)

is this ball red
  @b1:ascription(be ^ 
                 <Mood>int ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ ball ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Proximity>proximal ^ 
                             <Quantification>specific) ^ 
                 <Cop-Scope>(r1:q-color ^ red) ^ 
                 <Subject>b2:thing)

the book is in the library
  @b1:ascription(be ^ 
                 <Mood>ind ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ book ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific) ^ 
                 <Cop-Scope>(i1:m-location ^ in ^ 
                             <Anchor>(l1:e-place ^ library ^ 
                                      <Delimitation>unique ^ 
                                      <Num>sg ^ 
                                      <Quantification>specific)) ^ 
                 <Subject>b2:thing)


tccg> a ball is a robot 's
1 parse found.

Parse: s/^n : 
  @b1:ascription(be ^ 
                 <Mood>ind ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ ball ^ 
                             <Delimitation>existential ^ 
                             <Num>sg ^ 
                             <Quantification>specific) ^ 
                 <Cop-Scope>(x1:entity ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific ^ 
                             <Owner>(r1:animate ^ robot ^ 
                                     <Delimitation>existential ^ 
                                     <Num>sg ^ 
                                     <Quantification>specific)) ^ 
                 <Subject>b2:thing)


--------------------
Ascription questions
--------------------
What color does the ball have?
  @h1:ascription(have ^ 
                 <Mood>int ^ 
                 <Tense>pres ^ 
                 <Actor>(b1:thing ^ ball ^ 
                         <Delimitation>unique ^ 
                         <Num>sg ^ 
                         <Quantification>specific) ^ 
                 <Patient>(c1:entity ^ color ^ 
                           <Delimitation>unique ^ 
                           <Num>sg ^ 
                           <Quantification>specific) ^ 
                 <Subject>b1:thing ^ 
                 <Wh-Restr>(w1:specifier ^ what ^ 
                            <Scope>c1:entity))

What color is the box
  @b1:ascription(be ^ 
                 <Mood>int ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ box ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific) ^ 
                 <Cop-Scope>(c1:quality ^ color) ^ 
                 <Subject>b2:thing ^ 
                 <Wh-Restr>(w1:specifier ^ what ^ 
                            <Scope>c1:quality))

Where is the Borland book
  @b1:ascription(be ^ 
                 <Mood>int ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(b2:thing ^ book ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific ^ 
                             <Compound>(b3:entity ^ Borland)) ^ 
                 <Cop-Scope>(w1:m-location ^ where) ^ 
                 <Subject>b2:thing ^ 
                 <Wh-Restr>w1:m-location)


-----------------------------
Delimitation & quantification
-----------------------------
the two balls
@b1:thing(ball ^ 
            <Delimitation>unique ^ 
            <Num>pl ^ 
            <Quantification>specific ^ 
            <Modifier>(t1:number-cardinal ^ two))
both balls
  @b1:thing(ball ^ 
            <Delimitation>unique ^ 
            <Num>pl ^ 
            <Quantification>specific ^ 
            <Modifier>(b2:quantity ^ both))


@a1:entity(and ^ <First>(b1:physical ^ ball) ^ <Next>(c1:physical ^ cube))

@a1:entity(and ^ <First>(b1:physical ^ ball) ^ <Next>(a2:entity ^ and ^ <First>(c1: physical ^ cube) ^ <Next>(b2: physical ^ box)))

----------
InfoStatus
----------
familiar
[   identifiable (= uniquely identifiable) ]  <!-- not yet covered -->
[   nonidentifiable ]  <!-- yet covered -->



-----------------------------
Types (Concepts) from Hendrik
-----------------------------
entity
person (that's always a name of a person)
quality

---------------------------------
Features & Relations from Hendrik 
---------------------------------
#Color
#Shape
#Size
#Name
-Owner
-TopIn
-TopOn
-TopAt
-Near
-Next


---------------------
Transitivity: Events
---------------------

 @s1:perception(see ^ 
                 <Mood>ind ^ 
                 <Tense>pres ^ 
                 <Actor>(i1:person ^ I ^ 
                         <Num>sg) ^ 
                 <Patient>(b1:thing ^ ball ^ 
                           <Delimitation>existential ^ 
                           <Num>sg ^ 
                           <Quantification>specific) ^ 
                 <Subject>i1:person)


----------------
LIST STRUCTURES
----------------

a ball and a box
np : 
  @a1:entity(and ^ 
             <Num>pl ^ 
             <First>(b1:thing ^ ball ^ 
                     <Delimitation>existential ^ 
                     <Num>sg ^ 
                     <Quantification>specific) ^ 
             <Next>(b2:thing ^ box ^ 
                    <Delimitation>existential ^ 
                    <Num>sg ^ 
                    <Quantification>specific))

a ball and a box and a square
np : 
  @a1:entity(and ^ 
             <Num>pl ^ 
             <First>(b1:thing ^ ball ^ 
                     <Delimitation>existential ^ 
                     <Num>sg ^ 
                     <Quantification>specific) ^ 
             <Next>(a2:entity ^ and ^ 
                    <Num>pl ^ 
                    <First>(b2:thing ^ box ^ 
                            <Delimitation>existential ^ 
                            <Num>sg ^ 
                            <Quantification>specific) ^ 
                    <Next>(s1:thing ^ square ^ 
                           <Delimitation>existential ^ 
                           <Num>sg ^ 
                           <Quantification>specific)))





------------------
ALREADY THE CASE
------------------

 @b1:ascription(be ^ 
                 <Mood>ind ^ 
                 <Tense>pres ^ 
                 <Cop-Restr>(i1:thing ^ it ^ 
                             <Num>sg) ^ 
                 <Cop-Scope>(c1:entity ^ case ^ 
                             <Delimitation>unique ^ 
                             <Num>sg ^ 
                             <Quantification>specific) ^ 
                 <Modifier>(a1:m-time ^ already) ^ 
                 <Subject>(i1:thing)



				   

<!-- /**

@system structure.list

*/ --> 

   <system id="structure.list" region="STRUCTURE" metafunction="ideational">
      <chooser id="default"/>
      <conditions>
          <condition features="@type:entity"/>
      </conditions>
      <actions>
	  <action choice="default">
	    <identify-nomvar mode="First" src="FIRST" scope="global"/> <!-- need to test for it first, of course -->
	    <identify-nomvar mode="First" src="NEXT" scope="global"/>
	  </action>
      </actions>
   </system>



----------------
PRONOUNS
----------------

"it"
Parse 4: np : 
  @it1_0:thing(it ^ 
               <Num>sg)

"this"
Parse 7: np : 
  @context1_0:entity(context ^ 
                     <Delimitation>unique ^ 
                     <Num>sg ^ 
                     <Proximity>proximal ^ 
                     <Quantification>specific)

"that":
Parse 6: np : 
  @context1_0:entity(context ^ 
                     <Delimitation>unique ^ 
                     <Num>sg ^ 
                     <Proximity>distal ^ 
                     <Quantification>specific)

Salient:true + Familiar:true --> it
Salient:true + Familiar:false --> this/that (+proximal?)
Salient:false --> no pronominalization
				   
