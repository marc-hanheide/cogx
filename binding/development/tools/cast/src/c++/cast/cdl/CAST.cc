// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.

#include "CAST.hh"
#include <omniORB4/IOP_S.h>
#include <omniORB4/IOP_C.h>
#include <omniORB4/callDescriptor.h>
#include <omniORB4/callHandle.h>
#include <omniORB4/objTracker.h>


OMNI_USING_NAMESPACE(omni)

static const char* _0RL_library_version = omniORB_4_1;



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * CAST_RELEASE_STRING = "19.0 (aka \042every fix is a bug in disguise\042)";
} } 
#else
const char * cast::cdl::CAST_RELEASE_STRING = "19.0 (aka \042every fix is a bug in disguise\042)";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * GLOBAL_CONNECTION_PREFIX = "global";
} } 
#else
const char * cast::cdl::GLOBAL_CONNECTION_PREFIX = "global";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * XARCH_CONNECTION_PREFIX = "xarch";
} } 
#else
const char * cast::cdl::XARCH_CONNECTION_PREFIX = "xarch";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * ID_QUERY_PREFIX = "id";
} } 
#else
const char * cast::cdl::ID_QUERY_PREFIX = "id";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * EXISTS_QUERY_PREFIX = "ex";
} } 
#else
const char * cast::cdl::EXISTS_QUERY_PREFIX = "ex";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * OVERWRITE_COUNT_QUERY_PREFIX = "oc";
} } 
#else
const char * cast::cdl::OVERWRITE_COUNT_QUERY_PREFIX = "oc";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * ID_ARRAY_QUERY_PREFIX = "ia";
} } 
#else
const char * cast::cdl::ID_ARRAY_QUERY_PREFIX = "ia";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * TYPE_QUERY_PREFIX = "tp";
} } 
#else
const char * cast::cdl::TYPE_QUERY_PREFIX = "tp";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * SUBARCH_ID_KEY = "org.cognitivesystem.cast.subarchID";
} } 
#else
const char * cast::cdl::SUBARCH_ID_KEY = "org.cognitivesystem.cast.subarchID";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * COMPONENT_NUMBER_KEY = "org.cognitivesystem.cast.componentNumber";
} } 
#else
const char * cast::cdl::COMPONENT_NUMBER_KEY = "org.cognitivesystem.cast.componentNumber";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * CONFIG_FILE_KEY = "org.cognitivesystem.cast.config";
} } 
#else
const char * cast::cdl::CONFIG_FILE_KEY = "org.cognitivesystem.cast.config";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * WM_IDS_KEY = "org.cognitivesystem.cast.wmids";
} } 
#else
const char * cast::cdl::WM_IDS_KEY = "org.cognitivesystem.cast.wmids";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * COMPONENT_IDS_KEY = "org.cognitivesystem.cast.compids";
} } 
#else
const char * cast::cdl::COMPONENT_IDS_KEY = "org.cognitivesystem.cast.compids";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * LOG_KEY = "--log";
} } 
#else
const char * cast::cdl::LOG_KEY = "--log";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * DEBUG_KEY = "--debug";
} } 
#else
const char * cast::cdl::DEBUG_KEY = "--debug";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * DEBUG_EVENTS_KEY = "--debug-events";
} } 
#else
const char * cast::cdl::DEBUG_EVENTS_KEY = "--debug-events";
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage othewise.
namespace cast { namespace cdl { 
  extern const char * IGNORE_SA_KEY = "--ignore";
} } 
#else
const char * cast::cdl::IGNORE_SA_KEY = "--ignore";
#endif

void
cast::cdl::WorkingMemoryAddress::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_id,0);
  _n.marshalString(m_subarchitecture,0);

}

void
cast::cdl::WorkingMemoryAddress::operator<<= (cdrStream &_n)
{
  m_id = _n.unmarshalString(0);
  m_subarchitecture = _n.unmarshalString(0);

}

void
cast::cdl::WorkingMemoryPointer::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_type,0);
  (const WorkingMemoryAddress&) m_address >>= _n;

}

void
cast::cdl::WorkingMemoryPointer::operator<<= (cdrStream &_n)
{
  m_type = _n.unmarshalString(0);
  (WorkingMemoryAddress&)m_address <<= _n;

}

void
cast::cdl::WorkingMemoryEntry::operator>>= (cdrStream &_n) const
{
  m_operation >>= _n;
  (const WorkingMemoryAddress&) m_address >>= _n;
  _n.marshalString(m_type,0);
  m_version >>= _n;
  (const ::CORBA::Any&) m_data >>= _n;

}

void
cast::cdl::WorkingMemoryEntry::operator<<= (cdrStream &_n)
{
  (WorkingMemoryOperation&)m_operation <<= _n;
  (WorkingMemoryAddress&)m_address <<= _n;
  m_type = _n.unmarshalString(0);
  (::CORBA::Long&)m_version <<= _n;
  (::CORBA::Any&)m_data <<= _n;

}

void
cast::cdl::WorkingMemoryChange::operator>>= (cdrStream &_n) const
{
  m_operation >>= _n;
  _n.marshalString(m_src,0);
  (const WorkingMemoryAddress&) m_address >>= _n;
  _n.marshalString(m_type,0);

}

void
cast::cdl::WorkingMemoryChange::operator<<= (cdrStream &_n)
{
  (WorkingMemoryOperation&)m_operation <<= _n;
  m_src = _n.unmarshalString(0);
  (WorkingMemoryAddress&)m_address <<= _n;
  m_type = _n.unmarshalString(0);

}

void
cast::cdl::WorkingMemoryChangeFilter::operator>>= (cdrStream &_n) const
{
  m_operation >>= _n;
  _n.marshalString(m_src,0);
  (const WorkingMemoryAddress&) m_address >>= _n;
  _n.marshalString(m_type,0);
  m_restriction >>= _n;
  m_filterChange >>= _n;
  _n.marshalString(m_origin,0);

}

void
cast::cdl::WorkingMemoryChangeFilter::operator<<= (cdrStream &_n)
{
  (WorkingMemoryOperation&)m_operation <<= _n;
  m_src = _n.unmarshalString(0);
  (WorkingMemoryAddress&)m_address <<= _n;
  m_type = _n.unmarshalString(0);
  (FilterRestriction&)m_restriction <<= _n;
  (WorkingMemoryOperation&)m_filterChange <<= _n;
  m_origin = _n.unmarshalString(0);

}

void
cast::cdl::TaskDescription::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_taskName,0);
  (const TaskNameList&) m_predecessors >>= _n;
  (const TaskNameList&) m_superGoals >>= _n;
  (const TaskTagList&) m_tags >>= _n;

}

void
cast::cdl::TaskDescription::operator<<= (cdrStream &_n)
{
  m_taskName = _n.unmarshalString(0);
  (TaskNameList&)m_predecessors <<= _n;
  (TaskNameList&)m_superGoals <<= _n;
  (TaskTagList&)m_tags <<= _n;

}

void
cast::cdl::InformationProcessingTask::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_id,0);
  _n.marshalString(m_taskName,0);

}

void
cast::cdl::InformationProcessingTask::operator<<= (cdrStream &_n)
{
  m_id = _n.unmarshalString(0);
  m_taskName = _n.unmarshalString(0);

}

void
cast::cdl::TaskGoal::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_id,0);
  _n.marshalString(m_goalName,0);
  (const WorkingMemoryAddressList&) m_taskAddresses >>= _n;

}

void
cast::cdl::TaskGoal::operator<<= (cdrStream &_n)
{
  m_id = _n.unmarshalString(0);
  m_goalName = _n.unmarshalString(0);
  (WorkingMemoryAddressList&)m_taskAddresses <<= _n;

}

void
cast::cdl::TaskManagementResult::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_id,0);
  m_decision >>= _n;

}

void
cast::cdl::TaskManagementResult::operator<<= (cdrStream &_n)
{
  m_id = _n.unmarshalString(0);
  (TaskManagementDecision&)m_decision <<= _n;

}

void
cast::cdl::TaskResult::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_id,0);
  m_outcome >>= _n;

}

void
cast::cdl::TaskResult::operator<<= (cdrStream &_n)
{
  m_id = _n.unmarshalString(0);
  (TaskOutcome&)m_outcome <<= _n;

}

_init_in_def_( const ::CORBA::Long cast::cdl::testing::CAST_TEST_PASS = 29; )

_init_in_def_( const ::CORBA::Long cast::cdl::testing::CAST_TEST_FAIL = 30; )

void
cast::cdl::testing::CASTTestStruct::operator>>= (cdrStream &_n) const
{
  m_count >>= _n;
  (const WorkingMemoryChange&) m_change >>= _n;

}

void
cast::cdl::testing::CASTTestStruct::operator<<= (cdrStream &_n)
{
  (::CORBA::Long&)m_count <<= _n;
  (WorkingMemoryChange&)m_change <<= _n;

}

void
cast::cdl::testing::TestDummyStruct::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_dummy,0);

}

void
cast::cdl::testing::TestDummyStruct::operator<<= (cdrStream &_n)
{
  m_dummy = _n.unmarshalString(0);

}

void
cast::cdl::ui::TextOutput::operator>>= (cdrStream &_n) const
{
  m_type >>= _n;
  _n.marshalString(m_string,0);

}

void
cast::cdl::ui::TextOutput::operator<<= (cdrStream &_n)
{
  (OutputType&)m_type <<= _n;
  m_string = _n.unmarshalString(0);

}

void
cast::cdl::ui::ComponentEvent::operator>>= (cdrStream &_n) const
{
  m_event >>= _n;
  _n.marshalString(m_componentID,0);
  _n.marshalString(m_target,0);
  _n.marshalString(m_dataType,0);
  _n.marshalString(m_dataID,0);
  (const FrameworkBasics::BALTTime&) m_time >>= _n;

}

void
cast::cdl::ui::ComponentEvent::operator<<= (cdrStream &_n)
{
  (ComponentEventType&)m_event <<= _n;
  m_componentID = _n.unmarshalString(0);
  m_target = _n.unmarshalString(0);
  m_dataType = _n.unmarshalString(0);
  m_dataID = _n.unmarshalString(0);
  (FrameworkBasics::BALTTime&)m_time <<= _n;

}

void
cast::cdl::ui::ComponentStatus::operator>>= (cdrStream &_n) const
{
  _n.marshalString(m_component,0);
  _n.marshalString(m_subarchitecture,0);
  _n.marshalBoolean(m_log);
  _n.marshalBoolean(m_debug);
  _n.marshalBoolean(m_locked);
  _n.marshalBoolean(m_sleeping);
  m_changeQueue >>= _n;
  m_totalChangeEventsFiltered >>= _n;
  m_totalChangeEventsReceived >>= _n;
  m_totalAdds >>= _n;
  m_totalOverwrites >>= _n;
  m_totalDeletes >>= _n;
  m_totalReads >>= _n;
  m_totalProposals >>= _n;
  m_totalStarts >>= _n;
  m_totalEnds >>= _n;

}

void
cast::cdl::ui::ComponentStatus::operator<<= (cdrStream &_n)
{
  m_component = _n.unmarshalString(0);
  m_subarchitecture = _n.unmarshalString(0);
  m_log = _n.unmarshalBoolean();
  m_debug = _n.unmarshalBoolean();
  m_locked = _n.unmarshalBoolean();
  m_sleeping = _n.unmarshalBoolean();
  (::CORBA::Long&)m_changeQueue <<= _n;
  (::CORBA::Long&)m_totalChangeEventsFiltered <<= _n;
  (::CORBA::Long&)m_totalChangeEventsReceived <<= _n;
  (::CORBA::Long&)m_totalAdds <<= _n;
  (::CORBA::Long&)m_totalOverwrites <<= _n;
  (::CORBA::Long&)m_totalDeletes <<= _n;
  (::CORBA::Long&)m_totalReads <<= _n;
  (::CORBA::Long&)m_totalProposals <<= _n;
  (::CORBA::Long&)m_totalStarts <<= _n;
  (::CORBA::Long&)m_totalEnds <<= _n;

}

