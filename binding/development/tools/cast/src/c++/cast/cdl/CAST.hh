// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __CAST_hh__
#define __CAST_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_CAST
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_CAST
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_CAST
#endif



#ifndef __FrameworkBasics_hh_EXTERNAL_GUARD__
#define __FrameworkBasics_hh_EXTERNAL_GUARD__
#include <balt/idl/FrameworkBasics.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE cast

_CORBA_MODULE_BEG

  _CORBA_MODULE cdl

  _CORBA_MODULE_BEG

    _CORBA_MODULE_VAR _core_attr const char * CAST_RELEASE_STRING;

    _CORBA_MODULE_VAR _core_attr const char * GLOBAL_CONNECTION_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * XARCH_CONNECTION_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * ID_QUERY_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * EXISTS_QUERY_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * OVERWRITE_COUNT_QUERY_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * ID_ARRAY_QUERY_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * TYPE_QUERY_PREFIX;

    _CORBA_MODULE_VAR _core_attr const char * SUBARCH_ID_KEY;

    _CORBA_MODULE_VAR _core_attr const char * COMPONENT_NUMBER_KEY;

    _CORBA_MODULE_VAR _core_attr const char * CONFIG_FILE_KEY;

    _CORBA_MODULE_VAR _core_attr const char * WM_IDS_KEY;

    _CORBA_MODULE_VAR _core_attr const char * COMPONENT_IDS_KEY;

    _CORBA_MODULE_VAR _core_attr const char * LOG_KEY;

    _CORBA_MODULE_VAR _core_attr const char * DEBUG_KEY;

    _CORBA_MODULE_VAR _core_attr const char * DEBUG_EVENTS_KEY;

    _CORBA_MODULE_VAR _core_attr const char * IGNORE_SA_KEY;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OntologyEntry;

    typedef char* OntologyEntry;
    typedef ::CORBA::String_var OntologyEntry_var;
    typedef ::CORBA::String_out OntologyEntry_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryID;

    typedef char* WorkingMemoryID;
    typedef ::CORBA::String_var WorkingMemoryID_var;
    typedef ::CORBA::String_out WorkingMemoryID_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubarchitectureID;

    typedef char* SubarchitectureID;
    typedef ::CORBA::String_var SubarchitectureID_var;
    typedef ::CORBA::String_out SubarchitectureID_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryIDList;

    class WorkingMemoryIDList_var;

    class WorkingMemoryIDList : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef WorkingMemoryIDList_var _var_type;
      inline WorkingMemoryIDList() {}
      inline WorkingMemoryIDList(const WorkingMemoryIDList& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline WorkingMemoryIDList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline WorkingMemoryIDList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline WorkingMemoryIDList& operator = (const WorkingMemoryIDList& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class WorkingMemoryIDList_out;

    class WorkingMemoryIDList_var {
    public:
      inline WorkingMemoryIDList_var() : _pd_seq(0) {}
      inline WorkingMemoryIDList_var(WorkingMemoryIDList* _s) : _pd_seq(_s) {}
      inline WorkingMemoryIDList_var(const WorkingMemoryIDList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new WorkingMemoryIDList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~WorkingMemoryIDList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline WorkingMemoryIDList_var& operator = (WorkingMemoryIDList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline WorkingMemoryIDList_var& operator = (const WorkingMemoryIDList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new WorkingMemoryIDList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline WorkingMemoryIDList* operator -> () { return _pd_seq; }
      inline const WorkingMemoryIDList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator WorkingMemoryIDList& () const { return *_pd_seq; }
#else
      inline operator const WorkingMemoryIDList& () const { return *_pd_seq; }
      inline operator WorkingMemoryIDList& () { return *_pd_seq; }
#endif
        
      inline const WorkingMemoryIDList& in() const { return *_pd_seq; }
      inline WorkingMemoryIDList&       inout()    { return *_pd_seq; }
      inline WorkingMemoryIDList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline WorkingMemoryIDList* _retn() { WorkingMemoryIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class WorkingMemoryIDList_out;
      
    private:
      WorkingMemoryIDList* _pd_seq;
    };

    class WorkingMemoryIDList_out {
    public:
      inline WorkingMemoryIDList_out(WorkingMemoryIDList*& _s) : _data(_s) { _data = 0; }
      inline WorkingMemoryIDList_out(WorkingMemoryIDList_var& _s)
        : _data(_s._pd_seq) { _s = (WorkingMemoryIDList*) 0; }
      inline WorkingMemoryIDList_out(const WorkingMemoryIDList_out& _s) : _data(_s._data) {}
      inline WorkingMemoryIDList_out& operator = (const WorkingMemoryIDList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline WorkingMemoryIDList_out& operator = (WorkingMemoryIDList* _s) {
        _data = _s;
        return *this;
      }
      inline operator WorkingMemoryIDList*&()  { return _data; }
      inline WorkingMemoryIDList*& ptr()       { return _data; }
      inline WorkingMemoryIDList* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      WorkingMemoryIDList*& _data;

    private:
      WorkingMemoryIDList_out();
      WorkingMemoryIDList_out& operator=(const WorkingMemoryIDList_var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_SubarchitectureIDList;

    class SubarchitectureIDList_var;

    class SubarchitectureIDList : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef SubarchitectureIDList_var _var_type;
      inline SubarchitectureIDList() {}
      inline SubarchitectureIDList(const SubarchitectureIDList& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline SubarchitectureIDList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline SubarchitectureIDList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline SubarchitectureIDList& operator = (const SubarchitectureIDList& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class SubarchitectureIDList_out;

    class SubarchitectureIDList_var {
    public:
      inline SubarchitectureIDList_var() : _pd_seq(0) {}
      inline SubarchitectureIDList_var(SubarchitectureIDList* _s) : _pd_seq(_s) {}
      inline SubarchitectureIDList_var(const SubarchitectureIDList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new SubarchitectureIDList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~SubarchitectureIDList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline SubarchitectureIDList_var& operator = (SubarchitectureIDList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline SubarchitectureIDList_var& operator = (const SubarchitectureIDList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new SubarchitectureIDList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline SubarchitectureIDList* operator -> () { return _pd_seq; }
      inline const SubarchitectureIDList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator SubarchitectureIDList& () const { return *_pd_seq; }
#else
      inline operator const SubarchitectureIDList& () const { return *_pd_seq; }
      inline operator SubarchitectureIDList& () { return *_pd_seq; }
#endif
        
      inline const SubarchitectureIDList& in() const { return *_pd_seq; }
      inline SubarchitectureIDList&       inout()    { return *_pd_seq; }
      inline SubarchitectureIDList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline SubarchitectureIDList* _retn() { SubarchitectureIDList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class SubarchitectureIDList_out;
      
    private:
      SubarchitectureIDList* _pd_seq;
    };

    class SubarchitectureIDList_out {
    public:
      inline SubarchitectureIDList_out(SubarchitectureIDList*& _s) : _data(_s) { _data = 0; }
      inline SubarchitectureIDList_out(SubarchitectureIDList_var& _s)
        : _data(_s._pd_seq) { _s = (SubarchitectureIDList*) 0; }
      inline SubarchitectureIDList_out(const SubarchitectureIDList_out& _s) : _data(_s._data) {}
      inline SubarchitectureIDList_out& operator = (const SubarchitectureIDList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline SubarchitectureIDList_out& operator = (SubarchitectureIDList* _s) {
        _data = _s;
        return *this;
      }
      inline operator SubarchitectureIDList*&()  { return _data; }
      inline SubarchitectureIDList*& ptr()       { return _data; }
      inline SubarchitectureIDList* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      SubarchitectureIDList*& _data;

    private:
      SubarchitectureIDList_out();
      SubarchitectureIDList_out& operator=(const SubarchitectureIDList_var&);
    };

    enum ReceiverDeleteCondition { DELETE_RECEIVER, DO_NOT_DELETE_RECEIVER /*, __max_ReceiverDeleteCondition=0xffffffff */ };
    typedef ReceiverDeleteCondition& ReceiverDeleteCondition_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ReceiverDeleteCondition;

    enum WorkingMemoryOperation { ADD, OVERWRITE, DELETE, GET, WILDCARD /*, __max_WorkingMemoryOperation=0xffffffff */ };
    typedef WorkingMemoryOperation& WorkingMemoryOperation_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryOperation;

    enum WorkingMemoryChangeQueueBehaviour { DISCARD, QUEUE /*, __max_WorkingMemoryChangeQueueBehaviour=0xffffffff */ };
    typedef WorkingMemoryChangeQueueBehaviour& WorkingMemoryChangeQueueBehaviour_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeQueueBehaviour;

    enum FilterRestriction { LOCAL_SA, ALL_SA /*, __max_FilterRestriction=0xffffffff */ };
    typedef FilterRestriction& FilterRestriction_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_FilterRestriction;

    enum OperationMode { BLOCKING, NON_BLOCKING /*, __max_OperationMode=0xffffffff */ };
    typedef OperationMode& OperationMode_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OperationMode;

    enum WorkingMemoryPermissions { LOCKED_O, LOCKED_OD, LOCKED_ODR, UNLOCKED, DOES_NOT_EXIST, ALREADY_LOCKED /*, __max_WorkingMemoryPermissions=0xffffffff */ };
    typedef WorkingMemoryPermissions& WorkingMemoryPermissions_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPermissions;

    enum WorkingMemoryLockRequest { REQUEST_LOCK_O, REQUEST_LOCK_OD, REQUEST_LOCK_ODR, REQUEST_TRY_LOCK_O, REQUEST_TRY_LOCK_OD, REQUEST_TRY_LOCK_ODR, REQUEST_UNLOCK, REQUEST_STATUS /*, __max_WorkingMemoryLockRequest=0xffffffff */ };
    typedef WorkingMemoryLockRequest& WorkingMemoryLockRequest_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryLockRequest;

    struct WorkingMemoryAddress {
      typedef _CORBA_ConstrType_Variable_Var<WorkingMemoryAddress> _var_type;

      
      ::CORBA::String_member m_id;

      ::CORBA::String_member m_subarchitecture;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef WorkingMemoryAddress::_var_type WorkingMemoryAddress_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< WorkingMemoryAddress,WorkingMemoryAddress_var > WorkingMemoryAddress_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryAddress;

    struct WorkingMemoryPointer {
      typedef _CORBA_ConstrType_Variable_Var<WorkingMemoryPointer> _var_type;

      
      ::CORBA::String_member m_type;

      WorkingMemoryAddress m_address;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef WorkingMemoryPointer::_var_type WorkingMemoryPointer_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< WorkingMemoryPointer,WorkingMemoryPointer_var > WorkingMemoryPointer_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPointer;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPointerList;

    class WorkingMemoryPointerList_var;

    class WorkingMemoryPointerList : public _CORBA_Unbounded_Sequence< WorkingMemoryPointer >  {
    public:
      typedef WorkingMemoryPointerList_var _var_type;
      inline WorkingMemoryPointerList() {}
      inline WorkingMemoryPointerList(const WorkingMemoryPointerList& _s)
        : _CORBA_Unbounded_Sequence< WorkingMemoryPointer > (_s) {}

      inline WorkingMemoryPointerList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< WorkingMemoryPointer > (_max) {}
      inline WorkingMemoryPointerList(_CORBA_ULong _max, _CORBA_ULong _len, WorkingMemoryPointer* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< WorkingMemoryPointer > (_max, _len, _val, _rel) {}

    

      inline WorkingMemoryPointerList& operator = (const WorkingMemoryPointerList& _s) {
        _CORBA_Unbounded_Sequence< WorkingMemoryPointer > ::operator=(_s);
        return *this;
      }
    };

    class WorkingMemoryPointerList_out;

    class WorkingMemoryPointerList_var {
    public:
      inline WorkingMemoryPointerList_var() : _pd_seq(0) {}
      inline WorkingMemoryPointerList_var(WorkingMemoryPointerList* _s) : _pd_seq(_s) {}
      inline WorkingMemoryPointerList_var(const WorkingMemoryPointerList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new WorkingMemoryPointerList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~WorkingMemoryPointerList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline WorkingMemoryPointerList_var& operator = (WorkingMemoryPointerList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline WorkingMemoryPointerList_var& operator = (const WorkingMemoryPointerList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new WorkingMemoryPointerList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline WorkingMemoryPointer& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline WorkingMemoryPointerList* operator -> () { return _pd_seq; }
      inline const WorkingMemoryPointerList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator WorkingMemoryPointerList& () const { return *_pd_seq; }
#else
      inline operator const WorkingMemoryPointerList& () const { return *_pd_seq; }
      inline operator WorkingMemoryPointerList& () { return *_pd_seq; }
#endif
        
      inline const WorkingMemoryPointerList& in() const { return *_pd_seq; }
      inline WorkingMemoryPointerList&       inout()    { return *_pd_seq; }
      inline WorkingMemoryPointerList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline WorkingMemoryPointerList* _retn() { WorkingMemoryPointerList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class WorkingMemoryPointerList_out;
      
    private:
      WorkingMemoryPointerList* _pd_seq;
    };

    class WorkingMemoryPointerList_out {
    public:
      inline WorkingMemoryPointerList_out(WorkingMemoryPointerList*& _s) : _data(_s) { _data = 0; }
      inline WorkingMemoryPointerList_out(WorkingMemoryPointerList_var& _s)
        : _data(_s._pd_seq) { _s = (WorkingMemoryPointerList*) 0; }
      inline WorkingMemoryPointerList_out(const WorkingMemoryPointerList_out& _s) : _data(_s._data) {}
      inline WorkingMemoryPointerList_out& operator = (const WorkingMemoryPointerList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline WorkingMemoryPointerList_out& operator = (WorkingMemoryPointerList* _s) {
        _data = _s;
        return *this;
      }
      inline operator WorkingMemoryPointerList*&()  { return _data; }
      inline WorkingMemoryPointerList*& ptr()       { return _data; }
      inline WorkingMemoryPointerList* operator->() { return _data; }

      inline WorkingMemoryPointer& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      WorkingMemoryPointerList*& _data;

    private:
      WorkingMemoryPointerList_out();
      WorkingMemoryPointerList_out& operator=(const WorkingMemoryPointerList_var&);
    };

    struct WorkingMemoryEntry {
      typedef _CORBA_ConstrType_Variable_Var<WorkingMemoryEntry> _var_type;

      
      WorkingMemoryOperation m_operation;

      WorkingMemoryAddress m_address;

      ::CORBA::String_member m_type;

      ::CORBA::Long m_version;

      ::CORBA::Any m_data;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef WorkingMemoryEntry::_var_type WorkingMemoryEntry_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< WorkingMemoryEntry,WorkingMemoryEntry_var > WorkingMemoryEntry_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryEntry;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryEntryList;

    class WorkingMemoryEntryList_var;

    class WorkingMemoryEntryList : public _CORBA_Unbounded_Sequence< WorkingMemoryEntry >  {
    public:
      typedef WorkingMemoryEntryList_var _var_type;
      inline WorkingMemoryEntryList() {}
      inline WorkingMemoryEntryList(const WorkingMemoryEntryList& _s)
        : _CORBA_Unbounded_Sequence< WorkingMemoryEntry > (_s) {}

      inline WorkingMemoryEntryList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< WorkingMemoryEntry > (_max) {}
      inline WorkingMemoryEntryList(_CORBA_ULong _max, _CORBA_ULong _len, WorkingMemoryEntry* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< WorkingMemoryEntry > (_max, _len, _val, _rel) {}

    

      inline WorkingMemoryEntryList& operator = (const WorkingMemoryEntryList& _s) {
        _CORBA_Unbounded_Sequence< WorkingMemoryEntry > ::operator=(_s);
        return *this;
      }
    };

    class WorkingMemoryEntryList_out;

    class WorkingMemoryEntryList_var {
    public:
      inline WorkingMemoryEntryList_var() : _pd_seq(0) {}
      inline WorkingMemoryEntryList_var(WorkingMemoryEntryList* _s) : _pd_seq(_s) {}
      inline WorkingMemoryEntryList_var(const WorkingMemoryEntryList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new WorkingMemoryEntryList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~WorkingMemoryEntryList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline WorkingMemoryEntryList_var& operator = (WorkingMemoryEntryList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline WorkingMemoryEntryList_var& operator = (const WorkingMemoryEntryList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new WorkingMemoryEntryList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline WorkingMemoryEntry& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline WorkingMemoryEntryList* operator -> () { return _pd_seq; }
      inline const WorkingMemoryEntryList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator WorkingMemoryEntryList& () const { return *_pd_seq; }
#else
      inline operator const WorkingMemoryEntryList& () const { return *_pd_seq; }
      inline operator WorkingMemoryEntryList& () { return *_pd_seq; }
#endif
        
      inline const WorkingMemoryEntryList& in() const { return *_pd_seq; }
      inline WorkingMemoryEntryList&       inout()    { return *_pd_seq; }
      inline WorkingMemoryEntryList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline WorkingMemoryEntryList* _retn() { WorkingMemoryEntryList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class WorkingMemoryEntryList_out;
      
    private:
      WorkingMemoryEntryList* _pd_seq;
    };

    class WorkingMemoryEntryList_out {
    public:
      inline WorkingMemoryEntryList_out(WorkingMemoryEntryList*& _s) : _data(_s) { _data = 0; }
      inline WorkingMemoryEntryList_out(WorkingMemoryEntryList_var& _s)
        : _data(_s._pd_seq) { _s = (WorkingMemoryEntryList*) 0; }
      inline WorkingMemoryEntryList_out(const WorkingMemoryEntryList_out& _s) : _data(_s._data) {}
      inline WorkingMemoryEntryList_out& operator = (const WorkingMemoryEntryList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline WorkingMemoryEntryList_out& operator = (WorkingMemoryEntryList* _s) {
        _data = _s;
        return *this;
      }
      inline operator WorkingMemoryEntryList*&()  { return _data; }
      inline WorkingMemoryEntryList*& ptr()       { return _data; }
      inline WorkingMemoryEntryList* operator->() { return _data; }

      inline WorkingMemoryEntry& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      WorkingMemoryEntryList*& _data;

    private:
      WorkingMemoryEntryList_out();
      WorkingMemoryEntryList_out& operator=(const WorkingMemoryEntryList_var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryAddressList;

    class WorkingMemoryAddressList_var;

    class WorkingMemoryAddressList : public _CORBA_Unbounded_Sequence< WorkingMemoryAddress >  {
    public:
      typedef WorkingMemoryAddressList_var _var_type;
      inline WorkingMemoryAddressList() {}
      inline WorkingMemoryAddressList(const WorkingMemoryAddressList& _s)
        : _CORBA_Unbounded_Sequence< WorkingMemoryAddress > (_s) {}

      inline WorkingMemoryAddressList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< WorkingMemoryAddress > (_max) {}
      inline WorkingMemoryAddressList(_CORBA_ULong _max, _CORBA_ULong _len, WorkingMemoryAddress* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< WorkingMemoryAddress > (_max, _len, _val, _rel) {}

    

      inline WorkingMemoryAddressList& operator = (const WorkingMemoryAddressList& _s) {
        _CORBA_Unbounded_Sequence< WorkingMemoryAddress > ::operator=(_s);
        return *this;
      }
    };

    class WorkingMemoryAddressList_out;

    class WorkingMemoryAddressList_var {
    public:
      inline WorkingMemoryAddressList_var() : _pd_seq(0) {}
      inline WorkingMemoryAddressList_var(WorkingMemoryAddressList* _s) : _pd_seq(_s) {}
      inline WorkingMemoryAddressList_var(const WorkingMemoryAddressList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new WorkingMemoryAddressList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~WorkingMemoryAddressList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline WorkingMemoryAddressList_var& operator = (WorkingMemoryAddressList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline WorkingMemoryAddressList_var& operator = (const WorkingMemoryAddressList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new WorkingMemoryAddressList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline WorkingMemoryAddress& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline WorkingMemoryAddressList* operator -> () { return _pd_seq; }
      inline const WorkingMemoryAddressList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator WorkingMemoryAddressList& () const { return *_pd_seq; }
#else
      inline operator const WorkingMemoryAddressList& () const { return *_pd_seq; }
      inline operator WorkingMemoryAddressList& () { return *_pd_seq; }
#endif
        
      inline const WorkingMemoryAddressList& in() const { return *_pd_seq; }
      inline WorkingMemoryAddressList&       inout()    { return *_pd_seq; }
      inline WorkingMemoryAddressList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline WorkingMemoryAddressList* _retn() { WorkingMemoryAddressList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class WorkingMemoryAddressList_out;
      
    private:
      WorkingMemoryAddressList* _pd_seq;
    };

    class WorkingMemoryAddressList_out {
    public:
      inline WorkingMemoryAddressList_out(WorkingMemoryAddressList*& _s) : _data(_s) { _data = 0; }
      inline WorkingMemoryAddressList_out(WorkingMemoryAddressList_var& _s)
        : _data(_s._pd_seq) { _s = (WorkingMemoryAddressList*) 0; }
      inline WorkingMemoryAddressList_out(const WorkingMemoryAddressList_out& _s) : _data(_s._data) {}
      inline WorkingMemoryAddressList_out& operator = (const WorkingMemoryAddressList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline WorkingMemoryAddressList_out& operator = (WorkingMemoryAddressList* _s) {
        _data = _s;
        return *this;
      }
      inline operator WorkingMemoryAddressList*&()  { return _data; }
      inline WorkingMemoryAddressList*& ptr()       { return _data; }
      inline WorkingMemoryAddressList* operator->() { return _data; }

      inline WorkingMemoryAddress& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      WorkingMemoryAddressList*& _data;

    private:
      WorkingMemoryAddressList_out();
      WorkingMemoryAddressList_out& operator=(const WorkingMemoryAddressList_var&);
    };

    struct WorkingMemoryChange {
      typedef _CORBA_ConstrType_Variable_Var<WorkingMemoryChange> _var_type;

      
      WorkingMemoryOperation m_operation;

      ::CORBA::String_member m_src;

      WorkingMemoryAddress m_address;

      ::CORBA::String_member m_type;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef WorkingMemoryChange::_var_type WorkingMemoryChange_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< WorkingMemoryChange,WorkingMemoryChange_var > WorkingMemoryChange_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChange;

    struct WorkingMemoryChangeFilter {
      typedef _CORBA_ConstrType_Variable_Var<WorkingMemoryChangeFilter> _var_type;

      
      WorkingMemoryOperation m_operation;

      ::CORBA::String_member m_src;

      WorkingMemoryAddress m_address;

      ::CORBA::String_member m_type;

      FilterRestriction m_restriction;

      WorkingMemoryOperation m_filterChange;

      ::CORBA::String_member m_origin;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef WorkingMemoryChangeFilter::_var_type WorkingMemoryChangeFilter_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< WorkingMemoryChangeFilter,WorkingMemoryChangeFilter_var > WorkingMemoryChangeFilter_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeFilter;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeList;

    class WorkingMemoryChangeList_var;

    class WorkingMemoryChangeList : public _CORBA_Unbounded_Sequence< WorkingMemoryChange >  {
    public:
      typedef WorkingMemoryChangeList_var _var_type;
      inline WorkingMemoryChangeList() {}
      inline WorkingMemoryChangeList(const WorkingMemoryChangeList& _s)
        : _CORBA_Unbounded_Sequence< WorkingMemoryChange > (_s) {}

      inline WorkingMemoryChangeList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< WorkingMemoryChange > (_max) {}
      inline WorkingMemoryChangeList(_CORBA_ULong _max, _CORBA_ULong _len, WorkingMemoryChange* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< WorkingMemoryChange > (_max, _len, _val, _rel) {}

    

      inline WorkingMemoryChangeList& operator = (const WorkingMemoryChangeList& _s) {
        _CORBA_Unbounded_Sequence< WorkingMemoryChange > ::operator=(_s);
        return *this;
      }
    };

    class WorkingMemoryChangeList_out;

    class WorkingMemoryChangeList_var {
    public:
      inline WorkingMemoryChangeList_var() : _pd_seq(0) {}
      inline WorkingMemoryChangeList_var(WorkingMemoryChangeList* _s) : _pd_seq(_s) {}
      inline WorkingMemoryChangeList_var(const WorkingMemoryChangeList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new WorkingMemoryChangeList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~WorkingMemoryChangeList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline WorkingMemoryChangeList_var& operator = (WorkingMemoryChangeList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline WorkingMemoryChangeList_var& operator = (const WorkingMemoryChangeList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new WorkingMemoryChangeList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline WorkingMemoryChange& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline WorkingMemoryChangeList* operator -> () { return _pd_seq; }
      inline const WorkingMemoryChangeList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator WorkingMemoryChangeList& () const { return *_pd_seq; }
#else
      inline operator const WorkingMemoryChangeList& () const { return *_pd_seq; }
      inline operator WorkingMemoryChangeList& () { return *_pd_seq; }
#endif
        
      inline const WorkingMemoryChangeList& in() const { return *_pd_seq; }
      inline WorkingMemoryChangeList&       inout()    { return *_pd_seq; }
      inline WorkingMemoryChangeList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline WorkingMemoryChangeList* _retn() { WorkingMemoryChangeList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class WorkingMemoryChangeList_out;
      
    private:
      WorkingMemoryChangeList* _pd_seq;
    };

    class WorkingMemoryChangeList_out {
    public:
      inline WorkingMemoryChangeList_out(WorkingMemoryChangeList*& _s) : _data(_s) { _data = 0; }
      inline WorkingMemoryChangeList_out(WorkingMemoryChangeList_var& _s)
        : _data(_s._pd_seq) { _s = (WorkingMemoryChangeList*) 0; }
      inline WorkingMemoryChangeList_out(const WorkingMemoryChangeList_out& _s) : _data(_s._data) {}
      inline WorkingMemoryChangeList_out& operator = (const WorkingMemoryChangeList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline WorkingMemoryChangeList_out& operator = (WorkingMemoryChangeList* _s) {
        _data = _s;
        return *this;
      }
      inline operator WorkingMemoryChangeList*&()  { return _data; }
      inline WorkingMemoryChangeList*& ptr()       { return _data; }
      inline WorkingMemoryChangeList* operator->() { return _data; }

      inline WorkingMemoryChange& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      WorkingMemoryChangeList*& _data;

    private:
      WorkingMemoryChangeList_out();
      WorkingMemoryChangeList_out& operator=(const WorkingMemoryChangeList_var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskName;

    typedef char* TaskName;
    typedef ::CORBA::String_var TaskName_var;
    typedef ::CORBA::String_out TaskName_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskNameList;

    class TaskNameList_var;

    class TaskNameList : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef TaskNameList_var _var_type;
      inline TaskNameList() {}
      inline TaskNameList(const TaskNameList& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline TaskNameList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline TaskNameList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline TaskNameList& operator = (const TaskNameList& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class TaskNameList_out;

    class TaskNameList_var {
    public:
      inline TaskNameList_var() : _pd_seq(0) {}
      inline TaskNameList_var(TaskNameList* _s) : _pd_seq(_s) {}
      inline TaskNameList_var(const TaskNameList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TaskNameList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TaskNameList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TaskNameList_var& operator = (TaskNameList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TaskNameList_var& operator = (const TaskNameList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TaskNameList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TaskNameList* operator -> () { return _pd_seq; }
      inline const TaskNameList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TaskNameList& () const { return *_pd_seq; }
#else
      inline operator const TaskNameList& () const { return *_pd_seq; }
      inline operator TaskNameList& () { return *_pd_seq; }
#endif
        
      inline const TaskNameList& in() const { return *_pd_seq; }
      inline TaskNameList&       inout()    { return *_pd_seq; }
      inline TaskNameList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TaskNameList* _retn() { TaskNameList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TaskNameList_out;
      
    private:
      TaskNameList* _pd_seq;
    };

    class TaskNameList_out {
    public:
      inline TaskNameList_out(TaskNameList*& _s) : _data(_s) { _data = 0; }
      inline TaskNameList_out(TaskNameList_var& _s)
        : _data(_s._pd_seq) { _s = (TaskNameList*) 0; }
      inline TaskNameList_out(const TaskNameList_out& _s) : _data(_s._data) {}
      inline TaskNameList_out& operator = (const TaskNameList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TaskNameList_out& operator = (TaskNameList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TaskNameList*&()  { return _data; }
      inline TaskNameList*& ptr()       { return _data; }
      inline TaskNameList* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TaskNameList*& _data;

    private:
      TaskNameList_out();
      TaskNameList_out& operator=(const TaskNameList_var&);
    };

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskID;

    typedef char* TaskID;
    typedef ::CORBA::String_var TaskID_var;
    typedef ::CORBA::String_out TaskID_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskTag;

    typedef char* TaskTag;
    typedef ::CORBA::String_var TaskTag_var;
    typedef ::CORBA::String_out TaskTag_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskTagList;

    class TaskTagList_var;

    class TaskTagList : public _CORBA_Unbounded_Sequence_String {
    public:
      typedef TaskTagList_var _var_type;
      inline TaskTagList() {}
      inline TaskTagList(const TaskTagList& _s)
        : _CORBA_Unbounded_Sequence_String(_s) {}

      inline TaskTagList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence_String(_max) {}
      inline TaskTagList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

    

      inline TaskTagList& operator = (const TaskTagList& _s) {
        _CORBA_Unbounded_Sequence_String::operator=(_s);
        return *this;
      }
    };

    class TaskTagList_out;

    class TaskTagList_var {
    public:
      inline TaskTagList_var() : _pd_seq(0) {}
      inline TaskTagList_var(TaskTagList* _s) : _pd_seq(_s) {}
      inline TaskTagList_var(const TaskTagList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TaskTagList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TaskTagList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TaskTagList_var& operator = (TaskTagList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TaskTagList_var& operator = (const TaskTagList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TaskTagList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TaskTagList* operator -> () { return _pd_seq; }
      inline const TaskTagList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TaskTagList& () const { return *_pd_seq; }
#else
      inline operator const TaskTagList& () const { return *_pd_seq; }
      inline operator TaskTagList& () { return *_pd_seq; }
#endif
        
      inline const TaskTagList& in() const { return *_pd_seq; }
      inline TaskTagList&       inout()    { return *_pd_seq; }
      inline TaskTagList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TaskTagList* _retn() { TaskTagList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TaskTagList_out;
      
    private:
      TaskTagList* _pd_seq;
    };

    class TaskTagList_out {
    public:
      inline TaskTagList_out(TaskTagList*& _s) : _data(_s) { _data = 0; }
      inline TaskTagList_out(TaskTagList_var& _s)
        : _data(_s._pd_seq) { _s = (TaskTagList*) 0; }
      inline TaskTagList_out(const TaskTagList_out& _s) : _data(_s._data) {}
      inline TaskTagList_out& operator = (const TaskTagList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TaskTagList_out& operator = (TaskTagList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TaskTagList*&()  { return _data; }
      inline TaskTagList*& ptr()       { return _data; }
      inline TaskTagList* operator->() { return _data; }

      inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TaskTagList*& _data;

    private:
      TaskTagList_out();
      TaskTagList_out& operator=(const TaskTagList_var&);
    };

    struct TaskDescription {
      typedef _CORBA_ConstrType_Variable_Var<TaskDescription> _var_type;

      
      ::CORBA::String_member m_taskName;

      TaskNameList m_predecessors;

      TaskNameList m_superGoals;

      TaskTagList m_tags;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TaskDescription::_var_type TaskDescription_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TaskDescription,TaskDescription_var > TaskDescription_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskDescription;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskDescriptionList;

    class TaskDescriptionList_var;

    class TaskDescriptionList : public _CORBA_Unbounded_Sequence< TaskDescription >  {
    public:
      typedef TaskDescriptionList_var _var_type;
      inline TaskDescriptionList() {}
      inline TaskDescriptionList(const TaskDescriptionList& _s)
        : _CORBA_Unbounded_Sequence< TaskDescription > (_s) {}

      inline TaskDescriptionList(_CORBA_ULong _max)
        : _CORBA_Unbounded_Sequence< TaskDescription > (_max) {}
      inline TaskDescriptionList(_CORBA_ULong _max, _CORBA_ULong _len, TaskDescription* _val, _CORBA_Boolean _rel=0)
        : _CORBA_Unbounded_Sequence< TaskDescription > (_max, _len, _val, _rel) {}

    

      inline TaskDescriptionList& operator = (const TaskDescriptionList& _s) {
        _CORBA_Unbounded_Sequence< TaskDescription > ::operator=(_s);
        return *this;
      }
    };

    class TaskDescriptionList_out;

    class TaskDescriptionList_var {
    public:
      inline TaskDescriptionList_var() : _pd_seq(0) {}
      inline TaskDescriptionList_var(TaskDescriptionList* _s) : _pd_seq(_s) {}
      inline TaskDescriptionList_var(const TaskDescriptionList_var& _s) {
        if( _s._pd_seq )  _pd_seq = new TaskDescriptionList(*_s._pd_seq);
        else              _pd_seq = 0;
      }
      inline ~TaskDescriptionList_var() { if( _pd_seq )  delete _pd_seq; }
        
      inline TaskDescriptionList_var& operator = (TaskDescriptionList* _s) {
        if( _pd_seq )  delete _pd_seq;
        _pd_seq = _s;
        return *this;
      }
      inline TaskDescriptionList_var& operator = (const TaskDescriptionList_var& _s) {
        if( _s._pd_seq ) {
          if( !_pd_seq )  _pd_seq = new TaskDescriptionList;
          *_pd_seq = *_s._pd_seq;
        } else if( _pd_seq ) {
          delete _pd_seq;
          _pd_seq = 0;
        }
        return *this;
      }
      inline TaskDescription& operator [] (_CORBA_ULong _s) {
        return (*_pd_seq)[_s];
      }

    

      inline TaskDescriptionList* operator -> () { return _pd_seq; }
      inline const TaskDescriptionList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
      inline operator TaskDescriptionList& () const { return *_pd_seq; }
#else
      inline operator const TaskDescriptionList& () const { return *_pd_seq; }
      inline operator TaskDescriptionList& () { return *_pd_seq; }
#endif
        
      inline const TaskDescriptionList& in() const { return *_pd_seq; }
      inline TaskDescriptionList&       inout()    { return *_pd_seq; }
      inline TaskDescriptionList*&      out() {
        if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
        return _pd_seq;
      }
      inline TaskDescriptionList* _retn() { TaskDescriptionList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
        
      friend class TaskDescriptionList_out;
      
    private:
      TaskDescriptionList* _pd_seq;
    };

    class TaskDescriptionList_out {
    public:
      inline TaskDescriptionList_out(TaskDescriptionList*& _s) : _data(_s) { _data = 0; }
      inline TaskDescriptionList_out(TaskDescriptionList_var& _s)
        : _data(_s._pd_seq) { _s = (TaskDescriptionList*) 0; }
      inline TaskDescriptionList_out(const TaskDescriptionList_out& _s) : _data(_s._data) {}
      inline TaskDescriptionList_out& operator = (const TaskDescriptionList_out& _s) {
        _data = _s._data;
        return *this;
      }
      inline TaskDescriptionList_out& operator = (TaskDescriptionList* _s) {
        _data = _s;
        return *this;
      }
      inline operator TaskDescriptionList*&()  { return _data; }
      inline TaskDescriptionList*& ptr()       { return _data; }
      inline TaskDescriptionList* operator->() { return _data; }

      inline TaskDescription& operator [] (_CORBA_ULong _i) {
        return (*_data)[_i];
      }

    

      TaskDescriptionList*& _data;

    private:
      TaskDescriptionList_out();
      TaskDescriptionList_out& operator=(const TaskDescriptionList_var&);
    };

    struct InformationProcessingTask {
      typedef _CORBA_ConstrType_Variable_Var<InformationProcessingTask> _var_type;

      
      ::CORBA::String_member m_id;

      ::CORBA::String_member m_taskName;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef InformationProcessingTask::_var_type InformationProcessingTask_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< InformationProcessingTask,InformationProcessingTask_var > InformationProcessingTask_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_InformationProcessingTask;

    struct TaskGoal {
      typedef _CORBA_ConstrType_Variable_Var<TaskGoal> _var_type;

      
      ::CORBA::String_member m_id;

      ::CORBA::String_member m_goalName;

      WorkingMemoryAddressList m_taskAddresses;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TaskGoal::_var_type TaskGoal_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TaskGoal,TaskGoal_var > TaskGoal_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskGoal;

    enum TaskManagementDecision { GOAL_ADOPTED, GOAL_REJECTED, GOAL_WAITING /*, __max_TaskManagementDecision=0xffffffff */ };
    typedef TaskManagementDecision& TaskManagementDecision_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskManagementDecision;

    struct TaskManagementResult {
      typedef _CORBA_ConstrType_Variable_Var<TaskManagementResult> _var_type;

      
      ::CORBA::String_member m_id;

      TaskManagementDecision m_decision;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TaskManagementResult::_var_type TaskManagementResult_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TaskManagementResult,TaskManagementResult_var > TaskManagementResult_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskManagementResult;

    enum TaskOutcome { PROCESSING_INCOMPLETE, PROCESSING_COMPLETE, PROCESSING_COMPLETE_SUCCESS, PROCESSING_COMPLETE_FAILURE /*, __max_TaskOutcome=0xffffffff */ };
    typedef TaskOutcome& TaskOutcome_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskOutcome;

    struct TaskResult {
      typedef _CORBA_ConstrType_Variable_Var<TaskResult> _var_type;

      
      ::CORBA::String_member m_id;

      TaskOutcome m_outcome;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef TaskResult::_var_type TaskResult_var;

    typedef _CORBA_ConstrType_Variable_OUT_arg< TaskResult,TaskResult_var > TaskResult_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TaskResult;

    _CORBA_MODULE testing

    _CORBA_MODULE_BEG

      _CORBA_MODULE_VARINT const ::CORBA::Long CAST_TEST_PASS _init_in_decl_( = 29 );

      _CORBA_MODULE_VARINT const ::CORBA::Long CAST_TEST_FAIL _init_in_decl_( = 30 );

      struct CASTTestStruct {
        typedef _CORBA_ConstrType_Variable_Var<CASTTestStruct> _var_type;

        
        ::CORBA::Long m_count;

        WorkingMemoryChange m_change;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef CASTTestStruct::_var_type CASTTestStruct_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< CASTTestStruct,CASTTestStruct_var > CASTTestStruct_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_CASTTestStruct;

      struct TestDummyStruct {
        typedef _CORBA_ConstrType_Variable_Var<TestDummyStruct> _var_type;

        
        ::CORBA::String_member m_dummy;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef TestDummyStruct::_var_type TestDummyStruct_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< TestDummyStruct,TestDummyStruct_var > TestDummyStruct_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TestDummyStruct;

    _CORBA_MODULE_END

    _CORBA_MODULE ui

    _CORBA_MODULE_BEG

      enum OutputType { PRINT, DEBUG, LOG /*, __max_OutputType=0xffffffff */ };
      typedef OutputType& OutputType_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_OutputType;

      struct TextOutput {
        typedef _CORBA_ConstrType_Variable_Var<TextOutput> _var_type;

        
        OutputType m_type;

        ::CORBA::String_member m_string;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef TextOutput::_var_type TextOutput_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< TextOutput,TextOutput_var > TextOutput_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TextOutput;

      enum ComponentEventType { ADD, OVERWRITE, DELETE, GET, START, END, PROPOSED /*, __max_ComponentEventType=0xffffffff */ };
      typedef ComponentEventType& ComponentEventType_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentEventType;

      struct ComponentEvent {
        typedef _CORBA_ConstrType_Variable_Var<ComponentEvent> _var_type;

        
        ComponentEventType m_event;

        ::CORBA::String_member m_componentID;

        ::CORBA::String_member m_target;

        ::CORBA::String_member m_dataType;

        ::CORBA::String_member m_dataID;

        FrameworkBasics::BALTTime m_time;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef ComponentEvent::_var_type ComponentEvent_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentEvent,ComponentEvent_var > ComponentEvent_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentEvent;

      struct ComponentStatus {
        typedef _CORBA_ConstrType_Variable_Var<ComponentStatus> _var_type;

        
        ::CORBA::String_member m_component;

        ::CORBA::String_member m_subarchitecture;

        ::CORBA::Boolean m_log;

        ::CORBA::Boolean m_debug;

        ::CORBA::Boolean m_locked;

        ::CORBA::Boolean m_sleeping;

        ::CORBA::Long m_changeQueue;

        ::CORBA::Long m_totalChangeEventsFiltered;

        ::CORBA::Long m_totalChangeEventsReceived;

        ::CORBA::Long m_totalAdds;

        ::CORBA::Long m_totalOverwrites;

        ::CORBA::Long m_totalDeletes;

        ::CORBA::Long m_totalReads;

        ::CORBA::Long m_totalProposals;

        ::CORBA::Long m_totalStarts;

        ::CORBA::Long m_totalEnds;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef ComponentStatus::_var_type ComponentStatus_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< ComponentStatus,ComponentStatus_var > ComponentStatus_out;

      _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ComponentStatus;

    _CORBA_MODULE_END

    enum TriBool { triTrue, triFalse, triIndeterminate /*, __max_TriBool=0xffffffff */ };
    typedef TriBool& TriBool_out;

    _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_TriBool;

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_cast
_CORBA_MODULE_BEG

  _CORBA_MODULE cdl
  _CORBA_MODULE_BEG

    _CORBA_MODULE testing
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE ui
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_cast
_CORBA_MODULE_BEG

  _CORBA_MODULE cdl
  _CORBA_MODULE_BEG

    _CORBA_MODULE testing
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

    _CORBA_MODULE ui
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryIDList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryIDList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryIDList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryIDList*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::SubarchitectureIDList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::SubarchitectureIDList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::SubarchitectureIDList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::SubarchitectureIDList*& _sp);

inline void operator >>=(cast::cdl::ReceiverDeleteCondition _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::ReceiverDeleteCondition& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::DO_NOT_DELETE_RECEIVER) {
    _e = (cast::cdl::ReceiverDeleteCondition) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ReceiverDeleteCondition _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ReceiverDeleteCondition& _s);

inline void operator >>=(cast::cdl::WorkingMemoryOperation _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::WorkingMemoryOperation& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::WILDCARD) {
    _e = (cast::cdl::WorkingMemoryOperation) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryOperation _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryOperation& _s);

inline void operator >>=(cast::cdl::WorkingMemoryChangeQueueBehaviour _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::WorkingMemoryChangeQueueBehaviour& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::QUEUE) {
    _e = (cast::cdl::WorkingMemoryChangeQueueBehaviour) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeQueueBehaviour _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeQueueBehaviour& _s);

inline void operator >>=(cast::cdl::FilterRestriction _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::FilterRestriction& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::ALL_SA) {
    _e = (cast::cdl::FilterRestriction) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::FilterRestriction _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::FilterRestriction& _s);

inline void operator >>=(cast::cdl::OperationMode _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::OperationMode& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::NON_BLOCKING) {
    _e = (cast::cdl::OperationMode) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::OperationMode _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::OperationMode& _s);

inline void operator >>=(cast::cdl::WorkingMemoryPermissions _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::WorkingMemoryPermissions& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::ALREADY_LOCKED) {
    _e = (cast::cdl::WorkingMemoryPermissions) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPermissions _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPermissions& _s);

inline void operator >>=(cast::cdl::WorkingMemoryLockRequest _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::WorkingMemoryLockRequest& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::REQUEST_STATUS) {
    _e = (cast::cdl::WorkingMemoryLockRequest) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryLockRequest _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryLockRequest& _s);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddress& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryAddress* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryAddress*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddress*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointer& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPointer* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPointer*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointer*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointerList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPointerList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPointerList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointerList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntry& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryEntry* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryEntry*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntry*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntryList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryEntryList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryEntryList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntryList*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddressList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryAddressList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryAddressList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddressList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChange& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChange* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChange*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChange*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeFilter& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeFilter* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeFilter*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeFilter*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeList*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskNameList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskNameList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskNameList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskNameList*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskTagList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskTagList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskTagList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskTagList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskDescription& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::TaskDescription* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskDescription*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskDescription*& _sp);

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskDescriptionList& _s);
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskDescriptionList* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskDescriptionList*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskDescriptionList*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::InformationProcessingTask& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::InformationProcessingTask* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::InformationProcessingTask*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::InformationProcessingTask*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskGoal& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::TaskGoal* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskGoal*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskGoal*& _sp);

inline void operator >>=(cast::cdl::TaskManagementDecision _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::TaskManagementDecision& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::GOAL_WAITING) {
    _e = (cast::cdl::TaskManagementDecision) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TaskManagementDecision _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskManagementDecision& _s);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskManagementResult& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::TaskManagementResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskManagementResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskManagementResult*& _sp);

inline void operator >>=(cast::cdl::TaskOutcome _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::TaskOutcome& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::PROCESSING_COMPLETE_FAILURE) {
    _e = (cast::cdl::TaskOutcome) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TaskOutcome _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskOutcome& _s);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskResult& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::TaskResult* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskResult*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskResult*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::testing::CASTTestStruct& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::testing::CASTTestStruct* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::testing::CASTTestStruct*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::testing::CASTTestStruct*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::testing::TestDummyStruct& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::testing::TestDummyStruct* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::testing::TestDummyStruct*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::testing::TestDummyStruct*& _sp);

inline void operator >>=(cast::cdl::ui::OutputType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::ui::OutputType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::ui::LOG) {
    _e = (cast::cdl::ui::OutputType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ui::OutputType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::OutputType& _s);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::TextOutput& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::ui::TextOutput* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::TextOutput*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::TextOutput*& _sp);

inline void operator >>=(cast::cdl::ui::ComponentEventType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::ui::ComponentEventType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::ui::PROPOSED) {
    _e = (cast::cdl::ui::ComponentEventType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentEventType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentEventType& _s);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::ComponentEvent& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentEvent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentEvent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::ComponentEvent*& _sp);

extern void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::ComponentStatus& _s);
extern void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::ComponentStatus*& _sp);

inline void operator >>=(cast::cdl::TriBool _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (cast::cdl::TriBool& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= cast::cdl::triIndeterminate) {
    _e = (cast::cdl::TriBool) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TriBool _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TriBool& _s);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_CAST
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_CAST
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_CAST
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_CAST
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_CAST
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_CAST
#endif

#endif  // __CAST_hh__

