/*
 * CAST - The CoSy Architecture Schema Toolkit Copyright (C) 2006-2007
 * Nick Hawes This library is free software; you can redistribute it
 * and/or modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either version
 * 2.1 of the License, or (at your option) any later version. This
 * library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. You should have
 * received a copy of the GNU Lesser General Public License along with
 * this library; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package cast.architecture;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

import Ice.Current;
import cast.AlreadyExistsOnWMException;
import cast.ConsistencyException;
import cast.DoesNotExistOnWMException;
import cast.UnknownSubarchitectureException;
import cast.cdl.IGNORESAKEY;
import cast.cdl.WMIDSKEY;
import cast.cdl.WorkingMemoryAddress;
import cast.cdl.WorkingMemoryChange;
import cast.cdl.WorkingMemoryChangeFilter;
import cast.cdl.WorkingMemoryEntry;
import cast.cdl.WorkingMemoryEntrySeqHolder;
import cast.cdl.WorkingMemoryOperation;
import cast.cdl.WorkingMemoryPermissions;
import cast.core.CASTUtils;
import cast.core.CASTWMPermissionMap;
import cast.core.CASTWorkingMemory;
import cast.core.CASTWorkingMemoryInterface;
import cast.core.SubarchitectureComponent;
import cast.interfaces.WorkingMemoryPrx;
import cast.interfaces.WorkingMemoryPrxHelper;
import cast.interfaces.WorkingMemoryReaderComponentPrx;
import cast.interfaces.WorkingMemoryReaderComponentPrxHelper;
import cast.interfaces._WorkingMemoryOperations;

/**
 * Class to act as working memory for a sub-architecture. There are a lot issues
 * about the functionality that this implementation should support. Access to
 * working memory can be achieved by a number of mechanisms <br/>
 * 1. Type access. Each entry is given a type string by the originating class
 * with describes the information contained within the entry, e.g. speech string
 * or SIFT feature vector <br/>
 * 2. WM Index. Direct random access is available via numerical indices, much
 * like an array. Indices are generated by the working memory itself when new
 * entries are added.<br/>
 * 3. Unique ID. Each memory item is given a unique ID by the originating
 * process. This is used so that the originating class has an easy way of
 * referencing data it's created. We will start with string ids for
 * human-readability, but this may change to ints for size.
 * 
 * @author nah
 */
public class SubarchitectureWorkingMemory extends SubarchitectureComponent
		implements _WorkingMemoryOperations {

	private final WorkingMemoryChangeFilterMap<String> m_componentFilters;

	private final WorkingMemoryChangeFilterMap<String> m_wmFilters;

	protected final CASTWorkingMemoryInterface m_workingMemory;

	private final HashSet<String> m_ignoreList;

	/**
	 * Determine whether to send local notifications to other subarchitectures.
	 */
	private boolean m_sendXarchChangeNotifications;

	/**
	 * Flag used in testing, whether change filters are shared with other wms.
	 */
	private final boolean m_wmDistributedFiltering = true;

	/**
	 * Construct new object with a unique id. Name should be created with
	 * createName.
	 * 
	 * @param _id
	 * @see #createID(String)
	 */
	public SubarchitectureWorkingMemory() {
		m_workingMemory = new CASTWorkingMemory();
		m_componentFilters = new WorkingMemoryChangeFilterMap<String>();
		m_wmFilters = new WorkingMemoryChangeFilterMap<String>();
		m_ignoreList = new HashSet<String>();
		m_wmIDs = new HashSet<String>();
		m_permissions = new CASTWMPermissionMap();
		// m_xarchLockConnections = new ConcurrentHashMap<String,
		// PermissionsPullConnectorOut>();

		// determines whether this wm should broadcast to other
		// sub-architectures
		setSendXarchChangeNotifications(true);
		m_readers = new ArrayList<WorkingMemoryReaderComponentPrx>();
		m_workingMemories = new HashMap<String, WorkingMemoryPrx>();
		m_workingMemories_oneway = new HashMap<String, WorkingMemoryPrx>();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * cast.core.components.CASTComponentingComponent#configure(java.util.Properties
	 * )
	 */
	@Override
	public void configure(Map<String, String> _config) {

		String ignore = _config.get(IGNORESAKEY.value);
		if (ignore != null) {
			String[] ignoreList = ignore.split(",");
			for (String ignoreMe : ignoreList) {
				if (ignoreMe.length() > 0) {
					ignoreChangesFromSubarchitecture(ignoreMe);
				}
			}
		}

		// System.out.println(_config);
		// build lists of component and wm ids
		buildIDLists(_config);

	}

	private final HashSet<String> m_wmIDs;

	private void buildIDLists(Map<String, String> _props) {
		assert (_props != null);
		String wmIDs = _props.get(WMIDSKEY.value);
		assert (wmIDs != null);
		String[] ids = wmIDs.split(",");
		for (String id : ids) {
			if (id.length() > 0) {
				m_wmIDs.add(id);
			}
		}

	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void addComponentChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.addComponentChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}

		m_componentFilters.put(_data, _src);

		if (m_bDebugOutput) {
			debug("new filters length: " + m_componentFilters.size());
			debug("only local: " + m_componentFilters.localFiltersOnly());
		}
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void addWMChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.addWMChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}

		m_wmFilters.put(_data, _src);

		if (m_bDebugOutput) {
			debug("new filters length: " + m_wmFilters.size());
			debug("only local: " + m_wmFilters.localFiltersOnly());
		}
	}

	// protected void logMemoryChange(WorkingMemoryOperation _op) {
	// synchronized (m_componentStatus) {
	// switch (_op.value()) {
	// case WorkingMemoryOperation._ADD:
	// m_componentStatus.m_changeQueue++;
	// m_componentStatus.m_totalAdds++;
	// break;
	// case WorkingMemoryOperation._OVERWRITE:
	// m_componentStatus.m_totalOverwrites++;
	// break;
	// case WorkingMemoryOperation._DELETE:
	// m_componentStatus.m_changeQueue--;
	// m_componentStatus.m_totalDeletes++;
	// break;
	// default:
	// break;
	// }
	// }
	// }

	private final CASTWMPermissionMap m_permissions;

	private final ArrayList<WorkingMemoryReaderComponentPrx> m_readers;

	/**
	 * Add some data to working memory. If the given id already exists in the
	 * working memory then the data isn't added and false is returned.
	 * 
	 * @param _id
	 *            The id to use for the data.
	 * @param _data
	 *            The data itself.
	 * @return True if the data is added successfully, else false.
	 */
	protected boolean addToWorkingMemory(String _id, WorkingMemoryEntry _data) {
		boolean result = m_workingMemory.add(_id, _data);
		if (result) {
			m_permissions.add(_id);
		}
		return result;
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void deleteComponentChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.deleteComponentChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}
		m_componentFilters.remove(_data);
		if (m_bDebugOutput) {
			debug("new filters length: " + m_componentFilters.size());
			debug("only local: " + m_componentFilters.localFiltersOnly());
		}
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void deleteWMChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.deleteWMChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}
		m_wmFilters.remove(_data);
		if (m_bDebugOutput) {
			debug("new filters length: " + m_wmFilters.size());
			debug("only local: " + m_wmFilters.localFiltersOnly());
		}
	}

	/**
	 * Delete the specified entry from working memory. If the given id does not
	 * exist in the working memory then nothing happens and null is returned.
	 * 
	 * @param _id
	 *            The id of the entry to delete.
	 * @return The item that is deleted, or null if nothing is deleted.
	 */
	protected WorkingMemoryEntry deleteFromWorkingMemory(String _id,
			String _component) {

		boolean isLocked = false;

		if (m_permissions.isLocked(_id)) {

			WorkingMemoryPermissions permissions = m_permissions
					.getPermissions(_id);

			// if the item is delete locked
			if (!CASTUtils.deleteAllowed(permissions)) {
				// we're going to assume that client checking is up to scratch
				assert (m_permissions.isLockHolder(_id, _component));
			} else {
				// could just be an overwrite lock, in which case it doesn't
				// matter who is the lock holder
			}

			isLocked = true;
		}

		WorkingMemoryEntry result = m_workingMemory.remove(_id);

		if (isLocked) {
			debug("unlocking on deletion: " + _id);
			m_permissions.unlock(_id, _component);
		}

		try {
			unlockComponent();
			m_permissions.remove(_id);
			lockComponent();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

		return result;
	}

	private void readBlock(String _id, String _component) {

		WorkingMemoryPermissions perms = m_permissions.getPermissions(_id);

		while (m_permissions.isLocked(_id)
				&& !m_permissions.isLockHolder(_id, _component)
				&& !CASTUtils.readAllowed(perms)) {

			debug("blocking read by " + _component + " because " + _id
					+ " is locked by " + m_permissions.getLockHolder(_id));
			// block
			try {

				// unlock before we block to allow other things to
				// happen
				unlockComponent();
				m_permissions.lock(_id, _component,
						WorkingMemoryPermissions.LOCKEDODR);
				// relock to finish the operation
				lockComponent();

				// then unlock
				m_permissions.unlock(_id, _component);
			} catch (InterruptedException e) {
				println(e);
			}

			// now check if entry still exists as it could've been deleted
			// while we block... so we don't even hold a lock
			if (!m_workingMemory.contains(_id)) {
				debug("deletion during readBlock, returning");
				return;
			}

			perms = m_permissions.getPermissions(_id);

		}
	}

	/**
	 * Determines whether the wm is allowed to forward this change to the
	 * attached reader processes.
	 * 
	 * @param _change
	 * @return true if the change is not from an ignored sa and passes all the
	 *         filters
	 */
	protected boolean isAllowedChange(WorkingMemoryChange _change) {
		return (!m_ignoreList.contains(_change.address.subarchitecture))
				&& m_componentFilters.allowsChange(_change);
	}

	/**
	 * Determines whether to forward change notifications to other
	 * subarchitecture working memories (i.e. its peers).
	 * 
	 * @return Returns the sendXarchChangeNotifications.
	 */
	protected boolean isSendingXarchChangeNotifications() {
		return m_sendXarchChangeNotifications;
	}

	/**
	 * Overwrite some data to working memory. If the given id does not exist in
	 * the working memory then the data isn't written and false is returned.
	 * 
	 * @param _id
	 *            The id to use for the data.
	 * @param _data
	 *            The data itself.
	 * @return True if the data is overwritten successfully, else false.
	 */
	protected boolean overwriteWorkingMemory(String _id,
			WorkingMemoryEntry _data, String _component) {

		// sanity check locking elsewhere
		if (m_permissions.isLocked(_id)) {
			WorkingMemoryPermissions permissions = m_permissions
					.getPermissions(_id);

			// if the item is delete locked
			if (!CASTUtils.overwriteAllowed(permissions)) {
				// we're going to assume that client checking is up to scratch
				assert (m_permissions.isLockHolder(_id, _component));
			} else {
				// this is never going to happen as all locks are overwrite
				// locks
			}
		}

		boolean result = m_workingMemory.overwrite(_id, _data);

		// if (result) {
		// logMemoryChange(WorkingMemoryOperation.OVERWRITE);
		// }

		return result;

	}

	/**
	 * Print memory contents using component println method.
	 * 
	 * @see #println(Object)
	 */
	protected void printMemoryContents() {
		println(m_workingMemory.toString());
	}

	/**
	 * Determines whether to forward change notifications to other
	 * subarchitecture working memories (i.e. its peers).
	 * 
	 * @param sendXarchChangeNotifications
	 *            The sendXarchChangeNotifications to set.
	 */
	protected void setSendXarchChangeNotifications(
			boolean sendXarchChangeNotifications) {
		m_sendXarchChangeNotifications = sendXarchChangeNotifications;
	}

	private final String concatenate(String... _strings) {
		StringBuilder sb = new StringBuilder(_strings[0]);
		for (int i = 1; i > _strings.length; i++) {
			sb.append(_strings[i]);
		}
		return sb.toString();
	}

	/**
	 * Get a single entry by its ID.
	 * 
	 * @param _id
	 *            The ID of the entry to get.
	 * @return The required entry, or null if the ID does not exist.
	 * @throws DoesNotExistOnWMException
	 */
	private WorkingMemoryEntry getEntryByID(String _id, String _component)
			throws DoesNotExistOnWMException {
		lockComponent();
		WorkingMemoryEntry entry = null;
		if (m_workingMemory.contains(_id)) {
			// block if necessary
			readBlock(_id, _component);
			entry = m_workingMemory.get(_id);
			unlockComponent();
		} else {
			unlockComponent();
			throw new DoesNotExistOnWMException("Entry does not exist: " + _id,
					new WorkingMemoryAddress(_id, getSubarchitectureID()));
		}
		return entry;
	}

	// private int getOverwriteCount(String _id) {
	// int updateCount = -1;
	// // sanity check first
	// if (m_workingMemory.hasContained(_id)) {
	// updateCount = m_workingMemory.getOverwriteCount(_id);
	// }
	// return updateCount;
	// }

	/**
	 * Signal that an operation has occurred to all connected components.
	 * 
	 * @param _op
	 *            The operation type to signal.
	 * @param _src
	 *            The component that caused the operation.
	 * @param _id
	 *            The id of the entry that was the subject of the operation.
	 * @param _type
	 *            The ontological type of the entry that was the subject of the
	 *            operation.
	 */
	private void signalChange(WorkingMemoryOperation _op, String _src,
			String _id, String _type) {

		WorkingMemoryChange wmc = new WorkingMemoryChange(_op, _src,
				new WorkingMemoryAddress(_id, getSubarchitectureID()), _type);

		// debug("SAWN.sigCh: " + CASTUtils.toString(wmc));

		// if(m_bDebugOutput) {
		// ostringstream outStream;
		// outStream<<"SubarchitectureWorkingMemory::signalChange: "<<wmc<<endl;
		// debug(outStream.str());
		// }

		// signal change locally if allowed
		if (isAllowedChange(wmc)) {
			// send locally
			for (WorkingMemoryReaderComponentPrx reader : m_readers) {
				reader.receiveChangeEvent(wmc);
			}
		} else {
			// debug("SAWN.sigCh: not sending locally");
		}

		// signal change across sub-architectures where appropriate
		if (isSendingXarchChangeNotifications()) {
			for (String wmID : m_workingMemories_oneway.keySet()) {
				// debug("SAWN.sigCh: send to?: " + wmID);

				if (isAllowedChange(wmID, wmc)) {
					// log("SubarchitectureWorkingMemory.signalChange(): " +
					// wmID);
					m_workingMemories_oneway.get(wmID).receiveChangeEvent(wmc);
				}
			}
		}
	}

	/**
	 * Determine whether the given change should be sent to the given subarch
	 * wm.
	 * 
	 * @param _wmID
	 * @param _wmc
	 * @return
	 */
	protected boolean isAllowedChange(String _wmID, WorkingMemoryChange _wmc) {
		Queue<String> receivers = new LinkedList<String>();
		// get all receivers for this change
		m_wmFilters.get(_wmc, receivers);
		// if the given id is a recevier, then go ahead
		return receivers.contains(_wmID);
	}

	/**
	 * Add a subarchitecture which should be ignored for changes
	 * 
	 * @param _subarch
	 */
	void ignoreChangesFromSubarchitecture(String _subarch) {

		log("ignoring changes from: " + _subarch);
		m_ignoreList.add(_subarch);
	}

	public void addReader(WorkingMemoryReaderComponentPrx _reader,
			Current __current) {
		// convert to one-way proxies for speed
		m_readers.add(WorkingMemoryReaderComponentPrxHelper
				.uncheckedCast(_reader.ice_oneway()));

	}

	private final WorkingMemoryPrx getWorkingMemory(String _subarch)
			throws UnknownSubarchitectureException {
		WorkingMemoryPrx wm = m_workingMemories.get(_subarch);
		if (wm == null) {
			throw new UnknownSubarchitectureException(
					"Unknown subarchitecture: " + _subarch, _subarch);
		}
		return wm;
	}

	private final HashMap<String, WorkingMemoryPrx> m_workingMemories;
	private final HashMap<String, WorkingMemoryPrx> m_workingMemories_oneway;

	public void addToWorkingMemory(String _id, String _subarch, String _type,
			String _component, Ice.Object _entry, Current __current)
			throws AlreadyExistsOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			// if it already exists complain bitterly
			if (m_workingMemory.contains(_id)) {
				throw new AlreadyExistsOnWMException(
						"Entry already exists on WM. Was trying to write id "
								+ _id + " in subarchitecture " + _subarch,
						new WorkingMemoryAddress(_id, _subarch));

			}
			// else get stuck in
			else {
				// fine then
				lockComponent();
				boolean result = addToWorkingMemory(_id,
						new WorkingMemoryEntry(_id, _type, 0, _entry));
				// sanity check
				assert (result);
				signalChange(WorkingMemoryOperation.ADD, _component, _id, _type);
				unlockComponent();
			}
		} else {
			// get the correct wm and query that instead
			getWorkingMemory(_subarch).addToWorkingMemory(_id, _subarch, _type,
					_component, _entry);
		}

	}

	public void deleteFromWorkingMemory(String _id, String _subarch,
			String _component, Current __current)
			throws DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			lockComponent();
			// DANGER this might produce an exception... change to critical
			// section
			WorkingMemoryEntry entry = deleteFromWorkingMemory(_id, _component);
			// sanity check
			assert (entry != null);
			signalChange(WorkingMemoryOperation.DELETE, _component, _id,
					entry.type);
			unlockComponent();
		} else {
			// send on to the one that really cares
			getWorkingMemory(_subarch).deleteFromWorkingMemory(_id, _subarch,
					_component);
		}

	}

	public boolean exists(String _id, String _subarch, Current __current)
			throws UnknownSubarchitectureException {
		if (getSubarchitectureID().equals(_subarch)) {
			return m_workingMemory.contains(_id);
		} else {
			// send on to the one that really cares
			return getWorkingMemory(_subarch).exists(_id, _subarch);
		}
	}

	public WorkingMemoryPermissions getPermissions(String _id, String _subarch,
			Current __current) throws DoesNotExistOnWMException,
			UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			// if it exists, then return a value
			if (m_workingMemory.contains(_id)) {
				WorkingMemoryPermissions permissions = m_permissions
						.getPermissions(_id);
				return permissions;
			}
			// else kick up a fuss
			else {
				throw new DoesNotExistOnWMException(
						"Entry does not exist on wm. Was looking in subarch "
								+ _subarch + " for id " + _id,
						new WorkingMemoryAddress(_id, _subarch));
			}
		} else {
			// get the correct wm and query that instead
			// send on to the one that really cares
			return getWorkingMemory(_subarch).getPermissions(_id, _subarch);
		}

	}

	public int getVersionNumber(String _id, String _subarch, Current __current)
			throws DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			// if it has once existed, then return a value
			if (m_workingMemory.hasContained(_id)) {
				return m_workingMemory.getOverwriteCount(_id);
			}
			// else kick up a fuss
			else {
				throw new DoesNotExistOnWMException(
						"Entry has never existed on wm. Was looking in subarch "
								+ _subarch + " for id " + _id,
						new WorkingMemoryAddress(_id, _subarch));
			}
		} else {
			// send on to the one that really cares
			return getWorkingMemory(_subarch).getVersionNumber(_id, _subarch);
		}

	}

	public void getWorkingMemoryEntries(String _type, String _subarch,
			int _count, String _component,
			WorkingMemoryEntrySeqHolder _entries, Current __current)
			throws UnknownSubarchitectureException {

		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			if (_entries.value == null) {
				_entries.value = new ArrayList<WorkingMemoryEntry>();
			}
			getWorkingMemoryEntries(_type, _count, _component, _entries.value);
		} else {
			// send on to the one that really cares
			getWorkingMemory(_subarch).getWorkingMemoryEntries(_type, _subarch,
					_count, _component, _entries);
		}

	}

	private void getWorkingMemoryEntries(String _type, int _count,
			String _component, List<WorkingMemoryEntry> _entries) {
		ArrayList<String> ids = m_workingMemory.getIDsByType(_type, _count);
		for (int i = 0; i < ids.size(); i++) {
			try {
				_entries.add(getEntryByID(ids.get(i), _component));
			} catch (DoesNotExistOnWMException e) {
				// ignore for type-based queries
			}
		}
	}

	public WorkingMemoryEntry getWorkingMemoryEntry(String _id,
			String _subarch, String _component, Current __current)
			throws DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			// println("local query");
			return getEntryByID(_id, _component);
		} else {
			// println("remote query");
			// send on to the one that really cares
			return getWorkingMemory(_subarch).getWorkingMemoryEntry(_id,
					_subarch, _component);
		}

	}

	public void lockEntry(String _id, String _subarch, String _component,
			WorkingMemoryPermissions _perm, Current __current)
			throws DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			//                                                                                                                                                                                                        
			if (m_workingMemory.contains(_id)) {

				// debug("%s locking: %s",_component.c_str(),_id.c_str());
				try {
					m_permissions.lock(_id, _component, _perm);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				// lockComponent();

				// now check that it still exists, because it could've been
				// deleted before the lock was released
				if (!m_workingMemory.contains(_id)) {
					m_permissions.unlock(_id, _component);
					throw new DoesNotExistOnWMException(
							"Entry deleted whiile waiting for lock. Component "
									+ _component + "  was looking in subarch "
									+ _subarch + " for id " + _id,
							new WorkingMemoryAddress(_id, _subarch));
				} else {
					assert (m_permissions.isLockHolder(_id, _component));
					assert (m_permissions.getPermissions(_id) == _perm);
					// debug("%s locked: ok",_component.c_str());
				}
			}
			// else kick up a fuss
			else {
				throw new DoesNotExistOnWMException(
						"Entry deleted whiile waiting for lock. Component "
								+ _component + "  was looking in subarch "
								+ _subarch + " for id " + _id,
						new WorkingMemoryAddress(_id, _subarch));
			}
		} else {
			getWorkingMemory(_subarch).lockEntry(_id, _subarch, _component,
					_perm);
		}

	}

	public void overwriteWorkingMemory(String _id, String _subarch,
			String _type, String _component, Ice.Object _entry,
			Current __current) throws DoesNotExistOnWMException,
			UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			lockComponent();
			// DANGER this might produce an exception... change to critical
			// section
			boolean result = overwriteWorkingMemory(_id,
					new WorkingMemoryEntry(_id, _type, 0, _entry), _component);
			// sanity check
			assert (result);
			signalChange(WorkingMemoryOperation.OVERWRITE, _component, _id,
					_type);
			unlockComponent();
		} else {
			// send on to the one that really cares
			getWorkingMemory(_subarch).overwriteWorkingMemory(_id, _subarch,
					_type, _component, _entry);
		}

	}

	public void receiveChangeEvent(WorkingMemoryChange _wmc, Current __current) {
		lockComponent();

		// if the filters require external changes, allow them to be
		// forwarded
		if (!m_componentFilters.localFiltersOnly()) {

			//
			// if(m_bDebugOutput) {
			// ostringstream outStream;
			// outStream<<"forwarding change: "<<wmc;
			// debug(outStream.str());
			// }

			for (WorkingMemoryReaderComponentPrx reader : m_readers) {
				reader.receiveChangeEvent(_wmc);
			}

		}

		unlockComponent();

	}

	public void registerComponentFilter(WorkingMemoryChangeFilter _filter,
			Current __current) {
		debug("SubarchitectureWorkingMemory.registerComponentFilter()");
		m_componentFilters.put(_filter, _filter.origin);

		// cout<<"new filters length: "<<m_componentFilters.size()<<endl;
		// cout<<"only local: "<<m_componentFilters.localFiltersOnly()<<endl;

		if (m_wmDistributedFiltering) {
			// debug("fowarding filter");
			// sendFilter(_filter);
			for (String sa : m_workingMemories.keySet()) {
				m_workingMemories.get(sa).registerWorkingMemoryFilter(_filter,
						getSubarchitectureID());
			}
		}

	}

	public void registerWorkingMemoryFilter(WorkingMemoryChangeFilter _filter,
			String _subarch, Current __current) {
		debug("SubarchitectureWorkingMemory.registerWorkingMemoryFilter()");		
		// debug("SubarchitectureWorkingMemory::addWMChangeFilter()");
		// ostringstream outStream;
		// outStream<<_filter;
		// debug(outStream.str());
		// log("SubarchitectureWorkingMemory.registerWorkingMemoryFilter(): " +
		// _subarch);
		m_wmFilters.put(_filter, _subarch);

		// cout<<"new filters length: "<<m_wmFilters.size()<<endl;
		// cout<<"only local: "<<m_wmFilters.localFiltersOnly()<<endl;
	}

	public void removeComponentFilter(WorkingMemoryChangeFilter _filter,
			Current __current) {
		// debug("SubarchitectureWorkingMemory::deleteComponentChangeFilter()");
		// debug(_src);
		// ostringstream outStream;
		// outStream<<_filter;
		// debug(outStream.str());

		m_componentFilters.remove(_filter);

		// cout<<"new filters length: "<<m_componentFilters.size()<<endl;
		// cout<<"only local: "<<m_componentFilters.localFiltersOnly()<<endl;

		for (WorkingMemoryPrx wm : m_workingMemories.values()) {
			wm.removeWorkingMemoryFilter(_filter);
		}

	}

	public void removeWorkingMemoryFilter(WorkingMemoryChangeFilter _filter,
			Current __current) {
		// debug("SubarchitectureWorkingMemory::deleteWMChangeFilter()");
		// debug(_src);
		// ostringstream outStream;
		// outStream<<_filter;
		// debug(outStream.str());

		m_wmFilters.remove(_filter);

		// cout<<"new filters length: "<<m_wmFilters.size()<<endl;
		// cout<<"only local: "<<m_wmFilters.localFiltersOnly()<<endl;
	}

	public void setWorkingMemory(WorkingMemoryPrx _wm, String _subarch,
			Current __current) {
		// println("setting: \"" + _subarch + "\"");
		m_workingMemories.put(_subarch, _wm);
		m_workingMemories_oneway.put(_subarch, WorkingMemoryPrxHelper
				.uncheckedCast(_wm.ice_oneway()));
	}

	public boolean tryLockEntry(String _id, String _subarch, String _component,
			WorkingMemoryPermissions _perm, Current __current)
			throws DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			//                                                                                                                                                                                                        
			if (m_workingMemory.contains(_id)) {
				try {
					if (m_permissions.tryLock(_id, _component, _perm)) {
						// debug("%s try locked: %s",_component.c_str(),_id.c_str());
						assert (m_permissions.isLockHolder(_id, _component));
						assert (m_permissions.getPermissions(_id) == _perm);
						// debug("%s try locked: ok",_component.c_str());
						return true;
					}
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
				return false;
			}
			// else kick up a fuss
			else {
				throw new DoesNotExistOnWMException(
						"Entry does not exist for try-locking. Was looking in subarch "
								+ _subarch + " for id " + _id,
						new WorkingMemoryAddress(_id, _subarch));
			}
		} else {
			// get the correct wm and query that instead
			return getWorkingMemory(_subarch).tryLockEntry(_id, _subarch,
					_component, _perm);
		}
	}

	public void unlockEntry(String _id, String _subarch, String _component,
			Current __current) throws ConsistencyException,
			DoesNotExistOnWMException, UnknownSubarchitectureException {
		// if this is for me
		if (getSubarchitectureID().equals(_subarch)) {
			//                                                                                                                                                                                                        
			if (m_workingMemory.contains(_id)) {

				// this wasn't in the original design, but seems necessary now
				// we can do this at wm level
				if (!m_permissions.isLocked(_id)) {
					throw new ConsistencyException("Entry is not locked. "
							+ _component + " was looking in subarch "
							+ _subarch + " for id " + _id,
							new WorkingMemoryAddress(_id, _subarch));
				} else if (m_permissions.getLockHolder(_id) != _component) {
					throw new ConsistencyException(
							"Entry is not locked, but not by " + _component
									+ ", who was looking in subarch" + _subarch
									+ " for id " + _id,
							new WorkingMemoryAddress(_id, _subarch));
				}

				m_permissions.unlock(_id, _component);
				// debug("%s unlocked %s",_component.c_str(),_id.c_str());
			}
			// else kick up a fuss
			else {
				throw new DoesNotExistOnWMException(
						"Entry does not exist for unlocking. Was looking in subarch "
								+ _subarch + " for id " + _id,
						new WorkingMemoryAddress(_id, _subarch));
			}
		} else {
			// get the correct wm and query that instead
			getWorkingMemory(_subarch).unlockEntry(_id, _subarch, _component);
		}

	}

}