// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "Math.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_Math_mVector2D[] = {
  {"m_x", CORBA::TypeCode::PR_float_tc()},
  {"m_y", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_Math_mVector2D
#  undef _0RL_tc_Math_mVector2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_Math_mVector2D = CORBA::TypeCode::PR_struct_tc("IDL:Math/Vector2D:1.0", "Vector2D", _0RL_structmember_Math_mVector2D, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Math { 
  const ::CORBA::TypeCode_ptr _tc_Vector2D = _0RL_tc_Math_mVector2D;
} 
#else
const ::CORBA::TypeCode_ptr Math::_tc_Vector2D = _0RL_tc_Math_mVector2D;
#endif


static CORBA::PR_structMember _0RL_structmember_Math_mVector3D[] = {
  {"m_x", CORBA::TypeCode::PR_float_tc()},
  {"m_y", CORBA::TypeCode::PR_float_tc()},
  {"m_z", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_Math_mVector3D
#  undef _0RL_tc_Math_mVector3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_Math_mVector3D = CORBA::TypeCode::PR_struct_tc("IDL:Math/Vector3D:1.0", "Vector3D", _0RL_structmember_Math_mVector3D, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Math { 
  const ::CORBA::TypeCode_ptr _tc_Vector3D = _0RL_tc_Math_mVector3D;
} 
#else
const ::CORBA::TypeCode_ptr Math::_tc_Vector3D = _0RL_tc_Math_mVector3D;
#endif



static CORBA::PR_structMember _0RL_structmember_Math_mVector3DWithConfidence[] = {
  {"m_vector", _0RL_tc_Math_mVector3D},
  {"m_confidence", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_Math_mVector3DWithConfidence
#  undef _0RL_tc_Math_mVector3DWithConfidence
#endif
static CORBA::TypeCode_ptr _0RL_tc_Math_mVector3DWithConfidence = CORBA::TypeCode::PR_struct_tc("IDL:Math/Vector3DWithConfidence:1.0", "Vector3DWithConfidence", _0RL_structmember_Math_mVector3DWithConfidence, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Math { 
  const ::CORBA::TypeCode_ptr _tc_Vector3DWithConfidence = _0RL_tc_Math_mVector3DWithConfidence;
} 
#else
const ::CORBA::TypeCode_ptr Math::_tc_Vector3DWithConfidence = _0RL_tc_Math_mVector3DWithConfidence;
#endif










static CORBA::TypeCode_ptr _0RL_tc_Math_mVector3DWithConfidenceSeq = CORBA::TypeCode::PR_alias_tc("IDL:Math/Vector3DWithConfidenceSeq:1.0", "Vector3DWithConfidenceSeq", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_Math_mVector3DWithConfidence, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Math { 
  const ::CORBA::TypeCode_ptr _tc_Vector3DWithConfidenceSeq = _0RL_tc_Math_mVector3DWithConfidenceSeq;
} 
#else
const ::CORBA::TypeCode_ptr Math::_tc_Vector3DWithConfidenceSeq = _0RL_tc_Math_mVector3DWithConfidenceSeq;
#endif



static CORBA::PR_structMember _0RL_structmember_Math_mPose3D[] = {
  {"m_position", _0RL_tc_Math_mVector3D},
  {"m_orientation", _0RL_tc_Math_mVector3D}
};

#ifdef _0RL_tc_Math_mPose3D
#  undef _0RL_tc_Math_mPose3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_Math_mPose3D = CORBA::TypeCode::PR_struct_tc("IDL:Math/Pose3D:1.0", "Pose3D", _0RL_structmember_Math_mPose3D, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace Math { 
  const ::CORBA::TypeCode_ptr _tc_Pose3D = _0RL_tc_Math_mPose3D;
} 
#else
const ::CORBA::TypeCode_ptr Math::_tc_Pose3D = _0RL_tc_Math_mPose3D;
#endif


static void _0RL_Math_mVector2D_marshal_fn(cdrStream& _s, void* _v)
{
  Math::Vector2D* _p = (Math::Vector2D*)_v;
  *_p >>= _s;
}
static void _0RL_Math_mVector2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Math::Vector2D* _p = new Math::Vector2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Math_mVector2D_destructor_fn(void* _v)
{
  Math::Vector2D* _p = (Math::Vector2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Math::Vector2D& _s)
{
  Math::Vector2D* _p = new Math::Vector2D(_s);
  _a.PR_insert(_0RL_tc_Math_mVector2D,
               _0RL_Math_mVector2D_marshal_fn,
               _0RL_Math_mVector2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Math::Vector2D* _sp)
{
  _a.PR_insert(_0RL_tc_Math_mVector2D,
               _0RL_Math_mVector2D_marshal_fn,
               _0RL_Math_mVector2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Math::Vector2D*& _sp)
{
  return _a >>= (const Math::Vector2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Math::Vector2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Math_mVector2D,
                    _0RL_Math_mVector2D_unmarshal_fn,
                    _0RL_Math_mVector2D_marshal_fn,
                    _0RL_Math_mVector2D_destructor_fn,
                    _v)) {
    _sp = (const Math::Vector2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Math_mVector3D_marshal_fn(cdrStream& _s, void* _v)
{
  Math::Vector3D* _p = (Math::Vector3D*)_v;
  *_p >>= _s;
}
static void _0RL_Math_mVector3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Math::Vector3D* _p = new Math::Vector3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Math_mVector3D_destructor_fn(void* _v)
{
  Math::Vector3D* _p = (Math::Vector3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Math::Vector3D& _s)
{
  Math::Vector3D* _p = new Math::Vector3D(_s);
  _a.PR_insert(_0RL_tc_Math_mVector3D,
               _0RL_Math_mVector3D_marshal_fn,
               _0RL_Math_mVector3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Math::Vector3D* _sp)
{
  _a.PR_insert(_0RL_tc_Math_mVector3D,
               _0RL_Math_mVector3D_marshal_fn,
               _0RL_Math_mVector3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Math::Vector3D*& _sp)
{
  return _a >>= (const Math::Vector3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Math::Vector3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Math_mVector3D,
                    _0RL_Math_mVector3D_unmarshal_fn,
                    _0RL_Math_mVector3D_marshal_fn,
                    _0RL_Math_mVector3D_destructor_fn,
                    _v)) {
    _sp = (const Math::Vector3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Math_mVector3DWithConfidence_marshal_fn(cdrStream& _s, void* _v)
{
  Math::Vector3DWithConfidence* _p = (Math::Vector3DWithConfidence*)_v;
  *_p >>= _s;
}
static void _0RL_Math_mVector3DWithConfidence_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Math::Vector3DWithConfidence* _p = new Math::Vector3DWithConfidence;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Math_mVector3DWithConfidence_destructor_fn(void* _v)
{
  Math::Vector3DWithConfidence* _p = (Math::Vector3DWithConfidence*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Math::Vector3DWithConfidence& _s)
{
  Math::Vector3DWithConfidence* _p = new Math::Vector3DWithConfidence(_s);
  _a.PR_insert(_0RL_tc_Math_mVector3DWithConfidence,
               _0RL_Math_mVector3DWithConfidence_marshal_fn,
               _0RL_Math_mVector3DWithConfidence_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Math::Vector3DWithConfidence* _sp)
{
  _a.PR_insert(_0RL_tc_Math_mVector3DWithConfidence,
               _0RL_Math_mVector3DWithConfidence_marshal_fn,
               _0RL_Math_mVector3DWithConfidence_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Math::Vector3DWithConfidence*& _sp)
{
  return _a >>= (const Math::Vector3DWithConfidence*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Math::Vector3DWithConfidence*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Math_mVector3DWithConfidence,
                    _0RL_Math_mVector3DWithConfidence_unmarshal_fn,
                    _0RL_Math_mVector3DWithConfidence_marshal_fn,
                    _0RL_Math_mVector3DWithConfidence_destructor_fn,
                    _v)) {
    _sp = (const Math::Vector3DWithConfidence*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Math_mVector3DWithConfidenceSeq_marshal_fn(cdrStream& _s, void* _v)
{
  Math::Vector3DWithConfidenceSeq* _p = (Math::Vector3DWithConfidenceSeq*)_v;
  *_p >>= _s;
}
static void _0RL_Math_mVector3DWithConfidenceSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Math::Vector3DWithConfidenceSeq* _p = new Math::Vector3DWithConfidenceSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Math_mVector3DWithConfidenceSeq_destructor_fn(void* _v)
{
  Math::Vector3DWithConfidenceSeq* _p = (Math::Vector3DWithConfidenceSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Math::Vector3DWithConfidenceSeq& _s)
{
  Math::Vector3DWithConfidenceSeq* _p = new Math::Vector3DWithConfidenceSeq(_s);
  _a.PR_insert(_0RL_tc_Math_mVector3DWithConfidenceSeq,
               _0RL_Math_mVector3DWithConfidenceSeq_marshal_fn,
               _0RL_Math_mVector3DWithConfidenceSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Math::Vector3DWithConfidenceSeq* _sp)
{
  _a.PR_insert(_0RL_tc_Math_mVector3DWithConfidenceSeq,
               _0RL_Math_mVector3DWithConfidenceSeq_marshal_fn,
               _0RL_Math_mVector3DWithConfidenceSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Math::Vector3DWithConfidenceSeq*& _sp)
{
  return _a >>= (const Math::Vector3DWithConfidenceSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Math::Vector3DWithConfidenceSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Math_mVector3DWithConfidenceSeq,
                    _0RL_Math_mVector3DWithConfidenceSeq_unmarshal_fn,
                    _0RL_Math_mVector3DWithConfidenceSeq_marshal_fn,
                    _0RL_Math_mVector3DWithConfidenceSeq_destructor_fn,
                    _v)) {
    _sp = (const Math::Vector3DWithConfidenceSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_Math_mPose3D_marshal_fn(cdrStream& _s, void* _v)
{
  Math::Pose3D* _p = (Math::Pose3D*)_v;
  *_p >>= _s;
}
static void _0RL_Math_mPose3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  Math::Pose3D* _p = new Math::Pose3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_Math_mPose3D_destructor_fn(void* _v)
{
  Math::Pose3D* _p = (Math::Pose3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const Math::Pose3D& _s)
{
  Math::Pose3D* _p = new Math::Pose3D(_s);
  _a.PR_insert(_0RL_tc_Math_mPose3D,
               _0RL_Math_mPose3D_marshal_fn,
               _0RL_Math_mPose3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, Math::Pose3D* _sp)
{
  _a.PR_insert(_0RL_tc_Math_mPose3D,
               _0RL_Math_mPose3D_marshal_fn,
               _0RL_Math_mPose3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, Math::Pose3D*& _sp)
{
  return _a >>= (const Math::Pose3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const Math::Pose3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_Math_mPose3D,
                    _0RL_Math_mPose3D_unmarshal_fn,
                    _0RL_Math_mPose3D_marshal_fn,
                    _0RL_Math_mPose3D_destructor_fn,
                    _v)) {
    _sp = (const Math::Pose3D*)_v;
    return 1;
  }
  return 0;
}

