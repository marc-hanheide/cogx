/*!
\mainpage The Binding Subarchitecture
\anchor binding_main

The purpose of the binding subarchitecture is to support the creation
of a common representation across multiple subarchitectures.

\see http://www.dfki.de/~henrikj/publications/hri2008binding.pdf
\see also \ref binding_chlog
\see also \ref proper_usage_tips
\see \ref how_to_load_binding_data_cpp
\see \ref how_to_query_the_binder
\see \ref how_to_add_features

(this text needs to be fixed)

The subarchitectures should provide binding proxies

\section using_AbstractMonitor The AbstractMonitor

Using the \c Binding::AbstractMonitor (or in Java \p
binding::abstr::AbstractMonitor) is quite simple. \p AbstractMonitor resolved ?

\attention Before using your monitor to create proxies you MUST set
the ID of the binding subarchitecture using \p Binding::AbstractMonitor::setBindingSA. If you don't, you'll get a warning and a crash.

\sa BindingData::FeaturePointer BindingData::BindingProxy BindingData::BindingUnion

\subsection create_proxy Creating a proxy

\msc
    hscale = "2.4";
    YourMonitor,AbstractMonitor[URL = "\ref Binding::AbstractMonitor"],BindingWorkingMemory[URL = "\ref Binding::BindingWorkingMemory"],broadcast;
    --- [label="ready to start new proxy", ID="ready"];
    YourMonitor=>AbstractMonitor [label="startNewBasicProxy()", URL="\ref Binding::AbstractMonitor::startNewBasicProxy()", ID="1"];
    YourMonitor=>AbstractMonitor [label="addFeatureToCurrentProxy(FeatureType)", URL="\ref Binding::AbstractMonitor::addFeatureToCurrentProxy"];
    AbstractMonitor->BindingWorkingMemory [label="add feature"];
    YourMonitor<<AbstractMonitor [label="BindingData::FeaturePointer", URL="\ref BindingData::FeaturePointer"];
    ... [label = "Add any number of features from BindingData::Feature", URL="\ref BindingData::Feature", ID ="2"];
    YourMonitor=>AbstractMonitor [label="addFeatureToCurrentProxy(FeatureType)", URL="\ref Binding::AbstractMonitor::addFeatureToCurrentProxy"];
    AbstractMonitor->BindingWorkingMemory [label="add feature"];
    YourMonitor<<AbstractMonitor [label="BindingData::FeaturePointer", URL="\ref BindingData::FeaturePointer"];
    YourMonitor=>AbstractMonitor [label="storeCurrentProxy()", URL="\ref Binding::AbstractMonitor::storeCurrentProxy()"];
    AbstractMonitor->BindingWorkingMemory [label="add proxy", ID="3"];
    BindingWorkingMemory->broadcast [label="proxy added"];
    --- [label="ready to start new proxy", ID="ready"];
\endmsc

\li \c 1 Alternatively, a new proxy can be started with \p
Binding::AbstractMonitor::startNewBasicProxy(), \p
Binding::AbstractMonitor::startNewGroupProxy(), \p
Binding::AbstractMonitor::startNewRelationProxy() or
\p Binding::AbstractMonitor::changeExistingProxy()  (see \ref update_proxy)
\li \c 2 avoid inconsistencies, the binder will not mind, but others
might 
\li \c 3 the proxy contains pointers to all the stored features
\li \c ready Only one proxy can be "open" at a time. This simplifies
the interface to the abstract proxy, but it may make things more
complicated if you want to store a set of proxies. You may want to
inherit from \c AbstractProxy privately and add another public
interface to your monitor that can take a reference to your data type
(and then take care of the complexity of adding multiple proxies behind
this interface).

\subsection delete_proxy Delete an existing proxy

Just call \p Binding::AbstractMonitor::deleteExistingProxy, this will
take care of deletion of the proxy, and it's features.

\attention Do not delete any features yourself.  The deletion will be
handled by a garbage collector component (yet to be implemented). If
your subarchitecture deletes features, it may accidentally delete
features that are shared among several proxies (e.g. for group
proxies).

\subsection update_proxy Update an existing proxy

When you want to update an existing proxy, you probably want to change
only a feature's value or so. This is not possible to do. The binder
assumes that a feature is constant and never changed until its
deletion (otherwise a lot more admin of signals and and features would
have to be taken care of behind the scenes, e.g. for shared
features). To change a feature, e.g. \c BindingData::Feature::Colour from
"red" to "blue" you need to replace a feature with a new one.

There are two main ways to change the value of a feature (or to delete
it completely):

\li When you call \c Binding::AbstractMonitor::changeExistingProxy()
you can select what feature types to delete, and then you add the same
type with a different value. For example, you can remove all \c
BindingData::Feature::Colour and then add \c
BindingData::Feature::Colour corresponding to "blue" to make sure that
there is only one \c BindingData::Feature::Colour-feature, and it has
the value "blue". This is the most efficient, since it simply omit
copying some feature pointers. It's also safe when you really want to
make sure that your updated feature is not conflicting with an other
feature of the same type.  
\li You can also delete the feature
explicitly after the proxy is loaded with 
\p Binding::AbstractMonitor::deleteFeatureFromCurrentProxy().

\subsection cancel_proxy Cancel a new proxy

When your monitor is creating a new proxy, and you for some reason
realize that the proxy is not necessary, you can cancel it instead of
storing it. Just call \c
Binding::AbstractMonitor::cancelCurrentProxy()

\attention cancelling a proxy which you are updating results in undefined behaviour. Don't do it...

\section Bla

\page proper_usage_tips Proper usage tips

\section bug83 regarding fast proxy updates (bug 83)

\see https://bugzilla.cs.bham.ac.uk/show_bug.cgi?id=83

do you get an exception looking a bit like this?:
\code
terminate called after throwing an instance of 'Binding::BindingException'
  what():  ILLEGAL!!! Attempt to update a proxy while binder is working on it
(or one that has been cancelled). ProxyID: 0:vision.bindmonitor:data
\endcode

when there is a very fast proxy update, you need to ask yourself if it
is really necessary. I believe that it isn't in most cases. This is the reason
I added this strictness. If you for example have N features to add to a proxy,
why not add all of them before storing the proxy?

And if the "only one proxy at a time" requirement on the abstract binder is a
problem, I suggest you to create some intermediate representation of all your
proxies and then store them one at a time when you know things are complete.
(this is trivial to do since you can reuse the representations from \link
BindingFeatures.idl \endlink)

\page how_to_load_binding_data_cpp How to load binding data (C++)


First of all, let your component inherit (apart from the cast component) also from
  \p Binding::AbstractBindingWMRepresenter (alt. have a \p
  Binding::AbstractBindingWMRepresenter data member)

\p Binding::AbstractBindingWMRepresenter loads and represent \p
BindingData::BindingProxy and \p BindingData::BindingProxy as \p
Binding::LocalBindingData, instantiated as \p Binding::LBindingProxy
and \p Binding::LBindingUnion respectively (where L stands for
'local'). These local representations wrap the the IDL structs and
provides member functions. The original IDL data members can also be
accessed through \p Binding::LBindingProxy::operator->() and \p
Binding::LBindingUnion::operator->().

Worth noticing here is that all the \p BindingFeatures have a simliar
local representation: Binding::AbstractFeature. The derived classes
are in the templated class Binding::Feature.
\remark perhaps a renaming is in place here: AbstractLocalFeature and LFeature...
\remark the \p Binding::BindingFeatureOntology is in charge of associating abstract feature with the correct underlying ID struct. There is a mapping from the runtime \p std::type_info of the feature to a \p Binding::FeatureHelper for each feature. This connection is made in the \p Binding::FeatureRegistrant (where all the mapping to the \p Binding::AbstractInternalComparator is made too)

Now you have a few options: 

\section bnd_load_dir Load directly with the cache:
you can load proxies and unions using the
\p Binding::AbstractBindingWMRepresenter::m_proxyLocalCache and 
\p Binding::AbstractBindingWMRepresenter::m_unionLocalCache respectively. 
\remark The \p
cast::CASTDataLocalCache is similar to \p cast::CASTDataCache, but it
also translates the IDL struct into whatever local data type you want.

You can also load bindig features directly using this \p Binding::FeatureLoader : \p Binding::AbstractBindingWMRepresenter::m_featureLoader.
\remark \p BindingFeatures are always \p const on WM. That means that they are only added and removed, but never overwritten, therefore the \p Binding::FeatureLoader only loads each feature once (it's basically just a special kind of cache)
\remark have a look at the convenient functions in \link FeatureExtractor.hpp \endlink to cast abstract features into the corresponding idl struct or the templated \p Binding::Feature

Example:
\code
  const LBindingProxy& proxy(m_proxyLocalCache[proxyID]);
  // member function example:
  if(proxy.bound()) {
    cout << "I'm bound to\n" << proxy.bindingUnion().id() << " which is in turn is bound to " 
         << proxy.bindingUnion().proxyIDs() << " proxies and has " 
         << proxy.bindingUnion().featureSet().size() << " proxies\n";
  }
  // data member access:
  proxy->m_bestUnionsForProxyID
\endcode

\section bnd_load_extractors Loading with BindingGraphHandler and Extractors

the \p Binding::BindingGraphHandler loads proxies and unions (using a
referenced \p Binding::AbstractBindingWMRepresenter of choice) and
caches the data locally. This means that the data gets "frozen" at the
time of loading.

example:
\code
  BindingGraphHandler handler(*this);
  set<string> ids;
  ids.insert(proxyID)
  // load proxy
  Binding::ProxySet proxies = handler.loadProxies(ids);
  // get the union
  Binding::UnionSet unions = handler.extractUnionsFromProxies(proxies);
  // get all bound proxies (will not reload the first proxy, even if changed)
  proxies = handler.extractProxiesFromUnions(unions);
  // get all related proxies (advanced usage)
  proxies = 
    handler.extractProxiesFromProxies(one_proxy,
                                      RecursiveExtractor<ProxyPtr>(OutPortsExtractor<ProxyPtr>() || 
                                                                   InPortsExtractor<ProxyPtr>(),
                                                                   handler.loadProxyFctPtr()));
\endcode

\see \p Binding::RecursiveExtractor, \p Binding::OutPortsExtractor, \p Binding::InPortsExtractor and Binding::AbstractExtractor and associated operators etc in \link BasicExtractors.hpp \endlink and \link Extractors.hpp \endlink for more possible ways to extract proxies and unions from each other

\remark Please suggest/implement more extractors if you need them. They are quite simple internally.

If you want to make sure that the loaded proxies and unions are consistent with WM, you can use one of the predicates: \p Binding::ConsistencyCheck

example (no quarantee of correctness as I have brutally copypasted this):
\code
  bool consistency_checked = false;
  while(!consistency_checked) {
    if(true_for_all(handler.allProxiesFromWM(),ConsistencyCheck<ProxyPtr>(*this))) {
      consistency_checked = true;
    } else {
      handler.reloadAllLoadedData();
    }
  }
\endcode

You can also select subsets of the loaded proxies/unions using the predicates:

\code
   // only get the basic proxies (i.e. no groups or relations) with exactly one concept feature
   proxies = proxies | TypeCheck<ProxyPtr>(BindingData::BASIC) && hasFeature<ProxyPtr,BindingFeatures::Concept>(1);
\endcode

\see Have a look at implemented predicates and associated convenience functions and operators in \link BasicPredicates.hpp \endlink  and \link Predicates.hpp \endlink

\remark Please suggest/implement more predicates if you need them. They are quite simple internally and new ones are added almost every release since they are used a lot in the testing

\see \link TesterMonitor.cpp \endlink for a lot of examples of how to use predicates and extractors.

More examples from \link TesterMonitor.cpp \endlink:
\code
  assert(true_for_all(proxies,TypeCheck<ProxyPtr>(BindingData::BASIC)    ->* InportsCountCheck<ProxyPtr>(1)));
  assert(true_for_all(proxies,TypeCheck<ProxyPtr>(BindingData::RELATION) ->* OutportsCountCheck<ProxyPtr>(2)));
  assert(true_for_all(unions,TypeCheck<UnionPtr>(BindingData::BASIC)     ->* InportsCountCheck<UnionPtr>(1)));
  assert(true_for_all(unions,TypeCheck<UnionPtr>(BindingData::RELATION)  ->* OutportsCountCheck<UnionPtr>(2)));
.
.
.
  proxies = proxies | hasFeature<ProxyPtr,BindingFeatures::Singular>();
  assert(true_for_all(proxies, FreeSingular(m_handler))); // in this case they (it) should be free
  proxies = m_handler.extractProxiesFromProxies(proxies, GroupProxyFromSingularExtractor<ProxyPtr>());
  assert(proxies.size() == 1);
  assert(true_for_all(proxies,TypeCheck<ProxyPtr>(BindingData::GROUP)));
  proxies = m_handler.extractProxiesFromProxies(proxies, SingularProxiesFromGroupExtractor<ProxyPtr>());
  assert(true_for_all(proxies, 
                      hasFeature<ProxyPtr,BindingFeatures::Singular>() && 
                      FreeSingular(m_handler))); 
.
.
.
  assert(true_for_all(proxies,
                      featureCheck<ProxyPtr,BindingFeatures::Concept>(ConceptRegexMatcher("updated_test_concept_\\d+"))));
\endcode

\page how_to_query_the_binder How to query the binder

\attention When you query the binder the binder will only provide you the best answer it can.
\attention Proxies, unions and feature are all added and removed outside the control of the binder itself.
\attention This means that the reply you get may be false already immediately after it was created. 
\attention Make sure you deal with this, for example by always try-catching DoesNotExistOnWMExceptions wen you read stuff from the binder.

First, read about the structs in 
\link BindingQueries.idl\endlink

You can use the \p Binding::QueryUtils to easily create basic or
advanced queries. If you want to do advanced stuff (like querying
about more than one thing at a time), ask several queries and merge
the results.

\remark for even more advanced queries, make sure you work in C++ and then have a look at \ref how_to_load_binding_data_cpp

Example (C++)
\code
  startNewBasicProxy();
  BindingFeatures::Concept concept;
  concept.m_concept = CORBA::string_dup("ball");
  addFeatureToCurrentProxy(concept);
  ball_id = storeCurrentProxy();
  
  // 1st, create an instantiation of QueryUtils:
  QueryUtils utils(dynamic_cast<cast::PrivilegedManagedProcess&>(*this),
                   bindingSubarchID());

  // then start asking stuff:
  
  BindingFeatures::Concept concept;
  concept.m_concept = CORBA::string_dup("mug");
  string mug_query_id = utils.askBasicQuery(concept,
					    ball_id);
  // then listen for a WMC overwrite of your mug_query_id and that's your result, 
  // based on whether the comparator thing a mug is a ball or not
  
  string colour_query = utils.askBasicQuery<BindingFeatures::Colour>(ball_id);
  // then listen for your colour_query and it will tell you if the proxy at address 
  // ball_id has/or is bound to anything that has some colour

  concept.m_concept = CORBA::string_dup("thing");      
  string thing_query = utils.askAdvancedQuery(concept);
  /// which will tell you a lot about things on WM

\endcode


\page how_to_add_features How to add new binding features

First of all, the golden rule is to mimic with care and
understanding. Everything is more or less documented already, but
found in different places. Before you ad your new feature, make sure
you understand how the other, existing, features are implemented!

First step is to read what is in \link BindingFeatures.idl \endlink
where all features are defined. This is where you first need to add
your feature. And you need to do it exactly like for the other
features (e.g. with m_parent defined).

The next step is to let the binder kow about your feature. Study all
files in \link bindin/utils/feature-specialization \endlink etc... hmm in summary:

\li add feature in \link BindingFeatures.idl \endlink
\li create a helper, e.g. like \p Binding::AreaIDHelper ()
\li possibly, create som internal comparators, e.g. like \p Binding::AreaIDComparator or \p Binding::OtherSourceIDvsSourceIDComparator
\li include your header in \link IncludeAllFeatureHelpers.hpp \endlink
\li add your helper's cpp and hpp file in the CMakeLists.txt where all the others are found too
\li make sure your helper (and comparator(s)) are registered in the \p Binding::FeatureRegistrant:

from \link FeatureRegistrant.cpp \endlink
\code
  helper = shared_ptr<const AbstractFeatureHelper>(new SourceIDHelper);
  _ontology.addFeatureObjectType<BindingFeatures::SourceID>(helper);
  //...
    comparator = shared_ptr<const AbstractInternalComparator>(new SizeComparator);  
  registerInternalComparator(_ontology,comparator);
  comparator = shared_ptr<const AbstractInternalComparator>(new OtherSourceIDvsSourceIDComparator);
  registerInternalComparator(_ontology, comparator);
\endcode

Follow the links above (and most importantly, up to the relevant base
classes \p Binding::AbstractFeatureHelper and \p
Binding::AbstractInternalComparator) to the more detailed docs and
specifications and examples. In most cases it is simplest to just add
helpers that mimic existing helpers (I implemented all of them based
on copy-pasting and replacing, essentially).

I hope I didn't forget anything! But if i did... be patient, look at
the existing code, and you'll see what is missing. The compiler will
also help you, I hope...

\page proxy_deletion_discussion Proxy deletion discussion

\verbatim
Nick Hawes <...@...> Wed, Jul 23, 2008 at 7:28 PM 
To: ...@...
 
Hi all,

During today's PlayMate skype meeting (minutes coming soon!) we again
discussed the issue of when proxies should be made available for
binding on binding wm. This is my attempt to summarise that
discussion...

The general consensus appeared to be that proxies should only be
available for binding whilst they can be of use in the current task or
episode. The problem appears to break down into two parts:

(a) a mechanism for making proxies available or unavailable

(b) a mechanism for determining when a proxy should be available or
unavailable


For (a) there are two general approaches:

(a.1) if a proxy exists it is available, to make it unavailable it
should be deleted from binding wm.

(a.2) a proxy is given some feature to determine which it is available
or not. In this case available means "available for binding into
unions with all other available proxies". There may be other proxies
and unions on binding wm containing proxies that were previously
available, but they are no longer in the current available set.


For me (a.1) seems a lot cleaner, but possibly restrictive in the most
general case (but that's not necessarily our problem today)


For (b) I believe there are a couple of approaches:


(b.1) each binding monitor decides on its own when it's proxies should
be available and then unavailable using some kind of local heuristic.

(b.2) binding monitors collaborate to work out when proxies should be
made unavailable.

(b.3) an external process decides when proxies should be available or
unavailable.


(b.1) is what we're doing at the momemt. E.g. vision proxies are
available when the object is visible, but unavailable (deleted) when
gone from the scene. Comsys proxies are available whenever a discourse
reference may be used. This is potentially any time so they are never
made unavailable. This latter case illustrates the problem, a single
subarchitecture can never really determine in advance how long it's
proxies will be useful for, or when they are no longer going to be
needed. (correct me if I'm wrong though!)

(b.2) looks potentially appealing, but I'm not sure how well it will
work because it's really just taking some of the logic from (b.1) and
spreading it about.

(b.3) is interesting. GJ suggested that the planner was the only
component that could tell when an episode/task/whatever had been
completed and thus the proxies involved could potentially be made
unavailable. This seems to make sense, but only if all behaviours are
the result of plan execution. This is almost the case, except for
visual learning, but this could be incorporated into the planned
behaviour pretty simply too.


My hunch is that (a.1) is the simplest solution for making things
available and unavailable, and it has the advantage of not requiring
any more features (and therefore compilation time). For (b) it's not
obvious exactly what's best. (b.1) would require the least effort, but
might require each monitor to implement a bunch of behaviour specific
options (hacks?). (b.3) is the most general, but it could be overkill
and may cause us problems.



If we took the (b,3) route I suggest that we have a new struct in
binding called something like MakeProxyUnavailable which is used to
tell a monitor that certain proxies should be deleted if it's ok with
them (i.e. they can employ a bit of b.1 logic too... so vision doesn't
have to delete proxies for objects that are still visible). We can
then experiment with who creates these structs and when. E.g. we can
get the motivation sa to generate these structs after a plan execution
is complete. This would allow us to experiment with (b.2) a bit as
well (e.g. vision or nav.sa could dictate when all out of sight
proxies should be deleted...) but probably only for local debugging
and testing type behaviours.


Does that summary sound fair? How about the conclusions? Shoot now!
Also, more concrete examples of the behaviour of the playmate and
explorer using the proposed approaches would be good.

cheers,

-- 
Dr. Nick Hawes

Research Fellow, Intelligent Robotics Lab
School of Computer Science, University of Birmingham
www.cs.bham.ac.uk/~nah || +44 121 415 8279 || skype: nickhawes

_______________________________________________
cosy-integration mailing list

https://mailman.cs.bham.ac.uk/mailman/listinfo/cosy-integration
Henrik Jacobsson <...@...> 	Thu, Jul 24, 2008 at 12:06 PM
To: Nick Hawes <...@...>
Cc: ...@...
Greetings fellow integrators,

<...>
> The general consensus appeared to be that proxies should only be available
> for binding whilst they can be of use in the current task or episode. The
> problem appears to break down into two parts:

agreed.

> (a) a mechanism for making proxies available or unavailable
>
> (b) a mechanism for determining when a proxy should be available or
> unavailable

Good summary.

> For (a) there are two general approaches:
>
> (a.1) if a proxy exists it is available, to make it unavailable it should be
> deleted from binding wm.
>
> (a.2) a proxy is given some feature to determine which it is available or
> not. In this case available means "available for binding into unions with
> all other available proxies". There may be other proxies and unions on
> binding wm containing proxies that were previously available, but they are
> no longer in the current available set.
>
> For me (a.1) seems a lot cleaner, but possibly restrictive in the most
> general case (but that's not necessarily our problem today)

Yes, but it is a bit problematic if there are two users of the same
proxy. If one user id finished with the proxy it does no longer want
to bind anything to it, possibly. But deleting it will disrupt the
second user. But you're right, it may not be a problem today, or in
the demos (not sure about the explorer scenario though).

a.2 can be easily implemented by updating proxies with an added
http://www.dfki.de/~henrikj/binding_release8/subarchitectures/binding.sa/doc/cpp/html/structBindingFeatures_1_1ExistingProxyID.html
It's not very restrictive really. For example, if UOL's active learner
no longer want their visual proxies to bind with a specific existing
comsys proxy that they have already used once for learning, they can
do this. They should just make sure their proxies refer explicitly to
the comsys proxy (with the negated ExistingProxyID). This should solve
the problem without any further implicit signals being sent between
the subarchs.

> For (b) I believe there are a couple of approaches:
>
> (b.1) each binding monitor decides on its own when it's proxies should be
> available and then unavailable using some kind of local heuristic.
>
> (b.2) binding monitors collaborate to work out when proxies should be made
> unavailable.
>
> (b.3) an external process decides when proxies should be available or
> unavailable.
>
> (b.1) is what we're doing at the momemt. E.g. vision proxies are available
> when the object is visible, but unavailable (deleted) when gone from the
> scene. Comsys proxies are available whenever a discourse reference may be
> used. This is potentially any time so they are never made unavailable. This
> latter case illustrates the problem, a single subarchitecture can never
> really determine in advance how long it's proxies will be useful for, or
> when they are no longer going to be needed. (correct me if I'm wrong
> though!)

Yep, b.1 is not a solution at all...

> (b.2) looks potentially appealing, but I'm not sure how well it will work
> because it's really just taking some of the logic from (b.1) and spreading
> it about.

I suppose my suggestion falls in this category? I had sth more strict
in mind though... registration of providers of information (servers),
explicit user registration (cf. clients) and usage registration (cf.
client sessions on the server). Sure it spreads the logic about, but
in a rigorous way (if implemented properly). I can see it may require
a lot of time to implement though... especially if we consider that
solution b.3. is half ready....

> (b.3) is interesting. GJ suggested that the planner was the only component
> that could tell when an episode/task/whatever had been completed and thus
> the proxies involved could potentially be made unavailable. This seems to
> make sense, but only if all behaviours are the result of plan execution.
> This is almost the case, except for visual learning, but this could be
> incorporated into the planned behaviour pretty simply too.

If that is the case, b.3 is the way to go. In a way, the proxies and
the information they contain, can be seen as a shared resource. And
access shared resourced should be handled by a central mechanism
capable of scheduling the access. So the planner is the prime
candidate!

> My hunch is that (a.1) is the simplest solution for making things available
> and unavailable, and it has the advantage of not requiring any more features
> (and therefore compilation time).

IMO, a.2 also will not require anything beyond what is already there.
The required features are there.

> For (b) it's not obvious exactly what's
> best. (b.1) would require the least effort, but might require each monitor

IMO, b.1 requires the most effort to make correctly. We'd basically
need specific logics to deal with each subscenario in each SA. And we
need to do that correctly and be able to test it... so a more
stringent approach may actually bring less effort...

> to implement a bunch of behaviour specific options (hacks?). (b.3) is the
> most general, but it could be overkill and may cause us problems.

not 100% sure it's more general than my suggested solution, but I
agree it may be the way to go.

> If we took the (b,3) route I suggest that we have a new struct in binding
> called something like MakeProxyUnavailable which is used to tell a monitor
> that certain proxies should be deleted if it's ok with them (i.e. they can
> employ a bit of b.1 logic too... so vision doesn't have to delete proxies
> for objects that are still visible). We can then experiment with who creates
> these structs and when. E.g. we can get the motivation sa to generate these
> structs after a plan execution is complete. This would allow us to
> experiment with (b.2) a bit as well (e.g. vision or nav.sa could dictate
> when all out of sight proxies should be deleted...) but probably only for
> local debugging and testing type behaviours.

Sure.. but as argued at the top, a.2 may still be needed. But it
should also be easy to implement with the given features etc.

> Does that summary sound fair? How about the conclusions? Shoot now! Also,

*bang* *bang*

> more concrete examples of the behaviour of the playmate and explorer using
> the proposed approaches would be good.

Indeed... I give that to someone else... fingers itch to code now...

cheers
// Henrik J.

\endverbatim

\section older_suggestion Older suggestion

\verbatim
Henrik Jacobsson  ...@... Wed, Jul 2, 2008 at 3:13 PM

The problem is this, as I see it:

system A provides a service to "user" systems B, C and D without
exactly knowing what the users are doing and what they need the
information for. So if A creates a proxy, it can usually not delete
until it can know it is safe w.r.t. B,C & D, somehow. For example, if
comsys provides a bunch of proxies they may be used by visual
learning, planning and perhaps something else simultaneusly.

There is simply no magic solution to this... a comsys proxy may be
relevant for hours if it's part of a plan, and seconds if it's part of
a visual learning task. To suggest that it's comsys's responsibility
is wrong. To suggest it is any specific SA's responsibility is wrong.
We need system thinking!

My proposed solution:

1. all users must register themselves as users
2. all users must always tell the provider when they are finished with
a proxy (even after noops)
3. the provider only deletes proxies when all registered users have
signalled that they are finished
4. (if there are no registered users, delete as you please (in the
case of vision, you may want to have a feature stating wheter a proxy
is currently visible or not, we did have one earlier, but noone used
it))

Another problem: If there are several users, and one of them really
want to avoid having there stuff bind with the used proxy again before
it is deleted (for example if vision is finished after a few seconds
with a proxy that can't be deleted until a 10 minute plan is finished
with it)...

this problem can be solved by the user SA through a negated \p BindingFeatures::ExistingProxyID
and/or a negated \p BindingFeatures::OtherSourceID
referring to your own SA id. As a side effect, this will solve the
visual learning problem with remaning comsys proxies even before we
solve the problem in general. You could have it implemented today!

problem solved ;-)

You may call it "a hack to avoid garbage collection". But try coming
up with something simpler and cleaner first... As we approach the
deadline we need to accept hacks anyhow... BUT ONLY AS THEY ARE AS
SIMPLE AND ROBUST AS POSSIBLE AND DO NOT RISK BEING RUINED BY STRESSED
PROGRAMMERS WHEN WE NEAR THE DEADLINE... very important IMO...

// Henrik J.
\endverbatim

*/	