
# ********** WH-WORDS ****************

# This file contains the cats and families for clause initial question words
# like who, what, where, how, etc. 

# For the sake of incremental parsing and early projection, Wh-Words are treated 
# as the semantic and syntactic head of question clauses. 

# There are two entries for most of the question words, one for copulars, 'Who am I' 
# and one for other verbs which must use an auxillary, 'What did you see'

# They assign mood (both syntactic and semantic), select for the clauses Subject, 
# and properly distribute the features dictated by the specifics of the question word

# ************* Role-Defined ('extracted') Constituents *******************

# In addition to questioning Wh-words, this file also contains the cats and families
# necessary for handling 
#             put it WHERE I told you to put it __ 
#             I picked up WHAT you wanted __
#             I don't know WHO he is
#             I am going WHERE GJ is sleeping
# and         what I got you got to give it to your mama  
#                    (this is assuming Left-dislocation is handled )
#
# i.e.  NPs, preps, etc which are defined by the role they are playing in some given event.  

##########################
## SEMANTIC DEFINITIONS ##
##########################

   def WH-ITEM(arg)    {<Wh-Restr>(arg)}
   
##############
## FAMILIES ##
##############

 ## Family Building Macros ##

  def finite-entry(item, syn, sem)  {

      entry: from-s(s-int)  / ( s(VFORM:VFORM FIN:FIN POL:POL) +subj() item ) 
	                        /^ subj(NUM:NUM PERS:PERS)
						    /  finit()
							syn                   
			 : EVENT( INT() SUBJECT() WH-ITEM(sem) ); 
  } 

  def copular-entry(item, syn, sem)  {
	  entry: from-s(s-int)  /^ subj(NUM:NUM PERS:PERS)
	                        /( s(VFORM:VFORM FIN:FIN POL:POL) +subj() item ) 
							syn
       		 : E:ascription( INT() SUBJECT() WH-ITEM(sem) ); 

  } 

 
  def wh-subj-entry(syn, sem) { entry: from-s(s-int)     / ( s(fin) \ np[F 3rd s-sg] ) syn    :    EVENT( INT() <Subject>(F) WH-ITEM(sem) );  }


  def wh-comp-entries(item, syn, sem){ finite-entry ( item, syn, sem )
                                       copular-entry( item, syn, sem ) 
									 }
		
  def wh-all-entries(item, syn, sem){ finite-entry ( item, syn, sem )
                                      copular-entry( item, syn, sem )
								      wh-subj-entry( syn, sem ) 
									  }

    
   ## The Families ##

   family Quality-class          { entry: qclass<10>[C] : C(*) ; } 
   
   family Wh-np- (Wh)              { wh-all-entries ( / np<12>[F]   ,                             , F:entity * ) }
   
   family Wh-np-spec- (Wh)         { wh-all-entries ( / np<12>[F]   , / n<12>[F s-sg]             , V * <Scope>(F:entity) ) 
                                   wh-all-entries ( / np<12>[F]   ,                             , V * <Scope>(F:entity context) ) }   
								   								   
   family Wh-np-quant-count- (Wh)  { wh-all-entries ( / np<12>[F]   , / n<12>[F s-pl]             , V * <Scope>(F:entity)          )
                                   wh-all-entries ( / np<12>[F]   ,                             , V * <Scope>(F:entity context) ) }
   
   family Wh-np-quant-mass- (Wh)   { wh-all-entries ( / np<12>[F]   , / n<12>[F s-mass]           , V * <Scope>(F:entity) ) 
                                   wh-all-entries ( / np<12>[F]   ,                             , V * <Scope>(F:entity context) ) }
    
   family Wh-np-qclass- (Wh)       { wh-all-entries ( / np<12>[F]   , / n<12>[F] /qclass<13>[Q]   , V * <Scope>(Q <Scope>(F:entity) )  )
                                   wh-all-entries ( / np<12>[F]   , / qclass<13>[Q]             , V * <Scope>(Q <Scope>(F:entity context) ) ) }

   family Wh-pp- (Wh)              { wh-comp-entries ( / pp<12>[F]  ,                             , F:modifier * )  }
   
   family Wh-sent- (Wh)            { finite-entry ( / s<12>[F]      ,                             , F:event *)    }
  
   
   family Wh-adj- (Wh)             { wh-comp-entries ( / adj<12>[F] ,                             , F:quality * ) }
   family Wh-adj-qclass- (Wh)      { wh-comp-entries ( / adj<12>[F] , / qclass<12>[F]             , V * <Scope>(F:quality)  ) }
   family Wh-adj-degree- (Wh)      { wh-comp-entries ( / adj<12>[F] , / adj<12>[F]                , V * <Scope>(F:quality)  ) }
  
   
   # This is for handling the questioning of modifiers (i.e. optional adjuncts, like location, manner, etc)
   # There are two entries, the first is for scoping on the main (top level) event (where am is sitting), 
   # and the second is for embedded events (where did I want to sit)
   # Attachment of these modifiers is controlled by restricting the mclass of the scoped over (i.e. the 'questioned' event)
   # This is handled lexically, i.e. 'where' specifies that the sentence must unify with s-location
   # (note this fact explains the messiness of the 2nd entry, id 10, the typical sentence id must be associated
   #  with the embedded, scoped over, sentence)
   	   
   family Wh-sent-modifier- (Wh) {finite-entry( , , V *  <Scope>(E:event) ) 
                                entry: s<13>[E s-int]   / (s<~10>[F] $1 )
								                        / ( s<13>[E VFORM:VFORM FIN:FIN POL:POL] +subj() / (s<10>[F] $1 )  ) 
	                                                    /^ subj(NUM:NUM PERS:PERS)
						                                /  finit()
                    		 : EVENT( INT() SUBJECT() WH-ITEM(V *  <Scope>(F:event)) );  }





  ####################### 'Extracted' Constituents #######################

   
  def extr-subj(rslt, syn, sem) { 
  
     entry: rslt    / ( s(fin) \ np[F 3rd s-sg] ) syn   
		  : F( sem ^ <Scope>(E <Subject>(F) ) ) ; 
  }

  def extr-comp(rslt, item, syn, sem) { 
  
     entry: rslt  / ( s(fin NUM:NUM PERS:PERS FIN:FIN POL:POL) +subj()  item ) /^ subj(NUM:NUM PERS:PERS)  syn                   
	      :  F( sem ^ <Scope>(E SUBJECT() ) ) ; 
   }

  def extr-both (rslt, item, syn, sem)  {

	  extr-subj(rslt, syn, sem) 
	  extr-comp(rslt, item, syn, sem)
     
  } 


   # The indices are chosen based on underlying POS (e.g. 15 for n/np, 25 for pp)
   # This is because we need to lexically select features (i.e. via macros)
   # Also, the Semantic Index is always F to allow a systematic def (see above) and 
   # also to handle subject 'extraction' properly (all set to F)   

   # QUESTION: FOR EACH FAMILY, how much do we want the 'extracted' item to inherit.
   #   e.g. should an extracted direct object be accusitive...no.
   

   # What you picked up
   family Extr-np- (Wh)              { extr-both (np<15>[F ],  / np<16>[F] ,                      , F:entity *                      ) }
   
   # which (ball) you picked up
   family Extr-np-spec- (Wh)         { extr-both (np<15>[F ], / np<16>[F] , / n<16>[F s-sg]      ,  F:entity <Restr>(V *)              ) 
                                    extr-both (np<15>[F ], / np<16>[F] ,                      ,  F:entity context ^ <Restr>(V *)  ) }   
   # how many (balls) you picked up								   								   
   family Extr-np-quant-count- (Wh)  { extr-both (np<15>[F ], / np<16>[F] , / n<16>[F s-pl]      ,  F:entity <Restr>(V *)                 )
                                    extr-both (np<15>[F ], / np<16>[F] ,                      ,  F:entity context ^ <Restr>(V *)     ) } 

	   
   # how much (coffee) ...
   family Extr-np-quant-mass- (Wh)  { extr-both  (np<15>[F ], / np<16>[F] , / n<16>[F s-mass]    ,  F:entity ^ <Restr>(V *)                 )
                                    extr-both (np<15>[F ], / np<16>[F] ,                      ,  F:entity context ^ <Restr>(V *)     ) } 


   # what color/shape/size (ball) you picked up
   family Extr-np-qclass- (Wh)       { extr-both (np<15>[F ], / np<16>[F] , / n<16>[F]/ qclass<13>[Q]  , F:entity ^ <Restr>(V * <Scope>(Q) )               ) 
                                    extr-both (np<15>[F ], / np<16>[F] , / qclass<13>[Q]            , F:entity context ^ <Restr>(V * <Scope>(Q) )     ) }

   # where you put it
   family Extr-pp- (Wh)              { extr-comp (pp<25>[F] ,  / pp<26>[F] ,                    , F:modifier *              )}

  
   # what he says,  what you are doing
   family Extr-sent- (Wh)            { extr-comp (s<11>[F], / s_ma() ,                          , F:event *      )}  # MARK ME!!!
  
   # how did you make it (big, small, etc) 
   family Extr-adj- (Wh)             { extr-comp (adj<25>[F],  / adj<25>[F] ,                   , F:quality *    )}
   
   # what size did you make it
   family Extr-adj-qclass- (Wh)      { extr-comp (adj<25>[F],  / adj<25>[F] , / qclass<13>[Q]   , F:modifer <Restr>(V * <Scope>(Q) )    )}
   
   # how big did you make it
   family Extr-adj-degree- (Wh)      { extr-comp (adj<25>[F],  / adj<25>[F] , / adj<25>[F]      , F:modifer <Restr>(V *)        )}
  
  
  
  
  # When there is no missing arg.
  
  # 1st subj then M-Class appropriate main s (this set lexically). Results in M-TYPE appropriate pp.
  # 2nd  subj, then s missing wanting an M-CLASS appropriate s arg, then the s arg
  
  # !!! May 6: Must sort out proper arrangement of the immediate scope and the 'context' scope.
  #  Also unify this with above. <Restr> etc. 
  # !!!
  
  family Extr-pp-sent-modifier- (Wh)    { entry: pp<25>[F] /^  ( s(fin FIN:FIN POL:POL) +subj() ) /^ subj(NUM:NUM PERS:PERS)                             
                                         :  F( * ^ <Scope>(E SUBJECT() ) )  ;
  
						               entry: pp<25>[F]  / (s<~10>[E] $1 )
 							                         / ( s_ma(fin NUM:NUM PERS:PERS) +subj() / (s<10>[E]$1 )  ) 
	                                                 /^ subj(NUM:NUM PERS:PERS)
						                 :  F( * <Scope>(E <Scope>(G SUBJECT() ) ) );  
 }

  family Extr-adv-sent-modifier- (Wh)    { entry: adv<25>[F] /^  ( s(fin FIN:FIN POL:POL) +subj() ) /^ subj(NUM:NUM PERS:PERS)                             
                                         :  F( * ^ <Scope>(E SUBJECT() ) )  ;
  
						               entry: adv<25>[F]  / (s<~10>[E] $1 )
 							                         / ( s_ma(fin NUM:NUM PERS:PERS) +subj() / (s<10>[E]$1 )  ) 
	                                                 /^ subj(NUM:NUM PERS:PERS)
						                 :  F( * <Scope>(E <Scope>(G SUBJECT() ) ) );  
}
	   
#######################
## DICTIONARY FORMS  ##
#######################

  # Basic nouns, regular and irr

  def  wh-word (form, class, props) { _wh-word(form, form, class, props) } 
  def _wh-word (prd, form, class, props) {
    word form.-wh-word.class: props(class, pred=prd) { form ; }
  }

  def  wh-word+feat (form, class, props, args )  { _wh-word+feat(form, form, class, props, args )  } 
  def _wh-word+feat (prd, form, class, props, args )  {
    word form.-wh-word.class.props: props(class, pred=prd)  { form: args ; }
  }

  def  extr (form, class, props, args )  { _extr(form, form, class, props, args )  } 
  def _extr (prd, form, class, props, args )  {
    word form.-wh-comp.class.props: props(class, pred=prd)  { form: args ; }
  }



  def  wh-s-mod (form, class, mclass) { _wh-s-mod(form, form, class, mclass) } 
  def _wh-s-mod (prd, form, class, mclass) {
    word form.-wh-s-mod.class: Wh-sent-modifier(class, pred=prd) { form: mclass ; }
  }


  def  quality-class (form) { _quality-class(form, form) } 
  def _quality-class (prd, form) {
    word form.-quality-class-.class: Quality-class(quality, pred=prd) { form; }
  }



#### OLD STUFF

# This was before I realized that in order to get a single graph, must have proper
# semantic type at top
#
   # This is the Event which the SWh word is 'based on', i.e. either 'extracts' from or scopes over (or provides context for scoping over)
   #
#   def ES() { <Event>(E SUBJECT() ) }


   # What you picked up
#   family SWh-np(Wh)              { swh-entry (np(sg),  / np() ,                      , T:entity( * ES() )                      ) }
   
   # which (ball) you picked up
#   family SWh-np-spec(Wh)         { swh-entry (np(sg), / np() , / n(s-sg)            , V( * <Scope>(T:entity) ES() )            ) 
#                                    swh-entry (np(sg), / np() ,                      , V( * <Scope>(T:entity context) ES() )    ) }   

   # how many (balls) you picked up								   								   
#   family SWh-np-quant-count(Wh)  { swh-entry (np(sg), / np() , / n(s-pl)            , T:entity( <Restr>(V *) ES() )            )
#                                    swh-entry (np(sg), / np() ,                      , T:entity(context <Restr>(V *) ES() )     ) }
 
#     family SWh-np-quant-count(Wh)  { swh-entry (np(sg), / np() , / n(s-pl)            , V( * <Scope>(T:entity) ES() )            )
#                                    swh-entry (np(sg), / np() ,                      , V( * <Scope>(T:entity context) ES())     ) }

	   
   # how much (coffee) ...
#   family SWh-np-quant-mass(Wh)   { swh-entry (np(sg), / np() , / n(s-mass)          ,  V( * <Scope>(T:entity) ES() )           ) 
#                                   swh-entry  (np(sg) , / np() ,                      , V( * <Scope>(T:entity context) ES() )   ) }
   
   # what color/shape/size (ball) you picked up
#   family SWh-np-qclass(Wh)       { swh-entry (np(sg), / np() , / n() / qclass<13>[Q]  , V( * <Scope>(Q <Scope>(T:entity) )        ES() )   ) 
#                                    swh-entry (np(sg), / np() , / qclass<13>[Q]        , V( * <Scope>(Q <Scope>(T:entity context)) ES() )   ) }

   # where you put it
#   family SWh-pp(Wh)              { swh-entry (pp() ,  / pp() ,                        , M( * ES() )         )}

  
   # what he says,  what you are doing
#   family SWh-sent(Wh)            { swh-entry (s_ma(), / s_ma() ,                      , G:event( * ES() )    )}  # MARK ME!!!
  
   # how did you make it (big, small, etc) 
#   family SWh-adj(Wh)             { swh-entry (adj(),  / adj() ,                      , M:quality( * ES() )   )}
   
   # what size did you make it
#   family SWh-adj-qclass(Wh)      { swh-entry (adj(),  / adj() , / qclass<13>[Q]      , V( * <Scope>(Q) ES() )  )}
   
   # how big did you make it
#   family SWh-adj-degree(Wh)      { swh-entry (adj(),  / adj() , / adj()              , V( * <Scope>(M:quality) ES() )   )}
  
  
	     	   
   #family SWh-sent-modifier(Wh) {finite-entry( , , V *  <Scope>(E:event) ) 
   #                             entry: s<13>[E s-int]   / (s<~10>[F] $1 )
#								                        / ( s<13>[E VFORM:VFORM FIN:FIN POL:POL] +subj() / (s<10>[F]$1 )  ) 
#	                                                    /^ subj(NUM:NUM PERS:PERS)
#						                                /  finit()
 #                   		 : EVENT( INT() SUBJECT() WH-ITEM(V *  <Scope>(F:event)) );  }



# This was before I tried to unify relative-clauses and 'subords', i.e. I know where you went #

#  def inverted-entry(item, syn, sem)  {
#
#      entry: from-s(s-subord)  / ( s(VFORM:VFORM FIN:FIN POL:POL) +subj()  item ) 
#	                                 /^ subj(NUM:NUM PERS:PERS)
#		   					         syn                   
#			 : EVENT( SUBJECT() WH-ITEM(sem) ); 
#  } 

  