# This file contains all of the stuff necessary for 
# standard verbs, the copular and mood rules

#################################
# VERB ARGUMENTS: SLOTS & ROLES # 
#################################

# These are the syntactic slots and corresponding semantic roles
# used for verbal arguments(compliments)

# Semantic Role cats are, like all semantic cats, in CAPS.

# The general format for syn-cat names is type_slot# (args) for the bare compliment itself.
# For the comp plus its slash, +type_slot# (args)

# The slots are numbered based on their left to right position after the verb itself, so
#	    	_SUBJ_	 VERB		_1_			_2_				_3_
                        
# 1)		  I      slept  
# 2)		  I      hit		the ball
# 3)		  I      gave		him			the ball
# 4)		  I		 gave		it			to  him
# 5)		  I		 picked		it			up
# 6)		  I		 put		it			on the table
# 7)          I		 want								    to run
# 8)	      I	     want		him							to run
		 
# As you can see, the slot position is independent of the category (or kind) of the compliment.
# So in 3, 4, 5, 6 we have a NP, an OBLIQUE, a PARTICLE and a PP all in slot 3. Thus,
# the variable name for a given syntactic argument is a combination of category and slot position:
# Verb(vp) & Sentence comps are an exception, they are always in slot 3.. this was just a pragmatic
# decision to avoid doubling all of the cats.

  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  # IMPORTANT:  
  #         Although there are no semantic constraints for entites (animacy, etc)
  #         some of these verb-roles are restricting for modifiers (where-to and location, e.g.)
  #         Changes to the modifier section of ontological hierarchy will need be reflected here
  #
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  



  # SUBJECT SLOT ##
  
    def ACTOR(args)     { <Actor>(S:entity args) }
  
  ## COMP SLOT 1 ##
  
    def np_1(args)           { np<2>[X acc args] }            def +np_1(args)          { / np_1(args) }
	def +np_1-subj(args)     { \ np<~2>[X nom] }  # this is for 'object-controlled vp comps' like 'I want him to get it'

    def obl_1(frm, args)     { obl<2>[X acc MARK=frm args] }  def +obl_1(frm, args)    { / obl_1(frm, args) }
    def adj_1(args)          { adj<2>[X args] }               def +adj_1(args)         { / adj_1(args) }
    def pp_1(args)           { pp<2>[X args] }                def +pp_1(args)          { / pp_1(args) } 
    def s_1(feats)           { s<2>[X feats] }                def +s_1(feats, args)    { / ( s_1(feats) args ) }
	   
    def PATIENT(args)        { <Patient>(X:entity args) }

    def INSTRUMENT(args)     { <Modifier>(M:m-instrumental ^ with <Arg>(X:entity args) ) }  # used in family for 'use'  you can use the coffee maker to make coffee'

  ## COMP SLOT 2 ##
   
	def np_2(args)           { np<3>[Y acc args] }            def +np_2(args)          { / np_2(args) }
	def +np_2-subj(args)     { \ np<~3>[Y nom] }  
	def obl_2(frm, args)     { obl<3>[Y acc MARK=frm args] }  def +obl_2(frm, args)    { / obl_2(frm, args) }
    def adj_2(args)          { adj<3>[Y args] }               def +adj_2(args)         { / adj_2(args) }
    def pp_2(args)           { pp<3>[Y args] }                def +pp_2(args)          { / pp_2(args) }
    def prt_2(args)          { prt<3>[Y args] }               def +prt_2(args)         { / prt_2(args) }

    def RECIPIENT(args)      { <Recipient>(Y:entity args) }
	def PARTICLE(args)       { <Particle>(Y args) }
	
	# These are all given dependecy <Result>, but have different semantic resrictions on their arg
  	def R-LOC(args)            { <Result>(Y:m-location args) }
	def R-WHERETO(args)        { <Result>(Y:m-dynamic args) }
	def R-QUALITY(args)        { <Result>(Y:quality args) }
	
	def R-MODIFIER(args)       { <Result>(Y:modifier args) }
	def R-ENTITY(args)         { <Result>(Y:entity args) }

  ## COMP SLOT 3 ## 

   def s_3(feats)           { s<4>[Z feats] }      def +s_3(feats, args)    { / ( s_3(feats) args ) }
   def ECOMP(args)          { <Event>(Z:event args) }


##############
# MOOD RULES #
##############

  # The mood of a clause is projected as early as possible. i.e. we don't wait for the verb.
  # Instead, the first 'core' element of the clause does this
  #   Indicative: a free standing, clause initial NP
  #   Imperative: a base form verb wanting a subject (see below for dropped subjects)
  #   Interrogative: auxillaries in Y/N & Wh-words in Wh cases (see wh-words.ccg , verb-finite.ccg and copular section below for more)  
 
  rule {no typeraise;   # b/c indicative rule handles the building of standard indicative clauses, no need for type-raise
                        # this removes the unncessary readings
		no sub;}        # THIS ADDED TO KILL STUPID COLLAPSED ARG READINGS 'put this on the table' with this & table co-indexed.


  # The 'floating' subject np in the early stages of the (incremental) parsing of indicatives and interrogatives
  # is integrated into the utterance semantics by assigning it to the dependency slot <Subject>
  # Althoug it may seem it, this is not entirely a hack.
  # At these early stages, this np may not have a Thematic (Ideational) role (i.e actor, patient, etc) assigned to it by
  # its verb, but it has a very important interpersonal role. It is the thing which is argued with
 
  # It's big.                             
  # No, it's small, isn't it. 
  # It shouldn't be, should it.
  # etc.
  
  # i.e. it plays the role of Subject in the Mood structure of Systemic Functional Linguistics
  
  def SUBJECT(args)         { <Subject>(S:entity args) }

  # This creates indicative clauses out of any old NP, either as the subject (in Systemic Functional Grammar sense) or as a Fronted-object
  # as in 'this one I dont like'

 rule { typechange: subj() $1                           =>  from-s(s-ind ) /  ( s(VFORM:fin-clause s-minor) +subj() )  $1                             : EVENT( IND() SUBJECT() )             ; } 
 rule { typechange: np<12>[F acc nf-real] $1            =>  from-s(s-ind)  /  ( s(VFORM:fin-clause s-minor) +subj(nf-real) / np<12>[F]) /^ subj()  $1 : EVENT( IND() SUBJECT() <Fronted>(F) ); }

 # These rules turn verbs wanting subjects into 1) imperatives and 
 #                                               2) verbs with contextually 'alighted' (i.e. dropped) subjects
 # Despite standard claims that English is not a pro-drop language, it is still a widely attested phenomena 
 # in at least two specific 'genres'  1) single sequential episodes in narratives (see e.g. Chafe 1994)
 # and much more importantly for Moloko 2) in highly interactional discourses where the talk is directed  
 # at physical/practical tasks/actions involving the situation, i.e what is 'at hand' (see, e.g., McCarthy's work on CANCODE corpus)
 
 
 # JULY 24  ADDED restriction that nf-real to block presentational, clefts, etc from getting contextualized missing 'dummy' subject readings
 # AUG  5   ADDED vf-to-imp value, this allows verbs to  lexically select whether or not they receive an imp 
 #                (see verb and verb-no-imp dictionary macros below)         
 
  def imp-rule(args){ 
       rule { typechange: s(vf-to-imp) +subj(nf-real) args          => from-s(fin-full s-imp) args       : EVENT( IMP() SUBJECT(addressee) ); } 
       rule { typechange: s(fin) +subj(nf-real) args                => from-s(fin-ell s-ind-ell) args   : EVENT( IND() SUBJECT(context) ); }  
  }						 
 def imp-rule-set(args){
       rule { typechange: s(vf-base) +subj() { args }      => from-s(fin s-imp) { args }   : EVENT( IMP() SUBJECT(addressee) ); } 
       rule { typechange: s(fin) +subj() { args }          => from-s(fin s-ind-ell) { args }   : EVENT( IND() SUBJECT(context) ); } 
  }


##############
## FAMILIES ##
##############

## Family Building Macros ##
 
  def vcat(args, sem)             {  s(s-minor) +subj(nf-real)   args   : EVENT(* ACTOR() sem)  }
  def vcat-set(args, sem)         {  s(s-minor) +subj() { args } : EVENT(* ACTOR() sem)  } # for those with sets of args
   
## The Families ##

  family iv(V)               { entry: vcat(,)                                              ; }    
						          imp-rule( )
  family tv(V)               { entry: vcat(+np_1()              , PATIENT() )              ; }  
						          imp-rule( +np_1() )
  
  # Oblique objects
  #
  def v+obl(word){
                    family "v+".word."-np"(V)          { entry: vcat(+obl_1(word,)          , PATIENT() )              ; }
                	                                        imp-rule(+obl_1(word,) )
  }
  v+obl(of)
  v+obl(with)
  v+obl(for)
  v+obl(to)
  v+obl(from)
	  
								  
  family v+np+prt(V)         { entry: vcat(+prt_2() +np_1() , PATIENT() PARTICLE() )   ;
                               entry: vcat(+np_1() +prt_2() , PATIENT() PARTICLE() )   ;     }
  						          imp-rule(+prt_2() +np_1() )
 						          imp-rule(+np_1() +prt_2()  )

  family v+pp-whereto(V)  { entry: vcat(+pp_2() , R-WHERETO()  )   ;  }
  family v+pp-loc(V)      { entry: vcat(+pp_2() , R-LOC()  )   ;  }
  family v+pp(V)          { entry: vcat(+pp_2() , R-MODIFIER()   )   ; }
              		             imp-rule(+pp_2() )
 
  family v+adj(V)         { entry: vcat(+adj_2() , R-QUALITY()   )   ; }
               		             imp-rule(+adj_2() )
  
#######
#Mar 3:  So, if we don't have setarg & want /np/pp & /pp/np, we get stupid double-bound readings for put on# (>S operator does it)
#		BUT if we DO have setarg, then fronting won't parse b/c it's looking for (s\np/np)
#		
#	PROBLEMS HERE:	HOW DO WE FIGURE OUT WHAT CAN BE FRONTED/WH-QUESTIONED, HOW DOES THIS RELATE TO ORDER, ETC....
#######

### IMP-RULES DON'T WORK WITH SET-ARG (Jason confirmed this)


  family v+np+pp-whereto(V)  { entry: vcat(+pp_2() +np_1()      , PATIENT() R-WHERETO()  )   ; 
                               entry: vcat(/< np_1() /^ pp_2()  , PATIENT() R-WHERETO()  )   ;  }
  # AUG 18
  # the second entry allows 'extraction' of the patient np. We should eventually sort out a way of 'blocking' this from 
  # parsing via ind and imp rules (perhaps another layer of mood)
  #
  # THIS NEEDS TO BE GENERALIZED THROUGHOUT ARG-STRUCTURES (verb families)

							   
  family v+np+pp-loc(V)      { entry: vcat(+pp_2() +np_1()      , PATIENT() R-LOC()      )   ; 
                               entry: vcat(+np_1() +pp_2()      , PATIENT() R-LOC()      )   ;  }
 						          imp-rule(+pp_2() +np_1() )
                                  imp-rule(+np_1() +pp_2() )

 
  family v+np+adj(V)         { entry: vcat(+adj_2() +np_1()  , PATIENT() R-QUALITY()   )   ; 
                               entry: vcat(+np_1()  +adj_2() , PATIENT() R-QUALITY()   )   ; }
             		             imp-rule(+adj_2() +np_1() )
                                 imp-rule(+np_1() +adj_2() )

  family dtv(V)              { entry: vcat(+np_1() +np_2()          , PATIENT() RECIPIENT() )  ; }
  family dtv-for(V)          { entry: vcat(+np_1() +obl_2(for,)     , PATIENT() RECIPIENT() )  ; 
                               entry: vcat(+obl_1(for,) +np_2()     , PATIENT() RECIPIENT() )  ; }
  family dtv-to(V)           { entry: vcat(+np_1() +obl_2(to,)      , PATIENT() RECIPIENT() )  ; 
                               entry: vcat(+obl_2(to,) +np_1()      , PATIENT() RECIPIENT() )  ; }
						          imp-rule(+np_2() +np_1() )
        					      imp-rule(+np_1() +obl_2(for,) )
  						          imp-rule(+obl_2(for,) +np_1() )
						          imp-rule(+np_1() +obl_2(to,) )
  						          imp-rule(+obl_2(to,) +np_1() )
  						     
  family v+sent(V)            { entry: vcat(+s_3(fin,)                      , ECOMP() )        ; }
  family v+sent-ind(V)        { entry: vcat(+s_3(fin s-ind,)                 , ECOMP() )        ; }
					          imp-rule(+s_3(,) )
 
  family v+deictic-event(V)   { entry: vcat(+s_3(fin-deictic,)  , ECOMP() )    ; }  
 						          imp-rule(+s_3(fin-deictic,)  )

  family v+verb-ing(V)        { entry: vcat(+s_3(ing,     +subj() )      , ECOMP() )        ; } 
  						          imp-rule(+s_3(ing,     +subj() ) )
  family v+verb-inf(V)        { entry: vcat(+s_3(inf,     +subj() )      , ECOMP() )        ; } 
 						          imp-rule(+s_3(inf,     +subj() ) )

  family v+np+sent(V)         { entry: vcat(+s_3(,) +np_1()                         , PATIENT() ECOMP() )    ; }    
								  imp-rule(+s_3(,) +np_1() )
  family v+np+verb-inf(V)     { entry: vcat(+s_3(inf, +np_1-subj() ) +np_1()        , PATIENT() ECOMP() )    ; }
  
  family v+np+verb-base(V)    { entry: vcat(+s_3(vf-base, +np_1-subj() ) +np_1()    , PATIENT() ECOMP() )    ; }    
						          imp-rule(+s_3(vf-base, +np_1-subj() ) +np_1() )
  family v+np+verb-ing(V)     { entry: vcat(+s_3(ing, +np_1-subj() ) +np_1()        , PATIENT() ECOMP() )    ; }    
       					          imp-rule(+s_3(ing, +np_1-subj() ) +np_1() )
   
  
  ## More specialized verb families  ##

  # don't be silly
  family imp-do(V)               { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity addressee) ) ;}
  family imp-lets(V)             { entry: from-s(s-imp) / (s(vf-base) +subj()):  EVENT( IMP() <Subject>(S:entity speaker+addressee) ) ;}

  # I made it from plastic, it is made of plastic, etc.
  def v+np+obl-result(word){
                 family "v+np+".word."-np-result"(V)         { entry: vcat(+obl_2(word,) +np_1()  , PATIENT() R-ENTITY()   )   ; 
                                                              entry: vcat(+np_1()  +obl_2(word,) , PATIENT() R-ENTITY()   )   ; }
             	 imp-rule(+obl_2(word,) +np_1() )
                 imp-rule(+np_1() +obl_2(word,) )
  }
  v+np+obl-result(of)
  v+np+obl-result(from)
  v+np+obl-result(out_of)  
	  
  # you use this to pick up balls
  family v+instrumental-np+verb-inf(V)  { entry: vcat(+s_3(inf, +subj() ) +np_1()   , PATIENT() ECOMP( INSTRUMENT() ) )    ; }    
    					          imp-rule(+s_3(inf, +np_1-subj() ) +np_1() )
  
  # thank you for helping me  
  family v+Rec-np+for-verb-ing(V) { entry: vcat(+s_3(for-ing, +np_2-subj() ) +np_2()    , RECIPIENT() ECOMP() )    ; }    
						         # imp-rule(+s_3(for-ing, +np_2-subj() ) +np_2() )
 
  family Thanks(V)  { entry: s(s-ind) +s_3(for-ing, \ np_2(nom) )  : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ECOMP() ) ;
                      entry: s(s-ind)                              : EVENT (* IND() <Actor>(A:entity speaker <Num>(sg) ) RECIPIENT(addressee) ) ;  }

  ##################################
  ## VP & Sentential Coordination ##
  ##################################
    
  # First entry handles coordinated vps, i.e. subject controlled vp chains.
  # Every syn feature except for modifier class must be identical. If this weren't allowed to differ, 
  # couldnt handle I walked in and picked it up, cuz walk and pick have dif m-classes. 
  
  # Note: A nice consistent handling of these clausal chains seem to require the imp-rules above
  #       By converting s[base]\!np into imps, this entry allows the chaining of multiple vps
  #       to be 'converted' into an imp only once, thus having a single mood scoping over the
  #       whole chain. With base-level (lexical) s/args : E( <Mood>imp ... args), this wouldn't be possible
  
  # Question: what should the m-class of the result be?
  
  # Second entry handles general sentence coordination. The conjuncts must be mooded-clauses, 
  # the result is of general s-major mood and 'fin' verb form (if you don't give it a verb form
  # then some rules will grap a hold of it and make silly readings (e.g. see rules around imperatives)
  #   NOTE: May 15 restricted these to being ind or int, not dropped subject ind (s-ind-ell) or imp.
  #         This is because we want those to be handled using the vp-chains. This reduces number of parses
  #         and looks more sexy, like Givon's(1995)   S[subj vp vp vp vp vp ...] treatment
		    
  family Coord-s-  { entry:   (s<10>[R VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=yes] +subj() ) 
                            / (s<11>[N VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS] +subj() ) 
							\ (s<12>[F VFORM:VFORM POL:POL FIN:FIN NUM:NUM PERS:PERS COM=no] +subj() ) : COORD(*) ; 
                     entry:    s<10>[R s-ind fin COM=yes] /^ s<11>[N  fin s-ind ] \* s<12>[F fin s-ind COM=no]  : COORD(*) ;  
					 entry:    s<10>[R s-int fin COM=yes] /^ s<11>[N  fin s-int ] \* s<12>[F fin s-int COM=no]  : COORD(*) ;  }
  
#######################
## DICTIONARY FORMS  ##
#######################


  # This handles verbs which are perfectly regular ex. jump -> jumps, jumping, jumped (past), jumped (past participle)
  #
  def verb-reg(stem, mod, class, props)       {  verb(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg(prd, stem, mod, class, props) { _verb(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }

  # This handles verbs whose 3rd person present form is regular, but whose past and past particle aren't
  #
  def verb(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }

  # This handles irregular verbs, i.e. each form must be fully specified
  #
  def verb-basic(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.-verb-.class.mod:props(class, pred=prd) {
	  stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
      3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
      stem:      mod fin-full pres s-pos do         s-pl  ;
      pasttense: mod fin-full past s-pos do               ;
	  pastpart:  mod pp                                   ;
	  ving:      mod ing                                  ;
	  stem:      mod vf-base                              ;
   	  stem:      mod vf-to-imp                            ;   # This entry gets turned into an imp via rule (see above)

    }
  }

  
 
  # This set is identical but DOES NOT have a to-imp reading
  # Use these if you don't want this verb to receive an imperative reading.
  #
  #
  def verb-reg-no-imp(stem, mod, class, props)       {  verb-no-imp(stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def _verb-reg-no-imp(prd, stem, mod, class, props) { _verb-no-imp(prd, stem, stem."ing", stem."ed", stem."ed", mod, class, props) }
  def verb-no-imp(stem, ving, pasttense, pastpart, mod, class, props)       {  verb-basic-no-imp(stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def _verb-no-imp(prd, stem, ving, pasttense, pastpart, mod, class, props) { _verb-basic-no-imp(prd, stem, pluralize(stem), ving, pasttense, pastpart, mod, class, props) }
  def verb-basic-no-imp(stem, 3sing, ving, pasttense, pastpart, mod, class, props) {_verb-basic-no-imp(stem, stem, 3sing, ving, pasttense, pastpart, mod, class, props) }
  def _verb-basic-no-imp(prd, stem, 3sing, ving, pasttense, pastpart, mod, class, props) {
    word stem.prd.-verb-.class.mod:props(class, pred=prd) {
	  stem:      mod fin-full pres s-pos do non-3rd s-sg  ;  	
      3sing:     mod fin-full pres s-pos do 3rd     s-sg  ;
      stem:      mod fin-full pres s-pos do         s-pl  ;
      pasttense: mod fin-full past s-pos do               ;
	  pastpart:  mod pp                                   ;
	  ving:      mod ing                                  ;
	  stem:      mod vf-base                              ;
    }
  }


 def adjectival-verb(stem, mod, class, props) {_adjectival-verb(stem, stem, mod, class, props) }
 def _adjectival-verb(prd, stem, mod, class, props) {
     word stem.-be-adj-to: props (class, pred=prd)
     {stem: vf-be mod;}
 }


## OLD

 
  
  # The 3rd rule turns ing-form verbs into adverbials displaying 'disposition' 
  #  e.x I walked in hoping he would be there
  #      I didn't ask him assuming he didn't know
 
#  HE CAME IN LOOKING FOR A BALL
#  I WENT TO THE LIBRARY EXPCECTING TO FIND A BOOK
#						   rule { typechange: s_ma(ing) +subj() args           => s(m-class-4) +subj() args \* ( s(MCLASS:s-comment) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 
#						  rule { typechange: s_ma(ing) +subj()  { args }      => s(m-class-4) +subj() { args } \* ( s(MCLASS:s-comment) +subj() ) 
#                                                                                 : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 



#     				   rule { typechange:  s(fin MCLASS:s-comment) +subj()        => from-s() +subj() /( s_ma(ing) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-disposition blah E-ARG() ) ); } 

# Must block for some verbs by choosing to allow this, or not... prob same above I kept running should never have 'disposition' reading
#
#     				   rule { typechange:  s(fin MCLASS:s-comment) +subj()        => from-s() +subj() /( s_ma(inf) +subj() ) 
#						                                                          : EVENT( <Modifier>(M:m-purpose blah E-ARG() ) ); } 


 # is there ...
 # what is there 

# def pres-entry(syn, sem)      {  
#                                 entry: s(s-int) syn / subj() / np[D CASE = dummy-there]      : EVENT(* INT() ^ <Subject>(D) <Cop-Restr>(S) ^ sem)  ;
#								 entry: s(s-minor) \! np[D:dummy CASE = dummy-there] syn / subj() : EVENT(* <Cop-Restr>(S) ^ sem)  ;  }
#         					   #  entry: s(s-minor) \! np[D CASE = dummy-there] / subj() syn      : EVENT(* <Cop-Restr>(S) ^ sem)  ;  }
							
# family Presentational(V)     {  							   
#      							pres-entry( , ) 
#							pres-entry( / pp_1(CC-TYPE:post-n), <Cop-Scope>(X:m-location) ) 
#       						    # Inverted locational  'On the table is a ball'
						        #
#							    entry: s(s-ind) / subj() \ pp_1(CC-TYPE:post-n)  : EVENT(* IND() <Cop-Restr>(S:entity) ^ <Cop-Scope>(X:m-location) )  ;
#	     					 }


# def pres-entry(syn, sem)      {  
#                                 entry: s(s-int) syn / subj() / np[D dummy-there]      : EVENT(* INT() ^ <Subject>(D) <Presented>(S) ^ sem)  ;
#								 entry: s(s-minor) \! np[D dummy-there] syn / subj() : EVENT(* <Presented>(S) ^ sem)  ;  }

