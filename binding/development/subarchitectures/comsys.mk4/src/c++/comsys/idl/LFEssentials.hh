// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __LFEssentials_hh__
#define __LFEssentials_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems

  _CORBA_MODULE_BEG

    _CORBA_MODULE repr

    _CORBA_MODULE_BEG

      _CORBA_MODULE lf

      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen

        _CORBA_MODULE_BEG

          _CORBA_MODULE LFEssentials

          _CORBA_MODULE_BEG

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Id;

            typedef char* Id;
            typedef ::CORBA::String_var Id_var;
            typedef ::CORBA::String_out Id_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_nominalVariable;

            typedef char* nominalVariable;
            typedef ::CORBA::String_var nominalVariable_var;
            typedef ::CORBA::String_out nominalVariable_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ontologicalSort;

            typedef char* ontologicalSort;
            typedef ::CORBA::String_var ontologicalSort_var;
            typedef ::CORBA::String_out ontologicalSort_out;

            enum ConnectiveType { NONE, DISJUNCTIVE, CONJUNCTIVE, XDISJUNCTIVE /*, __max_ConnectiveType=0xffffffff */ };
            typedef ConnectiveType& ConnectiveType_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ConnectiveType;

            struct Proposition;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Propositions;

            class Propositions_var;

            class Propositions : public _CORBA_Unbounded_Sequence_Forward< Proposition >  {
            public:
              typedef Propositions_var _var_type;

              inline Propositions() {}
              Propositions(const Propositions& _s);
              Propositions& operator=(const Propositions& _s);

              inline Propositions(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence_Forward< Proposition > (_max) {}
              inline Propositions(_CORBA_ULong _max, _CORBA_ULong _len, Proposition* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence_Forward< Proposition > (_max, _len, _val, _rel) {}

            

              virtual ~Propositions();

              Proposition& operator[] (_CORBA_ULong _index);
              const Proposition& operator[] (_CORBA_ULong _index) const;
              static Proposition* allocbuf(_CORBA_ULong _nelems);
              static void freebuf(Proposition* _b);

              void operator>>= (cdrStream &_s) const;
              void operator<<= (cdrStream &_s);

            protected:
              void NP_copybuffer(_CORBA_ULong _newmax);
              void NP_freebuf();
            };

            class Propositions_out;

            class Propositions_var {
            public:
              inline Propositions_var() : _pd_seq(0) {}
              inline Propositions_var(Propositions* _s) : _pd_seq(_s) {}
              inline Propositions_var(const Propositions_var& _s) {
                if( _s._pd_seq )  _pd_seq = new Propositions(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~Propositions_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline Propositions_var& operator = (Propositions* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline Propositions_var& operator = (const Propositions_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new Propositions;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Proposition& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline Propositions* operator -> () { return _pd_seq; }
              inline const Propositions* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator Propositions& () const { return *_pd_seq; }
#else
              inline operator const Propositions& () const { return *_pd_seq; }
              inline operator Propositions& () { return *_pd_seq; }
#endif
                
              inline const Propositions& in() const { return *_pd_seq; }
              inline Propositions&       inout()    { return *_pd_seq; }
              inline Propositions*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline Propositions* _retn() { Propositions* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class Propositions_out;
              
            private:
              Propositions* _pd_seq;
            };

            class Propositions_out {
            public:
              inline Propositions_out(Propositions*& _s) : _data(_s) { _data = 0; }
              inline Propositions_out(Propositions_var& _s)
                : _data(_s._pd_seq) { _s = (Propositions*) 0; }
              inline Propositions_out(const Propositions_out& _s) : _data(_s._data) {}
              inline Propositions_out& operator = (const Propositions_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline Propositions_out& operator = (Propositions* _s) {
                _data = _s;
                return *this;
              }
              inline operator Propositions*&()  { return _data; }
              inline Propositions*& ptr()       { return _data; }
              inline Propositions* operator->() { return _data; }

              inline Proposition& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              Propositions*& _data;

            private:
              Propositions_out();
              Propositions_out& operator=(const Propositions_var&);
            };

            struct Proposition {
              typedef _CORBA_ConstrType_Variable_Var<Proposition> _var_type;

              
              ::CORBA::String_member prop;

              ConnectiveType connective;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Proposition::_var_type Proposition_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Proposition,Proposition_var > Proposition_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Proposition;

            struct Feature {
              typedef _CORBA_ConstrType_Variable_Var<Feature> _var_type;

              
              ::CORBA::String_member feat;

              ::CORBA::String_member value;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef Feature::_var_type Feature_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< Feature,Feature_var > Feature_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Feature;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Features;

            class Features_var;

            class Features : public _CORBA_Unbounded_Sequence< Feature >  {
            public:
              typedef Features_var _var_type;
              inline Features() {}
              inline Features(const Features& _s)
                : _CORBA_Unbounded_Sequence< Feature > (_s) {}

              inline Features(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< Feature > (_max) {}
              inline Features(_CORBA_ULong _max, _CORBA_ULong _len, Feature* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< Feature > (_max, _len, _val, _rel) {}

            

              inline Features& operator = (const Features& _s) {
                _CORBA_Unbounded_Sequence< Feature > ::operator=(_s);
                return *this;
              }
            };

            class Features_out;

            class Features_var {
            public:
              inline Features_var() : _pd_seq(0) {}
              inline Features_var(Features* _s) : _pd_seq(_s) {}
              inline Features_var(const Features_var& _s) {
                if( _s._pd_seq )  _pd_seq = new Features(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~Features_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline Features_var& operator = (Features* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline Features_var& operator = (const Features_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new Features;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline Feature& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline Features* operator -> () { return _pd_seq; }
              inline const Features* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator Features& () const { return *_pd_seq; }
#else
              inline operator const Features& () const { return *_pd_seq; }
              inline operator Features& () { return *_pd_seq; }
#endif
                
              inline const Features& in() const { return *_pd_seq; }
              inline Features&       inout()    { return *_pd_seq; }
              inline Features*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline Features* _retn() { Features* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class Features_out;
              
            private:
              Features* _pd_seq;
            };

            class Features_out {
            public:
              inline Features_out(Features*& _s) : _data(_s) { _data = 0; }
              inline Features_out(Features_var& _s)
                : _data(_s._pd_seq) { _s = (Features*) 0; }
              inline Features_out(const Features_out& _s) : _data(_s._data) {}
              inline Features_out& operator = (const Features_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline Features_out& operator = (Features* _s) {
                _data = _s;
                return *this;
              }
              inline operator Features*&()  { return _data; }
              inline Features*& ptr()       { return _data; }
              inline Features* operator->() { return _data; }

              inline Feature& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              Features*& _data;

            private:
              Features_out();
              Features_out& operator=(const Features_var&);
            };

            struct LFRelation {
              typedef _CORBA_ConstrType_Variable_Var<LFRelation> _var_type;

              
              ::CORBA::String_member head;

              ::CORBA::String_member mode;

              ::CORBA::String_member dep;

              ::CORBA::Boolean coIndexedDep;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef LFRelation::_var_type LFRelation_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< LFRelation,LFRelation_var > LFRelation_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFRelation;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Relations;

            class Relations_var;

            class Relations : public _CORBA_Unbounded_Sequence< LFRelation >  {
            public:
              typedef Relations_var _var_type;
              inline Relations() {}
              inline Relations(const Relations& _s)
                : _CORBA_Unbounded_Sequence< LFRelation > (_s) {}

              inline Relations(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< LFRelation > (_max) {}
              inline Relations(_CORBA_ULong _max, _CORBA_ULong _len, LFRelation* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< LFRelation > (_max, _len, _val, _rel) {}

            

              inline Relations& operator = (const Relations& _s) {
                _CORBA_Unbounded_Sequence< LFRelation > ::operator=(_s);
                return *this;
              }
            };

            class Relations_out;

            class Relations_var {
            public:
              inline Relations_var() : _pd_seq(0) {}
              inline Relations_var(Relations* _s) : _pd_seq(_s) {}
              inline Relations_var(const Relations_var& _s) {
                if( _s._pd_seq )  _pd_seq = new Relations(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~Relations_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline Relations_var& operator = (Relations* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline Relations_var& operator = (const Relations_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new Relations;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline LFRelation& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline Relations* operator -> () { return _pd_seq; }
              inline const Relations* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator Relations& () const { return *_pd_seq; }
#else
              inline operator const Relations& () const { return *_pd_seq; }
              inline operator Relations& () { return *_pd_seq; }
#endif
                
              inline const Relations& in() const { return *_pd_seq; }
              inline Relations&       inout()    { return *_pd_seq; }
              inline Relations*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline Relations* _retn() { Relations* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class Relations_out;
              
            private:
              Relations* _pd_seq;
            };

            class Relations_out {
            public:
              inline Relations_out(Relations*& _s) : _data(_s) { _data = 0; }
              inline Relations_out(Relations_var& _s)
                : _data(_s._pd_seq) { _s = (Relations*) 0; }
              inline Relations_out(const Relations_out& _s) : _data(_s._data) {}
              inline Relations_out& operator = (const Relations_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline Relations_out& operator = (Relations* _s) {
                _data = _s;
                return *this;
              }
              inline operator Relations*&()  { return _data; }
              inline Relations*& ptr()       { return _data; }
              inline Relations* operator->() { return _data; }

              inline LFRelation& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              Relations*& _data;

            private:
              Relations_out();
              Relations_out& operator=(const Relations_var&);
            };

            struct LFNominal {
              typedef _CORBA_ConstrType_Variable_Var<LFNominal> _var_type;

              
              ::CORBA::String_member nomVar;

              ::CORBA::String_member sort;

              Proposition prop;

              Features feats;

              Relations rels;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef LFNominal::_var_type LFNominal_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< LFNominal,LFNominal_var > LFNominal_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFNominal;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Nominals;

            class Nominals_var;

            class Nominals : public _CORBA_Unbounded_Sequence< LFNominal >  {
            public:
              typedef Nominals_var _var_type;
              inline Nominals() {}
              inline Nominals(const Nominals& _s)
                : _CORBA_Unbounded_Sequence< LFNominal > (_s) {}

              inline Nominals(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< LFNominal > (_max) {}
              inline Nominals(_CORBA_ULong _max, _CORBA_ULong _len, LFNominal* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< LFNominal > (_max, _len, _val, _rel) {}

            

              inline Nominals& operator = (const Nominals& _s) {
                _CORBA_Unbounded_Sequence< LFNominal > ::operator=(_s);
                return *this;
              }
            };

            class Nominals_out;

            class Nominals_var {
            public:
              inline Nominals_var() : _pd_seq(0) {}
              inline Nominals_var(Nominals* _s) : _pd_seq(_s) {}
              inline Nominals_var(const Nominals_var& _s) {
                if( _s._pd_seq )  _pd_seq = new Nominals(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~Nominals_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline Nominals_var& operator = (Nominals* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline Nominals_var& operator = (const Nominals_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new Nominals;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline LFNominal& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline Nominals* operator -> () { return _pd_seq; }
              inline const Nominals* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator Nominals& () const { return *_pd_seq; }
#else
              inline operator const Nominals& () const { return *_pd_seq; }
              inline operator Nominals& () { return *_pd_seq; }
#endif
                
              inline const Nominals& in() const { return *_pd_seq; }
              inline Nominals&       inout()    { return *_pd_seq; }
              inline Nominals*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline Nominals* _retn() { Nominals* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class Nominals_out;
              
            private:
              Nominals* _pd_seq;
            };

            class Nominals_out {
            public:
              inline Nominals_out(Nominals*& _s) : _data(_s) { _data = 0; }
              inline Nominals_out(Nominals_var& _s)
                : _data(_s._pd_seq) { _s = (Nominals*) 0; }
              inline Nominals_out(const Nominals_out& _s) : _data(_s._data) {}
              inline Nominals_out& operator = (const Nominals_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline Nominals_out& operator = (Nominals* _s) {
                _data = _s;
                return *this;
              }
              inline operator Nominals*&()  { return _data; }
              inline Nominals*& ptr()       { return _data; }
              inline Nominals* operator->() { return _data; }

              inline LFNominal& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              Nominals*& _data;

            private:
              Nominals_out();
              Nominals_out& operator=(const Nominals_var&);
            };

            struct LogicalForm {
              typedef _CORBA_ConstrType_Variable_Var<LogicalForm> _var_type;

              
              ::CORBA::String_member logicalFormId;

              Nominals noms;

              ::CORBA::Float preferenceScore;

              LFNominal root;

              ::CORBA::Long stringPos;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef LogicalForm::_var_type LogicalForm_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< LogicalForm,LogicalForm_var > LogicalForm_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogicalForm;

            struct LFComponent {
              typedef _CORBA_ConstrType_Variable_Var<LFComponent> _var_type;

              
              ::CORBA::String_member componentName;

              LogicalForm lf;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef LFComponent::_var_type LFComponent_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< LFComponent,LFComponent_var > LFComponent_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFComponent;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFComponents;

            class LFComponents_var;

            class LFComponents : public _CORBA_Unbounded_Sequence< LFComponent >  {
            public:
              typedef LFComponents_var _var_type;
              inline LFComponents() {}
              inline LFComponents(const LFComponents& _s)
                : _CORBA_Unbounded_Sequence< LFComponent > (_s) {}

              inline LFComponents(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< LFComponent > (_max) {}
              inline LFComponents(_CORBA_ULong _max, _CORBA_ULong _len, LFComponent* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< LFComponent > (_max, _len, _val, _rel) {}

            

              inline LFComponents& operator = (const LFComponents& _s) {
                _CORBA_Unbounded_Sequence< LFComponent > ::operator=(_s);
                return *this;
              }
            };

            class LFComponents_out;

            class LFComponents_var {
            public:
              inline LFComponents_var() : _pd_seq(0) {}
              inline LFComponents_var(LFComponents* _s) : _pd_seq(_s) {}
              inline LFComponents_var(const LFComponents_var& _s) {
                if( _s._pd_seq )  _pd_seq = new LFComponents(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~LFComponents_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline LFComponents_var& operator = (LFComponents* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline LFComponents_var& operator = (const LFComponents_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new LFComponents;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline LFComponent& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline LFComponents* operator -> () { return _pd_seq; }
              inline const LFComponents* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator LFComponents& () const { return *_pd_seq; }
#else
              inline operator const LFComponents& () const { return *_pd_seq; }
              inline operator LFComponents& () { return *_pd_seq; }
#endif
                
              inline const LFComponents& in() const { return *_pd_seq; }
              inline LFComponents&       inout()    { return *_pd_seq; }
              inline LFComponents*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline LFComponents* _retn() { LFComponents* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class LFComponents_out;
              
            private:
              LFComponents* _pd_seq;
            };

            class LFComponents_out {
            public:
              inline LFComponents_out(LFComponents*& _s) : _data(_s) { _data = 0; }
              inline LFComponents_out(LFComponents_var& _s)
                : _data(_s._pd_seq) { _s = (LFComponents*) 0; }
              inline LFComponents_out(const LFComponents_out& _s) : _data(_s._data) {}
              inline LFComponents_out& operator = (const LFComponents_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline LFComponents_out& operator = (LFComponents* _s) {
                _data = _s;
                return *this;
              }
              inline operator LFComponents*&()  { return _data; }
              inline LFComponents*& ptr()       { return _data; }
              inline LFComponents* operator->() { return _data; }

              inline LFComponent& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              LFComponents*& _data;

            private:
              LFComponents_out();
              LFComponents_out& operator=(const LFComponents_var&);
            };

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LFComponentsVector;

            class LFComponentsVector_var;

            class LFComponentsVector : public _CORBA_Unbounded_Sequence< LFComponents >  {
            public:
              typedef LFComponentsVector_var _var_type;
              inline LFComponentsVector() {}
              inline LFComponentsVector(const LFComponentsVector& _s)
                : _CORBA_Unbounded_Sequence< LFComponents > (_s) {}

              inline LFComponentsVector(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< LFComponents > (_max) {}
              inline LFComponentsVector(_CORBA_ULong _max, _CORBA_ULong _len, LFComponents* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< LFComponents > (_max, _len, _val, _rel) {}

            

              inline LFComponentsVector& operator = (const LFComponentsVector& _s) {
                _CORBA_Unbounded_Sequence< LFComponents > ::operator=(_s);
                return *this;
              }
            };

            class LFComponentsVector_out;

            class LFComponentsVector_var {
            public:
              inline LFComponentsVector_var() : _pd_seq(0) {}
              inline LFComponentsVector_var(LFComponentsVector* _s) : _pd_seq(_s) {}
              inline LFComponentsVector_var(const LFComponentsVector_var& _s) {
                if( _s._pd_seq )  _pd_seq = new LFComponentsVector(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~LFComponentsVector_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline LFComponentsVector_var& operator = (LFComponentsVector* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline LFComponentsVector_var& operator = (const LFComponentsVector_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new LFComponentsVector;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline LFComponents& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline LFComponentsVector* operator -> () { return _pd_seq; }
              inline const LFComponentsVector* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator LFComponentsVector& () const { return *_pd_seq; }
#else
              inline operator const LFComponentsVector& () const { return *_pd_seq; }
              inline operator LFComponentsVector& () { return *_pd_seq; }
#endif
                
              inline const LFComponentsVector& in() const { return *_pd_seq; }
              inline LFComponentsVector&       inout()    { return *_pd_seq; }
              inline LFComponentsVector*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline LFComponentsVector* _retn() { LFComponentsVector* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class LFComponentsVector_out;
              
            private:
              LFComponentsVector* _pd_seq;
            };

            class LFComponentsVector_out {
            public:
              inline LFComponentsVector_out(LFComponentsVector*& _s) : _data(_s) { _data = 0; }
              inline LFComponentsVector_out(LFComponentsVector_var& _s)
                : _data(_s._pd_seq) { _s = (LFComponentsVector*) 0; }
              inline LFComponentsVector_out(const LFComponentsVector_out& _s) : _data(_s._data) {}
              inline LFComponentsVector_out& operator = (const LFComponentsVector_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline LFComponentsVector_out& operator = (LFComponentsVector* _s) {
                _data = _s;
                return *this;
              }
              inline operator LFComponentsVector*&()  { return _data; }
              inline LFComponentsVector*& ptr()       { return _data; }
              inline LFComponentsVector* operator->() { return _data; }

              inline LFComponents& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              LFComponentsVector*& _data;

            private:
              LFComponentsVector_out();
              LFComponentsVector_out& operator=(const LFComponentsVector_var&);
            };

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogicalFormsVector;

            class LogicalFormsVector_var;

            class LogicalFormsVector : public _CORBA_Unbounded_Sequence< LogicalForm >  {
            public:
              typedef LogicalFormsVector_var _var_type;
              inline LogicalFormsVector() {}
              inline LogicalFormsVector(const LogicalFormsVector& _s)
                : _CORBA_Unbounded_Sequence< LogicalForm > (_s) {}

              inline LogicalFormsVector(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< LogicalForm > (_max) {}
              inline LogicalFormsVector(_CORBA_ULong _max, _CORBA_ULong _len, LogicalForm* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< LogicalForm > (_max, _len, _val, _rel) {}

            

              inline LogicalFormsVector& operator = (const LogicalFormsVector& _s) {
                _CORBA_Unbounded_Sequence< LogicalForm > ::operator=(_s);
                return *this;
              }
            };

            class LogicalFormsVector_out;

            class LogicalFormsVector_var {
            public:
              inline LogicalFormsVector_var() : _pd_seq(0) {}
              inline LogicalFormsVector_var(LogicalFormsVector* _s) : _pd_seq(_s) {}
              inline LogicalFormsVector_var(const LogicalFormsVector_var& _s) {
                if( _s._pd_seq )  _pd_seq = new LogicalFormsVector(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~LogicalFormsVector_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline LogicalFormsVector_var& operator = (LogicalFormsVector* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline LogicalFormsVector_var& operator = (const LogicalFormsVector_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new LogicalFormsVector;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline LogicalForm& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline LogicalFormsVector* operator -> () { return _pd_seq; }
              inline const LogicalFormsVector* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator LogicalFormsVector& () const { return *_pd_seq; }
#else
              inline operator const LogicalFormsVector& () const { return *_pd_seq; }
              inline operator LogicalFormsVector& () { return *_pd_seq; }
#endif
                
              inline const LogicalFormsVector& in() const { return *_pd_seq; }
              inline LogicalFormsVector&       inout()    { return *_pd_seq; }
              inline LogicalFormsVector*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline LogicalFormsVector* _retn() { LogicalFormsVector* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class LogicalFormsVector_out;
              
            private:
              LogicalFormsVector* _pd_seq;
            };

            class LogicalFormsVector_out {
            public:
              inline LogicalFormsVector_out(LogicalFormsVector*& _s) : _data(_s) { _data = 0; }
              inline LogicalFormsVector_out(LogicalFormsVector_var& _s)
                : _data(_s._pd_seq) { _s = (LogicalFormsVector*) 0; }
              inline LogicalFormsVector_out(const LogicalFormsVector_out& _s) : _data(_s._data) {}
              inline LogicalFormsVector_out& operator = (const LogicalFormsVector_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline LogicalFormsVector_out& operator = (LogicalFormsVector* _s) {
                _data = _s;
                return *this;
              }
              inline operator LogicalFormsVector*&()  { return _data; }
              inline LogicalFormsVector*& ptr()       { return _data; }
              inline LogicalFormsVector* operator->() { return _data; }

              inline LogicalForm& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              LogicalFormsVector*& _data;

            private:
              LogicalFormsVector_out();
              LogicalFormsVector_out& operator=(const LogicalFormsVector_var&);
            };

            enum MetaType { ASSERTION, COMMAND, QUESTION, UNKNOWN /*, __max_MetaType=0xffffffff */ };
            typedef MetaType& MetaType_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MetaType;

            enum MetaTypeSort { informative_attributive_endurant_instantiation, informative_attributive_endurant_quality, informative_attributive_endurant_perspective_spatial, informative_polar_positive, informative_polar_negative, affective_state_physical, ability_cognition_perception_object, ability_cognition_perception_object_neg, affective_need_object, affective_desire_object, affective_desire_action_general, affective_desire_action_specific, evaluative_positive, evaluative_negative, command_cognitive_analysis_location, command_cognitive_analysis_endurant, command_manipulation_object, command_manipulation_subject, command_movement_position_causative, command_movement_position_subjective, command_movement_motion_locationchange_motion_subjective, command_movement_motion_locationchange_motion_direction, command_movement_motion_locationchange_motion_destination, command_movement_motion_locationchange_motion_guidance_person, command_movement_motion_locationchange_motion_guidance_area, command_movement_motion_locationchange_transport_object, command_movement_motion_locationchange_transport_object_direction, command_movement_motion_locationchange_transport_object_destination, command_movement_motion_insitu_pose_relative, command_movement_motion_insitu_pose_facing, command_assist, command_obtain_object, command_obtain_object_recipient, command_obtain_object_destination, command_obtain_object_origin, informative_factual_endurant_generic, informative_factual_endurant_instantiation, informative_factual_endurant_perspective_spatial, informative_factual_person_perspective_spatial, informative_factual_endurant_quality, informative_polar_endurant_perspective_spatial, informative_polar_endurant_quality, informative_polar_endurant_instantiation, informative_polar_person_perspective_spatial, informative_polar_perm_poss_abil_movement_motion_locationchange_motion, informative_polar_perm_poss_abil_movement_motion_locationchange_transport_object, informative_polar_perm_poss_abil_movement_motion_locationchange_transport_object_direction, informative_polar_perm_poss_abil_movement_motion_locationchange_transport_object_destination, informative_polar_perm_poss_abil_assist, informative_polar_perm_poss_abil_obtain_object, informative_polar_volit_predict_obtain_object, informative_polar_volit_predict_movement_motion_locationchange_motion, informative_polar_volit_predict_movement_motion_locationchange_transport_object, informative_polar_volit_predict_movement_motion_locationchange_transport_object_direction, informative_polar_volit_predict_movement_motion_locationchange_transport_object_destination, affective_factual_desire_object, affective_factual_desire_general, affective_factual_disposition_general, affective_factual_mood, affective_polar_desire_object, affective_polar_disposition_object, affective_polar_mood, affective_choice_desire_object, affective_choice_disposition_object /*, __max_MetaTypeSort=0xffffffff */ };
            typedef MetaTypeSort& MetaTypeSort_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MetaTypeSort;

            struct MetaTypeCharacterization {
              typedef _CORBA_ConstrType_Variable_Var<MetaTypeCharacterization> _var_type;

              
              ::CORBA::String_member logicalFormId;

              MetaType mType;

              MetaTypeSort mSort;

              LFComponents components;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef MetaTypeCharacterization::_var_type MetaTypeCharacterization_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< MetaTypeCharacterization,MetaTypeCharacterization_var > MetaTypeCharacterization_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MetaTypeCharacterization;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MetaTypeCharacterizationsVector;

            class MetaTypeCharacterizationsVector_var;

            class MetaTypeCharacterizationsVector : public _CORBA_Unbounded_Sequence< MetaTypeCharacterization >  {
            public:
              typedef MetaTypeCharacterizationsVector_var _var_type;
              inline MetaTypeCharacterizationsVector() {}
              inline MetaTypeCharacterizationsVector(const MetaTypeCharacterizationsVector& _s)
                : _CORBA_Unbounded_Sequence< MetaTypeCharacterization > (_s) {}

              inline MetaTypeCharacterizationsVector(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< MetaTypeCharacterization > (_max) {}
              inline MetaTypeCharacterizationsVector(_CORBA_ULong _max, _CORBA_ULong _len, MetaTypeCharacterization* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< MetaTypeCharacterization > (_max, _len, _val, _rel) {}

            

              inline MetaTypeCharacterizationsVector& operator = (const MetaTypeCharacterizationsVector& _s) {
                _CORBA_Unbounded_Sequence< MetaTypeCharacterization > ::operator=(_s);
                return *this;
              }
            };

            class MetaTypeCharacterizationsVector_out;

            class MetaTypeCharacterizationsVector_var {
            public:
              inline MetaTypeCharacterizationsVector_var() : _pd_seq(0) {}
              inline MetaTypeCharacterizationsVector_var(MetaTypeCharacterizationsVector* _s) : _pd_seq(_s) {}
              inline MetaTypeCharacterizationsVector_var(const MetaTypeCharacterizationsVector_var& _s) {
                if( _s._pd_seq )  _pd_seq = new MetaTypeCharacterizationsVector(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~MetaTypeCharacterizationsVector_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline MetaTypeCharacterizationsVector_var& operator = (MetaTypeCharacterizationsVector* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline MetaTypeCharacterizationsVector_var& operator = (const MetaTypeCharacterizationsVector_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new MetaTypeCharacterizationsVector;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline MetaTypeCharacterization& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline MetaTypeCharacterizationsVector* operator -> () { return _pd_seq; }
              inline const MetaTypeCharacterizationsVector* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator MetaTypeCharacterizationsVector& () const { return *_pd_seq; }
#else
              inline operator const MetaTypeCharacterizationsVector& () const { return *_pd_seq; }
              inline operator MetaTypeCharacterizationsVector& () { return *_pd_seq; }
#endif
                
              inline const MetaTypeCharacterizationsVector& in() const { return *_pd_seq; }
              inline MetaTypeCharacterizationsVector&       inout()    { return *_pd_seq; }
              inline MetaTypeCharacterizationsVector*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline MetaTypeCharacterizationsVector* _retn() { MetaTypeCharacterizationsVector* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class MetaTypeCharacterizationsVector_out;
              
            private:
              MetaTypeCharacterizationsVector* _pd_seq;
            };

            class MetaTypeCharacterizationsVector_out {
            public:
              inline MetaTypeCharacterizationsVector_out(MetaTypeCharacterizationsVector*& _s) : _data(_s) { _data = 0; }
              inline MetaTypeCharacterizationsVector_out(MetaTypeCharacterizationsVector_var& _s)
                : _data(_s._pd_seq) { _s = (MetaTypeCharacterizationsVector*) 0; }
              inline MetaTypeCharacterizationsVector_out(const MetaTypeCharacterizationsVector_out& _s) : _data(_s._data) {}
              inline MetaTypeCharacterizationsVector_out& operator = (const MetaTypeCharacterizationsVector_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline MetaTypeCharacterizationsVector_out& operator = (MetaTypeCharacterizationsVector* _s) {
                _data = _s;
                return *this;
              }
              inline operator MetaTypeCharacterizationsVector*&()  { return _data; }
              inline MetaTypeCharacterizationsVector*& ptr()       { return _data; }
              inline MetaTypeCharacterizationsVector* operator->() { return _data; }

              inline MetaTypeCharacterization& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              MetaTypeCharacterizationsVector*& _data;

            private:
              MetaTypeCharacterizationsVector_out();
              MetaTypeCharacterizationsVector_out& operator=(const MetaTypeCharacterizationsVector_var&);
            };

            enum LogicalFormComplexityType { SIMPLEX, COMPLX_CONJUNCTIVE, COMPLEX_DISJUNCTIVE, COMPLEX_MIXED /*, __max_LogicalFormComplexityType=0xffffffff */ };
            typedef LogicalFormComplexityType& LogicalFormComplexityType_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogicalFormComplexityType;

            struct MetaLogicalForm {
              typedef _CORBA_ConstrType_Variable_Var<MetaLogicalForm> _var_type;

              
              LogicalForm lf;

              LogicalFormComplexityType complexityType;

              LogicalFormsVector lfsVector;

              MetaTypeCharacterizationsVector characterizationsVector;

              LFComponentsVector componentsVector;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef MetaLogicalForm::_var_type MetaLogicalForm_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< MetaLogicalForm,MetaLogicalForm_var > MetaLogicalForm_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_MetaLogicalForm;

            enum EpistemicStatusFeature { EPI_KNOWN, EPI_UNKNOWN /*, __max_EpistemicStatusFeature=0xffffffff */ };
            typedef EpistemicStatusFeature& EpistemicStatusFeature_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_EpistemicStatusFeature;

            enum UpdateStatusFeature { T, F, AMB /*, __max_UpdateStatusFeature=0xffffffff */ };
            typedef UpdateStatusFeature& UpdateStatusFeature_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_UpdateStatusFeature;

            struct DynCompStatus {
              typedef _CORBA_ConstrType_Variable_Var<DynCompStatus> _var_type;

              
              ::CORBA::String_member referent;

              EpistemicStatusFeature epistemicStatus;

              UpdateStatusFeature updateStatus;

              ::CORBA::String_member statusSource;

              ::CORBA::String_member statusGround;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef DynCompStatus::_var_type DynCompStatus_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< DynCompStatus,DynCompStatus_var > DynCompStatus_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DynCompStatus;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_DynCompStatusSeq;

            class DynCompStatusSeq_var;

            class DynCompStatusSeq : public _CORBA_Unbounded_Sequence< DynCompStatus >  {
            public:
              typedef DynCompStatusSeq_var _var_type;
              inline DynCompStatusSeq() {}
              inline DynCompStatusSeq(const DynCompStatusSeq& _s)
                : _CORBA_Unbounded_Sequence< DynCompStatus > (_s) {}

              inline DynCompStatusSeq(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< DynCompStatus > (_max) {}
              inline DynCompStatusSeq(_CORBA_ULong _max, _CORBA_ULong _len, DynCompStatus* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< DynCompStatus > (_max, _len, _val, _rel) {}

            

              inline DynCompStatusSeq& operator = (const DynCompStatusSeq& _s) {
                _CORBA_Unbounded_Sequence< DynCompStatus > ::operator=(_s);
                return *this;
              }
            };

            class DynCompStatusSeq_out;

            class DynCompStatusSeq_var {
            public:
              inline DynCompStatusSeq_var() : _pd_seq(0) {}
              inline DynCompStatusSeq_var(DynCompStatusSeq* _s) : _pd_seq(_s) {}
              inline DynCompStatusSeq_var(const DynCompStatusSeq_var& _s) {
                if( _s._pd_seq )  _pd_seq = new DynCompStatusSeq(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~DynCompStatusSeq_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline DynCompStatusSeq_var& operator = (DynCompStatusSeq* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline DynCompStatusSeq_var& operator = (const DynCompStatusSeq_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new DynCompStatusSeq;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline DynCompStatus& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline DynCompStatusSeq* operator -> () { return _pd_seq; }
              inline const DynCompStatusSeq* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator DynCompStatusSeq& () const { return *_pd_seq; }
#else
              inline operator const DynCompStatusSeq& () const { return *_pd_seq; }
              inline operator DynCompStatusSeq& () { return *_pd_seq; }
#endif
                
              inline const DynCompStatusSeq& in() const { return *_pd_seq; }
              inline DynCompStatusSeq&       inout()    { return *_pd_seq; }
              inline DynCompStatusSeq*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline DynCompStatusSeq* _retn() { DynCompStatusSeq* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class DynCompStatusSeq_out;
              
            private:
              DynCompStatusSeq* _pd_seq;
            };

            class DynCompStatusSeq_out {
            public:
              inline DynCompStatusSeq_out(DynCompStatusSeq*& _s) : _data(_s) { _data = 0; }
              inline DynCompStatusSeq_out(DynCompStatusSeq_var& _s)
                : _data(_s._pd_seq) { _s = (DynCompStatusSeq*) 0; }
              inline DynCompStatusSeq_out(const DynCompStatusSeq_out& _s) : _data(_s._data) {}
              inline DynCompStatusSeq_out& operator = (const DynCompStatusSeq_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline DynCompStatusSeq_out& operator = (DynCompStatusSeq* _s) {
                _data = _s;
                return *this;
              }
              inline operator DynCompStatusSeq*&()  { return _data; }
              inline DynCompStatusSeq*& ptr()       { return _data; }
              inline DynCompStatusSeq* operator->() { return _data; }

              inline DynCompStatus& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              DynCompStatusSeq*& _data;

            private:
              DynCompStatusSeq_out();
              DynCompStatusSeq_out& operator=(const DynCompStatusSeq_var&);
            };

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems
  _CORBA_MODULE_BEG

    _CORBA_MODULE repr
    _CORBA_MODULE_BEG

      _CORBA_MODULE lf
      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen
        _CORBA_MODULE_BEG

          _CORBA_MODULE LFEssentials
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems
  _CORBA_MODULE_BEG

    _CORBA_MODULE repr
    _CORBA_MODULE_BEG

      _CORBA_MODULE lf
      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen
        _CORBA_MODULE_BEG

          _CORBA_MODULE LFEssentials
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::ConnectiveType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::ConnectiveType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::XDISJUNCTIVE) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::ConnectiveType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::ConnectiveType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::ConnectiveType& _s);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Propositions& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Propositions* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Propositions*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Propositions*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Proposition& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Proposition* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Proposition*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Proposition*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Feature& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Feature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Feature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Feature*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Features& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Features* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Features*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Features*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFRelation& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFRelation* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFRelation*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFRelation*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Relations& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Relations* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Relations*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Relations*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFNominal& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFNominal* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFNominal*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFNominal*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Nominals& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Nominals* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::Nominals*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::Nominals*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponent& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponent* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponent*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponent*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponents& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponents* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponents*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponents*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponentsVector& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponentsVector* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponentsVector*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LFComponentsVector*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormsVector& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormsVector* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormsVector*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormsVector*& _sp);

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::UNKNOWN) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaType& _s);

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeSort _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeSort& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::affective_choice_disposition_object) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeSort) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeSort _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeSort& _s);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterization& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterization* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterization*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterization*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterizationsVector& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterizationsVector* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterizationsVector*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaTypeCharacterizationsVector*& _sp);

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormComplexityType _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormComplexityType& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::COMPLEX_MIXED) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormComplexityType) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormComplexityType _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalFormComplexityType& _s);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaLogicalForm& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaLogicalForm* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaLogicalForm*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::MetaLogicalForm*& _sp);

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::EpistemicStatusFeature _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::EpistemicStatusFeature& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::EPI_UNKNOWN) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::EpistemicStatusFeature) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::EpistemicStatusFeature _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::EpistemicStatusFeature& _s);

inline void operator >>=(org::cognitivesystems::repr::lf::autogen::LFEssentials::UpdateStatusFeature _e, cdrStream& s) {
  ::operator>>=((::CORBA::ULong)_e, s);
}

inline void operator <<= (org::cognitivesystems::repr::lf::autogen::LFEssentials::UpdateStatusFeature& _e, cdrStream& s) {
  ::CORBA::ULong _0RL_e;
  ::operator<<=(_0RL_e,s);
  if (_0RL_e <= org::cognitivesystems::repr::lf::autogen::LFEssentials::AMB) {
    _e = (org::cognitivesystems::repr::lf::autogen::LFEssentials::UpdateStatusFeature) _0RL_e;
  }
  else {
    OMNIORB_THROW(MARSHAL,_OMNI_NS(MARSHAL_InvalidEnumValue),
                  (::CORBA::CompletionStatus)s.completion());
  }
}

void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::UpdateStatusFeature _s);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::UpdateStatusFeature& _s);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatus& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatus* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatus*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatus*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatusSeq& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatusSeq* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatusSeq*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFEssentials::DynCompStatusSeq*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_LFEssentials
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_LFEssentials
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFEssentials
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFEssentials
#endif

#endif  // __LFEssentials_hh__

