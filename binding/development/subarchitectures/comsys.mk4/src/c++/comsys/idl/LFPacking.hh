// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __LFPacking_hh__
#define __LFPacking_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif



#ifndef __LFEssentials_hh_EXTERNAL_GUARD__
#define __LFEssentials_hh_EXTERNAL_GUARD__
#include <comsys/idl/LFEssentials.hh>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems

  _CORBA_MODULE_BEG

    _CORBA_MODULE repr

    _CORBA_MODULE_BEG

      _CORBA_MODULE lf

      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen

        _CORBA_MODULE_BEG

          _CORBA_MODULE LFPacking

          _CORBA_MODULE_BEG

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingNodeId;

            typedef char* PackingNodeId;
            typedef ::CORBA::String_var PackingNodeId_var;
            typedef ::CORBA::String_out PackingNodeId_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingEdgeId;

            typedef char* PackingEdgeId;
            typedef ::CORBA::String_var PackingEdgeId_var;
            typedef ::CORBA::String_out PackingEdgeId_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedLogicalFormId;

            typedef char* PackedLogicalFormId;
            typedef ::CORBA::String_var PackedLogicalFormId_var;
            typedef ::CORBA::String_out PackedLogicalFormId_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_nominalVariable;

            typedef char* nominalVariable;
            typedef ::CORBA::String_var nominalVariable_var;
            typedef ::CORBA::String_out nominalVariable_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Proposition;

            typedef LFEssentials::Proposition Proposition;
            typedef LFEssentials::Proposition_var Proposition_var;
            typedef LFEssentials::Proposition_out Proposition_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_Relations;

            typedef LFEssentials::Relations Relations;
            typedef LFEssentials::Relations_var Relations_var;
            typedef LFEssentials::Relations_out Relations_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_ontologicalSort;

            typedef char* ontologicalSort;
            typedef ::CORBA::String_var ontologicalSort_var;
            typedef ::CORBA::String_out ontologicalSort_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_LogicalFormIds;

            class LogicalFormIds_var;

            class LogicalFormIds : public _CORBA_Unbounded_Sequence_String {
            public:
              typedef LogicalFormIds_var _var_type;
              inline LogicalFormIds() {}
              inline LogicalFormIds(const LogicalFormIds& _s)
                : _CORBA_Unbounded_Sequence_String(_s) {}

              inline LogicalFormIds(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence_String(_max) {}
              inline LogicalFormIds(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

            

              inline LogicalFormIds& operator = (const LogicalFormIds& _s) {
                _CORBA_Unbounded_Sequence_String::operator=(_s);
                return *this;
              }
            };

            class LogicalFormIds_out;

            class LogicalFormIds_var {
            public:
              inline LogicalFormIds_var() : _pd_seq(0) {}
              inline LogicalFormIds_var(LogicalFormIds* _s) : _pd_seq(_s) {}
              inline LogicalFormIds_var(const LogicalFormIds_var& _s) {
                if( _s._pd_seq )  _pd_seq = new LogicalFormIds(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~LogicalFormIds_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline LogicalFormIds_var& operator = (LogicalFormIds* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline LogicalFormIds_var& operator = (const LogicalFormIds_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new LogicalFormIds;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline LogicalFormIds* operator -> () { return _pd_seq; }
              inline const LogicalFormIds* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator LogicalFormIds& () const { return *_pd_seq; }
#else
              inline operator const LogicalFormIds& () const { return *_pd_seq; }
              inline operator LogicalFormIds& () { return *_pd_seq; }
#endif
                
              inline const LogicalFormIds& in() const { return *_pd_seq; }
              inline LogicalFormIds&       inout()    { return *_pd_seq; }
              inline LogicalFormIds*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline LogicalFormIds* _retn() { LogicalFormIds* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class LogicalFormIds_out;
              
            private:
              LogicalFormIds* _pd_seq;
            };

            class LogicalFormIds_out {
            public:
              inline LogicalFormIds_out(LogicalFormIds*& _s) : _data(_s) { _data = 0; }
              inline LogicalFormIds_out(LogicalFormIds_var& _s)
                : _data(_s._pd_seq) { _s = (LogicalFormIds*) 0; }
              inline LogicalFormIds_out(const LogicalFormIds_out& _s) : _data(_s._data) {}
              inline LogicalFormIds_out& operator = (const LogicalFormIds_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline LogicalFormIds_out& operator = (LogicalFormIds* _s) {
                _data = _s;
                return *this;
              }
              inline operator LogicalFormIds*&()  { return _data; }
              inline LogicalFormIds*& ptr()       { return _data; }
              inline LogicalFormIds* operator->() { return _data; }

              inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              LogicalFormIds*& _data;

            private:
              LogicalFormIds_out();
              LogicalFormIds_out& operator=(const LogicalFormIds_var&);
            };

            struct PackingNodeTarget {
              typedef _CORBA_ConstrType_Variable_Var<PackingNodeTarget> _var_type;

              
              ::CORBA::String_member pnId;

              LogicalFormIds lfIds;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackingNodeTarget::_var_type PackingNodeTarget_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackingNodeTarget,PackingNodeTarget_var > PackingNodeTarget_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingNodeTarget;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingNodeTargets;

            class PackingNodeTargets_var;

            class PackingNodeTargets : public _CORBA_Unbounded_Sequence< PackingNodeTarget >  {
            public:
              typedef PackingNodeTargets_var _var_type;
              inline PackingNodeTargets() {}
              inline PackingNodeTargets(const PackingNodeTargets& _s)
                : _CORBA_Unbounded_Sequence< PackingNodeTarget > (_s) {}

              inline PackingNodeTargets(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackingNodeTarget > (_max) {}
              inline PackingNodeTargets(_CORBA_ULong _max, _CORBA_ULong _len, PackingNodeTarget* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackingNodeTarget > (_max, _len, _val, _rel) {}

            

              inline PackingNodeTargets& operator = (const PackingNodeTargets& _s) {
                _CORBA_Unbounded_Sequence< PackingNodeTarget > ::operator=(_s);
                return *this;
              }
            };

            class PackingNodeTargets_out;

            class PackingNodeTargets_var {
            public:
              inline PackingNodeTargets_var() : _pd_seq(0) {}
              inline PackingNodeTargets_var(PackingNodeTargets* _s) : _pd_seq(_s) {}
              inline PackingNodeTargets_var(const PackingNodeTargets_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackingNodeTargets(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackingNodeTargets_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackingNodeTargets_var& operator = (PackingNodeTargets* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackingNodeTargets_var& operator = (const PackingNodeTargets_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackingNodeTargets;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackingNodeTarget& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackingNodeTargets* operator -> () { return _pd_seq; }
              inline const PackingNodeTargets* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackingNodeTargets& () const { return *_pd_seq; }
#else
              inline operator const PackingNodeTargets& () const { return *_pd_seq; }
              inline operator PackingNodeTargets& () { return *_pd_seq; }
#endif
                
              inline const PackingNodeTargets& in() const { return *_pd_seq; }
              inline PackingNodeTargets&       inout()    { return *_pd_seq; }
              inline PackingNodeTargets*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackingNodeTargets* _retn() { PackingNodeTargets* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackingNodeTargets_out;
              
            private:
              PackingNodeTargets* _pd_seq;
            };

            class PackingNodeTargets_out {
            public:
              inline PackingNodeTargets_out(PackingNodeTargets*& _s) : _data(_s) { _data = 0; }
              inline PackingNodeTargets_out(PackingNodeTargets_var& _s)
                : _data(_s._pd_seq) { _s = (PackingNodeTargets*) 0; }
              inline PackingNodeTargets_out(const PackingNodeTargets_out& _s) : _data(_s._data) {}
              inline PackingNodeTargets_out& operator = (const PackingNodeTargets_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackingNodeTargets_out& operator = (PackingNodeTargets* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackingNodeTargets*&()  { return _data; }
              inline PackingNodeTargets*& ptr()       { return _data; }
              inline PackingNodeTargets* operator->() { return _data; }

              inline PackingNodeTarget& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackingNodeTargets*& _data;

            private:
              PackingNodeTargets_out();
              PackingNodeTargets_out& operator=(const PackingNodeTargets_var&);
            };

            struct PackingEdge {
              typedef _CORBA_ConstrType_Variable_Var<PackingEdge> _var_type;

              
              ::CORBA::String_member peId;

              ::CORBA::String_member mode;

              ::CORBA::String_member head;

              PackingNodeTargets targets;

              ::CORBA::Boolean coIndexedDep;

              ::CORBA::Float preferenceScore;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackingEdge::_var_type PackingEdge_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackingEdge,PackingEdge_var > PackingEdge_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingEdge;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingEdges;

            class PackingEdges_var;

            class PackingEdges : public _CORBA_Unbounded_Sequence< PackingEdge >  {
            public:
              typedef PackingEdges_var _var_type;
              inline PackingEdges() {}
              inline PackingEdges(const PackingEdges& _s)
                : _CORBA_Unbounded_Sequence< PackingEdge > (_s) {}

              inline PackingEdges(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackingEdge > (_max) {}
              inline PackingEdges(_CORBA_ULong _max, _CORBA_ULong _len, PackingEdge* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackingEdge > (_max, _len, _val, _rel) {}

            

              inline PackingEdges& operator = (const PackingEdges& _s) {
                _CORBA_Unbounded_Sequence< PackingEdge > ::operator=(_s);
                return *this;
              }
            };

            class PackingEdges_out;

            class PackingEdges_var {
            public:
              inline PackingEdges_var() : _pd_seq(0) {}
              inline PackingEdges_var(PackingEdges* _s) : _pd_seq(_s) {}
              inline PackingEdges_var(const PackingEdges_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackingEdges(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackingEdges_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackingEdges_var& operator = (PackingEdges* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackingEdges_var& operator = (const PackingEdges_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackingEdges;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackingEdge& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackingEdges* operator -> () { return _pd_seq; }
              inline const PackingEdges* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackingEdges& () const { return *_pd_seq; }
#else
              inline operator const PackingEdges& () const { return *_pd_seq; }
              inline operator PackingEdges& () { return *_pd_seq; }
#endif
                
              inline const PackingEdges& in() const { return *_pd_seq; }
              inline PackingEdges&       inout()    { return *_pd_seq; }
              inline PackingEdges*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackingEdges* _retn() { PackingEdges* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackingEdges_out;
              
            private:
              PackingEdges* _pd_seq;
            };

            class PackingEdges_out {
            public:
              inline PackingEdges_out(PackingEdges*& _s) : _data(_s) { _data = 0; }
              inline PackingEdges_out(PackingEdges_var& _s)
                : _data(_s._pd_seq) { _s = (PackingEdges*) 0; }
              inline PackingEdges_out(const PackingEdges_out& _s) : _data(_s._data) {}
              inline PackingEdges_out& operator = (const PackingEdges_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackingEdges_out& operator = (PackingEdges* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackingEdges*&()  { return _data; }
              inline PackingEdges*& ptr()       { return _data; }
              inline PackingEdges* operator->() { return _data; }

              inline PackingEdge& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackingEdges*& _data;

            private:
              PackingEdges_out();
              PackingEdges_out& operator=(const PackingEdges_var&);
            };

            struct PackedFeature {
              typedef _CORBA_ConstrType_Variable_Var<PackedFeature> _var_type;

              
              ::CORBA::String_member feat;

              ::CORBA::String_member value;

              LogicalFormIds lfIds;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackedFeature::_var_type PackedFeature_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackedFeature,PackedFeature_var > PackedFeature_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedFeature;

            struct PackedOntologicalSort {
              typedef _CORBA_ConstrType_Variable_Var<PackedOntologicalSort> _var_type;

              
              ::CORBA::String_member sort;

              LogicalFormIds lfIds;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackedOntologicalSort::_var_type PackedOntologicalSort_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackedOntologicalSort,PackedOntologicalSort_var > PackedOntologicalSort_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedOntologicalSort;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedOntologicalSorts;

            class PackedOntologicalSorts_var;

            class PackedOntologicalSorts : public _CORBA_Unbounded_Sequence< PackedOntologicalSort >  {
            public:
              typedef PackedOntologicalSorts_var _var_type;
              inline PackedOntologicalSorts() {}
              inline PackedOntologicalSorts(const PackedOntologicalSorts& _s)
                : _CORBA_Unbounded_Sequence< PackedOntologicalSort > (_s) {}

              inline PackedOntologicalSorts(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackedOntologicalSort > (_max) {}
              inline PackedOntologicalSorts(_CORBA_ULong _max, _CORBA_ULong _len, PackedOntologicalSort* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackedOntologicalSort > (_max, _len, _val, _rel) {}

            

              inline PackedOntologicalSorts& operator = (const PackedOntologicalSorts& _s) {
                _CORBA_Unbounded_Sequence< PackedOntologicalSort > ::operator=(_s);
                return *this;
              }
            };

            class PackedOntologicalSorts_out;

            class PackedOntologicalSorts_var {
            public:
              inline PackedOntologicalSorts_var() : _pd_seq(0) {}
              inline PackedOntologicalSorts_var(PackedOntologicalSorts* _s) : _pd_seq(_s) {}
              inline PackedOntologicalSorts_var(const PackedOntologicalSorts_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackedOntologicalSorts(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackedOntologicalSorts_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackedOntologicalSorts_var& operator = (PackedOntologicalSorts* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackedOntologicalSorts_var& operator = (const PackedOntologicalSorts_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackedOntologicalSorts;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackedOntologicalSort& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackedOntologicalSorts* operator -> () { return _pd_seq; }
              inline const PackedOntologicalSorts* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackedOntologicalSorts& () const { return *_pd_seq; }
#else
              inline operator const PackedOntologicalSorts& () const { return *_pd_seq; }
              inline operator PackedOntologicalSorts& () { return *_pd_seq; }
#endif
                
              inline const PackedOntologicalSorts& in() const { return *_pd_seq; }
              inline PackedOntologicalSorts&       inout()    { return *_pd_seq; }
              inline PackedOntologicalSorts*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackedOntologicalSorts* _retn() { PackedOntologicalSorts* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackedOntologicalSorts_out;
              
            private:
              PackedOntologicalSorts* _pd_seq;
            };

            class PackedOntologicalSorts_out {
            public:
              inline PackedOntologicalSorts_out(PackedOntologicalSorts*& _s) : _data(_s) { _data = 0; }
              inline PackedOntologicalSorts_out(PackedOntologicalSorts_var& _s)
                : _data(_s._pd_seq) { _s = (PackedOntologicalSorts*) 0; }
              inline PackedOntologicalSorts_out(const PackedOntologicalSorts_out& _s) : _data(_s._data) {}
              inline PackedOntologicalSorts_out& operator = (const PackedOntologicalSorts_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackedOntologicalSorts_out& operator = (PackedOntologicalSorts* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackedOntologicalSorts*&()  { return _data; }
              inline PackedOntologicalSorts*& ptr()       { return _data; }
              inline PackedOntologicalSorts* operator->() { return _data; }

              inline PackedOntologicalSort& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackedOntologicalSorts*& _data;

            private:
              PackedOntologicalSorts_out();
              PackedOntologicalSorts_out& operator=(const PackedOntologicalSorts_var&);
            };

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedFeatures;

            class PackedFeatures_var;

            class PackedFeatures : public _CORBA_Unbounded_Sequence< PackedFeature >  {
            public:
              typedef PackedFeatures_var _var_type;
              inline PackedFeatures() {}
              inline PackedFeatures(const PackedFeatures& _s)
                : _CORBA_Unbounded_Sequence< PackedFeature > (_s) {}

              inline PackedFeatures(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackedFeature > (_max) {}
              inline PackedFeatures(_CORBA_ULong _max, _CORBA_ULong _len, PackedFeature* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackedFeature > (_max, _len, _val, _rel) {}

            

              inline PackedFeatures& operator = (const PackedFeatures& _s) {
                _CORBA_Unbounded_Sequence< PackedFeature > ::operator=(_s);
                return *this;
              }
            };

            class PackedFeatures_out;

            class PackedFeatures_var {
            public:
              inline PackedFeatures_var() : _pd_seq(0) {}
              inline PackedFeatures_var(PackedFeatures* _s) : _pd_seq(_s) {}
              inline PackedFeatures_var(const PackedFeatures_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackedFeatures(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackedFeatures_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackedFeatures_var& operator = (PackedFeatures* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackedFeatures_var& operator = (const PackedFeatures_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackedFeatures;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackedFeature& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackedFeatures* operator -> () { return _pd_seq; }
              inline const PackedFeatures* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackedFeatures& () const { return *_pd_seq; }
#else
              inline operator const PackedFeatures& () const { return *_pd_seq; }
              inline operator PackedFeatures& () { return *_pd_seq; }
#endif
                
              inline const PackedFeatures& in() const { return *_pd_seq; }
              inline PackedFeatures&       inout()    { return *_pd_seq; }
              inline PackedFeatures*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackedFeatures* _retn() { PackedFeatures* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackedFeatures_out;
              
            private:
              PackedFeatures* _pd_seq;
            };

            class PackedFeatures_out {
            public:
              inline PackedFeatures_out(PackedFeatures*& _s) : _data(_s) { _data = 0; }
              inline PackedFeatures_out(PackedFeatures_var& _s)
                : _data(_s._pd_seq) { _s = (PackedFeatures*) 0; }
              inline PackedFeatures_out(const PackedFeatures_out& _s) : _data(_s._data) {}
              inline PackedFeatures_out& operator = (const PackedFeatures_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackedFeatures_out& operator = (PackedFeatures* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackedFeatures*&()  { return _data; }
              inline PackedFeatures*& ptr()       { return _data; }
              inline PackedFeatures* operator->() { return _data; }

              inline PackedFeature& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackedFeatures*& _data;

            private:
              PackedFeatures_out();
              PackedFeatures_out& operator=(const PackedFeatures_var&);
            };

            struct PackedNominal {
              typedef _CORBA_ConstrType_Variable_Var<PackedNominal> _var_type;

              
              ::CORBA::String_member nomVar;

              PackedOntologicalSorts packedSorts;

              Proposition prop;

              Relations rels;

              PackedFeatures feats;

              PackingEdges pEdges;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackedNominal::_var_type PackedNominal_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackedNominal,PackedNominal_var > PackedNominal_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedNominal;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedNominals;

            class PackedNominals_var;

            class PackedNominals : public _CORBA_Unbounded_Sequence< PackedNominal >  {
            public:
              typedef PackedNominals_var _var_type;
              inline PackedNominals() {}
              inline PackedNominals(const PackedNominals& _s)
                : _CORBA_Unbounded_Sequence< PackedNominal > (_s) {}

              inline PackedNominals(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackedNominal > (_max) {}
              inline PackedNominals(_CORBA_ULong _max, _CORBA_ULong _len, PackedNominal* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackedNominal > (_max, _len, _val, _rel) {}

            

              inline PackedNominals& operator = (const PackedNominals& _s) {
                _CORBA_Unbounded_Sequence< PackedNominal > ::operator=(_s);
                return *this;
              }
            };

            class PackedNominals_out;

            class PackedNominals_var {
            public:
              inline PackedNominals_var() : _pd_seq(0) {}
              inline PackedNominals_var(PackedNominals* _s) : _pd_seq(_s) {}
              inline PackedNominals_var(const PackedNominals_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackedNominals(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackedNominals_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackedNominals_var& operator = (PackedNominals* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackedNominals_var& operator = (const PackedNominals_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackedNominals;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackedNominal& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackedNominals* operator -> () { return _pd_seq; }
              inline const PackedNominals* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackedNominals& () const { return *_pd_seq; }
#else
              inline operator const PackedNominals& () const { return *_pd_seq; }
              inline operator PackedNominals& () { return *_pd_seq; }
#endif
                
              inline const PackedNominals& in() const { return *_pd_seq; }
              inline PackedNominals&       inout()    { return *_pd_seq; }
              inline PackedNominals*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackedNominals* _retn() { PackedNominals* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackedNominals_out;
              
            private:
              PackedNominals* _pd_seq;
            };

            class PackedNominals_out {
            public:
              inline PackedNominals_out(PackedNominals*& _s) : _data(_s) { _data = 0; }
              inline PackedNominals_out(PackedNominals_var& _s)
                : _data(_s._pd_seq) { _s = (PackedNominals*) 0; }
              inline PackedNominals_out(const PackedNominals_out& _s) : _data(_s._data) {}
              inline PackedNominals_out& operator = (const PackedNominals_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackedNominals_out& operator = (PackedNominals* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackedNominals*&()  { return _data; }
              inline PackedNominals*& ptr()       { return _data; }
              inline PackedNominals* operator->() { return _data; }

              inline PackedNominal& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackedNominals*& _data;

            private:
              PackedNominals_out();
              PackedNominals_out& operator=(const PackedNominals_var&);
            };

            struct NominalPackingEdgePair {
              typedef _CORBA_ConstrType_Variable_Var<NominalPackingEdgePair> _var_type;

              
              ::CORBA::String_member head;

              PackingEdge pe;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef NominalPackingEdgePair::_var_type NominalPackingEdgePair_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< NominalPackingEdgePair,NominalPackingEdgePair_var > NominalPackingEdgePair_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NominalPackingEdgePair;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_NominalPackingEdgePairs;

            class NominalPackingEdgePairs_var;

            class NominalPackingEdgePairs : public _CORBA_Unbounded_Sequence< NominalPackingEdgePair >  {
            public:
              typedef NominalPackingEdgePairs_var _var_type;
              inline NominalPackingEdgePairs() {}
              inline NominalPackingEdgePairs(const NominalPackingEdgePairs& _s)
                : _CORBA_Unbounded_Sequence< NominalPackingEdgePair > (_s) {}

              inline NominalPackingEdgePairs(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< NominalPackingEdgePair > (_max) {}
              inline NominalPackingEdgePairs(_CORBA_ULong _max, _CORBA_ULong _len, NominalPackingEdgePair* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< NominalPackingEdgePair > (_max, _len, _val, _rel) {}

            

              inline NominalPackingEdgePairs& operator = (const NominalPackingEdgePairs& _s) {
                _CORBA_Unbounded_Sequence< NominalPackingEdgePair > ::operator=(_s);
                return *this;
              }
            };

            class NominalPackingEdgePairs_out;

            class NominalPackingEdgePairs_var {
            public:
              inline NominalPackingEdgePairs_var() : _pd_seq(0) {}
              inline NominalPackingEdgePairs_var(NominalPackingEdgePairs* _s) : _pd_seq(_s) {}
              inline NominalPackingEdgePairs_var(const NominalPackingEdgePairs_var& _s) {
                if( _s._pd_seq )  _pd_seq = new NominalPackingEdgePairs(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~NominalPackingEdgePairs_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline NominalPackingEdgePairs_var& operator = (NominalPackingEdgePairs* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline NominalPackingEdgePairs_var& operator = (const NominalPackingEdgePairs_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new NominalPackingEdgePairs;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline NominalPackingEdgePair& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline NominalPackingEdgePairs* operator -> () { return _pd_seq; }
              inline const NominalPackingEdgePairs* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator NominalPackingEdgePairs& () const { return *_pd_seq; }
#else
              inline operator const NominalPackingEdgePairs& () const { return *_pd_seq; }
              inline operator NominalPackingEdgePairs& () { return *_pd_seq; }
#endif
                
              inline const NominalPackingEdgePairs& in() const { return *_pd_seq; }
              inline NominalPackingEdgePairs&       inout()    { return *_pd_seq; }
              inline NominalPackingEdgePairs*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline NominalPackingEdgePairs* _retn() { NominalPackingEdgePairs* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class NominalPackingEdgePairs_out;
              
            private:
              NominalPackingEdgePairs* _pd_seq;
            };

            class NominalPackingEdgePairs_out {
            public:
              inline NominalPackingEdgePairs_out(NominalPackingEdgePairs*& _s) : _data(_s) { _data = 0; }
              inline NominalPackingEdgePairs_out(NominalPackingEdgePairs_var& _s)
                : _data(_s._pd_seq) { _s = (NominalPackingEdgePairs*) 0; }
              inline NominalPackingEdgePairs_out(const NominalPackingEdgePairs_out& _s) : _data(_s._data) {}
              inline NominalPackingEdgePairs_out& operator = (const NominalPackingEdgePairs_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline NominalPackingEdgePairs_out& operator = (NominalPackingEdgePairs* _s) {
                _data = _s;
                return *this;
              }
              inline operator NominalPackingEdgePairs*&()  { return _data; }
              inline NominalPackingEdgePairs*& ptr()       { return _data; }
              inline NominalPackingEdgePairs* operator->() { return _data; }

              inline NominalPackingEdgePair& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              NominalPackingEdgePairs*& _data;

            private:
              NominalPackingEdgePairs_out();
              NominalPackingEdgePairs_out& operator=(const NominalPackingEdgePairs_var&);
            };

            struct PackingNode {
              typedef _CORBA_ConstrType_Variable_Var<PackingNode> _var_type;

              
              ::CORBA::String_member pnId;

              LogicalFormIds lfIds;

              PackedNominals packedNoms;

              ::CORBA::String_member root;

              NominalPackingEdgePairs nomsPePairs;

              ::CORBA::Float preferenceScore;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackingNode::_var_type PackingNode_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackingNode,PackingNode_var > PackingNode_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingNode;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackingNodes;

            class PackingNodes_var;

            class PackingNodes : public _CORBA_Unbounded_Sequence< PackingNode >  {
            public:
              typedef PackingNodes_var _var_type;
              inline PackingNodes() {}
              inline PackingNodes(const PackingNodes& _s)
                : _CORBA_Unbounded_Sequence< PackingNode > (_s) {}

              inline PackingNodes(_CORBA_ULong _max)
                : _CORBA_Unbounded_Sequence< PackingNode > (_max) {}
              inline PackingNodes(_CORBA_ULong _max, _CORBA_ULong _len, PackingNode* _val, _CORBA_Boolean _rel=0)
                : _CORBA_Unbounded_Sequence< PackingNode > (_max, _len, _val, _rel) {}

            

              inline PackingNodes& operator = (const PackingNodes& _s) {
                _CORBA_Unbounded_Sequence< PackingNode > ::operator=(_s);
                return *this;
              }
            };

            class PackingNodes_out;

            class PackingNodes_var {
            public:
              inline PackingNodes_var() : _pd_seq(0) {}
              inline PackingNodes_var(PackingNodes* _s) : _pd_seq(_s) {}
              inline PackingNodes_var(const PackingNodes_var& _s) {
                if( _s._pd_seq )  _pd_seq = new PackingNodes(*_s._pd_seq);
                else              _pd_seq = 0;
              }
              inline ~PackingNodes_var() { if( _pd_seq )  delete _pd_seq; }
                
              inline PackingNodes_var& operator = (PackingNodes* _s) {
                if( _pd_seq )  delete _pd_seq;
                _pd_seq = _s;
                return *this;
              }
              inline PackingNodes_var& operator = (const PackingNodes_var& _s) {
                if( _s._pd_seq ) {
                  if( !_pd_seq )  _pd_seq = new PackingNodes;
                  *_pd_seq = *_s._pd_seq;
                } else if( _pd_seq ) {
                  delete _pd_seq;
                  _pd_seq = 0;
                }
                return *this;
              }
              inline PackingNode& operator [] (_CORBA_ULong _s) {
                return (*_pd_seq)[_s];
              }

            

              inline PackingNodes* operator -> () { return _pd_seq; }
              inline const PackingNodes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
              inline operator PackingNodes& () const { return *_pd_seq; }
#else
              inline operator const PackingNodes& () const { return *_pd_seq; }
              inline operator PackingNodes& () { return *_pd_seq; }
#endif
                
              inline const PackingNodes& in() const { return *_pd_seq; }
              inline PackingNodes&       inout()    { return *_pd_seq; }
              inline PackingNodes*&      out() {
                if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
                return _pd_seq;
              }
              inline PackingNodes* _retn() { PackingNodes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
                
              friend class PackingNodes_out;
              
            private:
              PackingNodes* _pd_seq;
            };

            class PackingNodes_out {
            public:
              inline PackingNodes_out(PackingNodes*& _s) : _data(_s) { _data = 0; }
              inline PackingNodes_out(PackingNodes_var& _s)
                : _data(_s._pd_seq) { _s = (PackingNodes*) 0; }
              inline PackingNodes_out(const PackingNodes_out& _s) : _data(_s._data) {}
              inline PackingNodes_out& operator = (const PackingNodes_out& _s) {
                _data = _s._data;
                return *this;
              }
              inline PackingNodes_out& operator = (PackingNodes* _s) {
                _data = _s;
                return *this;
              }
              inline operator PackingNodes*&()  { return _data; }
              inline PackingNodes*& ptr()       { return _data; }
              inline PackingNodes* operator->() { return _data; }

              inline PackingNode& operator [] (_CORBA_ULong _i) {
                return (*_data)[_i];
              }

            

              PackingNodes*& _data;

            private:
              PackingNodes_out();
              PackingNodes_out& operator=(const PackingNodes_var&);
            };

            struct PackedLogicalForm {
              typedef _CORBA_ConstrType_Variable_Var<PackedLogicalForm> _var_type;

              
              ::CORBA::String_member packedLFId;

              PackingNodes pNodes;

              ::CORBA::String_member root;

            

              void operator>>= (cdrStream &) const;
              void operator<<= (cdrStream &);
            };

            typedef PackedLogicalForm::_var_type PackedLogicalForm_var;

            typedef _CORBA_ConstrType_Variable_OUT_arg< PackedLogicalForm,PackedLogicalForm_var > PackedLogicalForm_out;

            _CORBA_MODULE_VAR _dyn_attr const ::CORBA::TypeCode_ptr _tc_PackedLogicalForm;

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems
  _CORBA_MODULE_BEG

    _CORBA_MODULE repr
    _CORBA_MODULE_BEG

      _CORBA_MODULE lf
      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen
        _CORBA_MODULE_BEG

          _CORBA_MODULE LFPacking
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_org
_CORBA_MODULE_BEG

  _CORBA_MODULE cognitivesystems
  _CORBA_MODULE_BEG

    _CORBA_MODULE repr
    _CORBA_MODULE_BEG

      _CORBA_MODULE lf
      _CORBA_MODULE_BEG

        _CORBA_MODULE autogen
        _CORBA_MODULE_BEG

          _CORBA_MODULE LFPacking
          _CORBA_MODULE_BEG

          _CORBA_MODULE_END

        _CORBA_MODULE_END

      _CORBA_MODULE_END

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*& _sp);

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes& _s);
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*& _sp);
_CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*& _sp);

extern void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm& _s);
extern void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*& _sp);
extern _CORBA_Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*& _sp);





#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_LFPacking
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_LFPacking
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFPacking
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_LFPacking
#endif

#endif  // __LFPacking_hh__

