/**=================================================================================

ComsysEssentials.idl

Author(s):	Geert-Jan M. Kruijff <gj@dfki.de>
			Pierre Lison		 <pierrel@coli.uni-sb.de>
			Hendrik Zender		 <zender@dfki.de>
			
Version:	080811 [comsys.mk4] 
			(Started: 060923 [comsys.mk3]) 

The file ComsysEssentials.idl provides an IDL specification of the data types for
the working memory in the communication subsystem. To facilitate synchronization 
between processes helping to build a situated interpretation of an utterance, we 
have adopted a modularization of data structures: for each level of analysis, we
have an individual data structure, which refers (through identifiers) to related 
data structures at other levels. 

This IDL requires the general LFEssentials IDL to be loaded, for specifying 
logical forms. 

The main data structures are: 
<ul> 
<li> PhonString:	   a phonological string, delivered by ASR
<li> PackedLFs:		   a packed representation of logical forms 
<li> Cache:            a pair of pointers to content representations, and a mapping 
					   between indices in these representations to associate content.      
</ul>

To compile the IDL to java: run <ant idl>
Location of the java code:  src/java/org/cognitivesystems/comsys/autogen
=================================================================================*/

#include "LFPacking.idl"
#include <CAST.idl>

module org {
module cognitivesystems {
module comsys {
module autogen {
module ComsysEssentials {

	//===========================================================================
	// GLOBALLY-USED SUPPORT STRUCTS, TYPEDEFS, ENUMS
	//===========================================================================
	
	// The string Id represents the unique identifier
	typedef string UniqueId; 

	//===========================================================================
	// FUNCTIONALITY SPECIFIC STRUCTS, TYPEDEFS, ENUMS
	//===========================================================================
	
	//---------------------------------------------------------------------------
	// Speech recognition 
	//---------------------------------------------------------------------------	
	
	
	/** The struct PhonString provides a data structure for information about a 
		phonological string. This data structure is created by speech recognition.
		
		@param UniqueId	  id				The unique identifier of the object
		@param string wordSequence		The recognized sequence of words
		@param long	  length			The number of words in the sequence
		@param float  confidenceValue	The recognition confidence value for the sequence of words
	*/
	
	struct PhonString { 
		UniqueId id;
		string wordSequence; 
		long length;
		float confidenceValue;
		float NLconfidenceValue;
		long rank;
	}; // PhonString


	/**
	    A byte array containing audio packets.
		<p> The audio format is U-law, 8 kHz, 8bits, mono.
	*/

	struct AudioData {
		sequence<octet> dataArray;
	};


	/** odd hack for triggering answering -- TODO needs to be done properly! */
	struct BoggleWoggle {
		string m_string;
	};

   
	/**
		The struct RecogResult represents the result of a transaction with the Nuance
		Speech Recognition Server.  
	  
		@param boolean	isRecognized		true if something has been recognized by the ASR engine, false otherwise
		@param boolean	isConnectionClosed	true if the connection has been shut down by the caller, false otherwise
		@param string	recString			the string that has been recognized if isRecognized is true, or the empty string otherwise
		@param long		confidence			the confidence value of the result if there is one, or 0.0 otherwise
		@param long		probability			the probability value of the result if there is one, or 0.0 otherwise
		@param string	ipAddress			the IP address of the caller
	*/

	struct RecogResult {
		boolean isRecognized ;
		boolean isConnectionClosed ;
		string recString ;
		long confidence ;
		long probability ;
		string ipAddress ;
	  } ;

	//---------------------------------------------------------------------------
	// Utterance processing
	//---------------------------------------------------------------------------	
	
	struct NonStandardRule {
		string rulename;
		long numberOfApplications;
	};
	
	struct NonStandardRulesAppliedForLF {
		string logicalFormId;
		sequence<NonStandardRule> nonStandardRules;
	};
	
	struct PhonStringLFPair {
		string logicalFormId;
		PhonString phon;
	};
	
	/** The struct PackedLFs provides a data structure for information about 
		the logical form(s) that represent interpretations for the (given) 
		PhonString.

		@param UniqueId	  id					The unique identifier of the object
		@param PhonString phon				The object representing the string (utterance) 
		@param PackedLogicalForm packedLF	The object representing the interpretations
		@param long finalized				Indicator whether the interpretations are finalized (0=unfinished; 1=finished parsing, 2=finished final pruning) 
	*/
	
	struct PackedLFs { 
		UniqueId id;
		sequence<PhonStringLFPair> phonStringLFPairs;
		sequence<PhonString> nonParsablePhonStrings;
		long stringPos;
	  //nah: change
	  //LFPacking::PackedLogicalForm packedLF;
	  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm packedLF;
		long finalized; 
		string type;
		sequence<NonStandardRulesAppliedForLF> nonStandardRulesForLF;
	}; // end PackedLFs


	/**
		The struct InterpretationSupport provides info about a single relation (in a PLF), and provides
		a list of supported or unsupported interpretations. Support is indicated by a boolean flag: "true" means
		the interpretation is supported, false means it is not. 
	*/ 
	
	struct InterpretationSupport { 
		UniqueId plfId;
		string headNomVar;
		string depNomVar;
		string mode;
		boolean isSupported;
		sequence <string> LFids;		
	}; 

	/**
		The struct ContextInfo provides info about supported and unsupported interpretations for a given 
		packed logical form (by id). 
	*/ 

	struct ContextInfo { 
		UniqueId plfId; 
		sequence <InterpretationSupport> interpretations;
	}; // end ContextInfo

	//---------------------------------------------------------------------------
	// Speech output
	//---------------------------------------------------------------------------

	struct SpokenOutputItem { 
		UniqueId soiid;
		string phonString;
        any inputStream ;
	}; // end SpokenOutputItem 

	//---------------------------------------------------------------------------
	// Utterance planning and realization
	//---------------------------------------------------------------------------

	struct ContentPlanningGoal { 
		UniqueId cpgid;
		org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm lf;
	}; // end ProductionLF

	struct ProductionLF { 
		UniqueId plfid;
		org::cognitivesystems::repr::lf::autogen::LFEssentials::LogicalForm lf;
	}; // end ProductionLF

	//---------------------------------------------------------------------------
	// Abstract structs for Caching - i.e. multi-level representation
	//---------------------------------------------------------------------------

	/**	An index association relates two sequence of indices */ 
	struct IndexAssociation { 
		sequence<long> id1;
		sequence<long> id2;
		string relType ;
	} ;

	/**	A CacheMapping is a sequence of associations between indices.*/ 
	struct CacheMapping { 
		sequence<IndexAssociation> associations;
	} ; 


	/**
		A Cache is a pair of pointers to content representations (one of which is a set of graph structures
		from the packed logical form) , and a mapping between indices in these representations 
		to associate content. 
	*/ 

	struct Cache {
		string CacheId ;  			/** the cache identifier */
	    string cacheType ;			/** the type of the cache, as per the comsys ontology types */ 
		PackedLFs plf ;				/**  the packed logical form associated to the cache */
		sequence<any> content1 ;	/** a set of pointers (eg. discourse referents) */
		sequence<any> content2 ;	/** a set of pointers (eg. graph structures within the packed logical form) */
		CacheMapping mapping ;		/** mapping between the indices of the two representations */
	} ;


	//---------------------------------------------------------------------------
	// Structs for the discourse model representation
	//---------------------------------------------------------------------------
	
	
	/** SDRS formula representing a rhetorical relation */
	struct SDRSRelation {
		string relType ;			/** Relation type */
		sequence<string> args ;		/** Sequence of arguments - speech act discourse referents */
		boolean issubord ;			/** is subordinated */
	} ;
	
		
	/** IDL switch: a SDRS formula can store two (mutually exclusive)
	type of objects: a rhetorical relation, or a packed logical form */
	union SDRSType switch (short) {
		case 1: SDRSRelation relation ;
		case 2: PackedLFs plf ;
	} ;
		
	
	/** A SDRS formula */
	struct SDRSFormula {
		string label ;				/** Formula label */
		string tprec ;				/** Temporal precedence */
		sequence<Cache> caches ;		/** set of caches associated to the formula */
		SDRSType type ;				/** type of formula - either a rhetorical relation or a logical form */
	} ;
	
	
	/** <label,formula> pair */
	struct LabelFormulaPair {
		string label ;				/** the label */
		SDRSFormula formula ;		/** the formula */
	} ;
	
	
	/** Mapping between a label and a formula */
	struct LabelFormulaMapping {
		sequence<LabelFormulaPair> mapping ;
	} ;
		
		
	/** A SDRS - Segmented Discourse Representation Structure */
	struct SDRS {
		sequence<string> A ;			/** Set of speech act discourse referents */
		string LAST ; 					/** label of the content of the last clause  added to the LF */
		LabelFormulaMapping F ;			/** function assigning a SDRS-formula to each label in A */
	} ;
	
	
	
	//---------------------------------------------------------------------------
	// Structs for the spatio-temporal representation
	//---------------------------------------------------------------------------
	

	struct EventDiscRefRelation {
		string eventId;
		string discRefId;
		string mode;
	};
	
	struct Event {
		string eventId;
		string type;
		sequence<EventDiscRefRelation> participants;
	};
	
	struct StateDiscRefRelation {
		string stateId;
		string discRefId;
		string mode;
	};
	
	struct State {
		string stateId;
		string type;
		sequence<StateDiscRefRelation> participants;
	};
	
	struct AspectualRelation {
		string eventSourceId;
		string stateTargetId;
		string aspect;
	};
	
	
	struct TemporalRelation {
		string eventSourceId;
		string stateTargetId;
		string tempRelation;
	};
	
	struct Nucleus {
		string nucleusId;
		string plfId;
		Cache  discRefs;
		sequence<Event> events;
		sequence<State> states;
		sequence<AspectualRelation> aspectualRelations;
		sequence<TemporalRelation> temporalRelations;		
	};
	
	struct InterNucleusRelation {
		string sourceId;
		string targetId;
		string mode;
	};
	
	
	struct SpatioTemporalRepresentation {
		sequence<Nucleus> nuclei;
		sequence<InterNucleusRelation> interNucleusRelations;
		string currentNucleusId;
	};
	
	
	//---------------------------------------------------------------------------
	// Structs for the dialogue move interpretation
	//---------------------------------------------------------------------------
	
	enum MoveType {
		ASSERT,
		ACTION_DIRECTIVE,
		QUESTION_W,
		QUESTION_YN,
		OPENING,
		CLOSING,
		ACCEPT,
		REJECT
	};
	
	struct DialogueMove {
		string dmId;
		MoveType mType;
		string SDRSFormulaId1;
		string SDRSFormulaId2;
	};	

	//---------------------------------------------------------------------------
	// Structs for the generation of referring expressions (RefEx / GRE)
	//---------------------------------------------------------------------------
	
	struct GRETask {
		cast::cdl::WorkingMemoryPointer m_intendedReferentProxy;
		boolean m_done;
		string m_resultLF;
	};

}; // module
}; // module
}; // module
}; // module
}; // module
