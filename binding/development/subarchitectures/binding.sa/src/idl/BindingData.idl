#ifndef BINDING_DATA_IDL_
#define BINDING_DATA_IDL_

#include <CAST.idl>

/// module for IDLs related to binding, excluding the binding features
/// that are all in module \p BindingFeatures
module BindingData {

  /// String used to idenify the binding subarch in the configuration options
  const string BINDING_SUBARCH_CONFIG_KEY = "-bsa";

  /// String used to idenify the binding subarch in the configuration options
  const string BINDING_SUBARCH_NOCHECK_CONFIG_KEY = "--no-check";

  // String used to prefix particular pulls to the binding working memory.
  //const string NEW_BINDING_QUERY_PREFIX = "bd";
    
  /// The string used to construct a pull from binding wm looking for
  /// a proxy that points to the given address.
  const string  BINDING_QUERY_PREFIX_SOURCE_DATA = "bs";

  /// The string used to construct a pull from binding wm looking for
  /// proxies that match particular set of binding features.
  const string  FEATURE_SET_QUERY_PREFIX= "fs";
  
  /// A feature and its content, e.g. feature could be colour and
  /// "red" its value. See the \p BindingData::Feature namespace for
  /// more details
  struct FeaturePointer {
    /// Type of feature to which \p FeaturePointer is pointing
    /// through \p m_pointer
    cast::cdl::OntologyEntry m_type;
    /// Points to the feature data (storage in Binding WM is assumed)
    cast::cdl::WorkingMemoryID m_address;
    
    // points to the immediate proxy in which the feature is a
    // member. If this proxy is a group, then also the individual
    // proxies will have the same feature. (this is duplicated in all
    // features too, for technical reasons, hopefully we can get rid
    // of this later)
    cast::cdl::WorkingMemoryID m_immediateProxyID;
  };

  /// A sequence of \p FeaturePointer. Binding features describe
  /// proxies, and unions.
  typedef sequence <FeaturePointer> FeaturePointers;

  
  /// A structure used to indicate the a feature could be transferred
  /// from one binding element to another (e.g. to trigger learning)
  struct BindingFeatureTransfer {

    /// the feature to be propagated
    BindingData::FeaturePointer m_feature;
    /// an explicit reference to the ID of the binding SA. Used to
    /// make sure several binders can be run.
    cast::cdl::SubarchitectureID m_bindingSubarchitectureID;

    /// the proxy that should receive the feature
    cast::cdl::WorkingMemoryAddress m_target;

    /// the union that is the source of the feature
    cast::cdl::WorkingMemoryAddress m_source;

  };
    
  /// tells binding components that a feature and all its associated
  /// data should be deleted
  struct ExplicitFeatureDeletionTask {
    cast::cdl::WorkingMemoryID m_featureID;
  };

  /// tells binding components that a feature and all its associated
  /// data should be deleted
  struct BindingProxyDeletionTask {
    cast::cdl::WorkingMemoryID m_proxyID;
  };

  /// Used to list a number of binding WM entries
  typedef sequence <cast::cdl::WorkingMemoryID> WorkingMemoryIDList;
  
  /// a list of ontology entries
  typedef sequence <cast::cdl::OntologyEntry> OntologyEntries;

  
  /// the type of \p Port that a proxy may have to a relation 
  enum PortType {
    SIMPLE_RELATION, ///< a simple binary relation
    SPATIAL_RELATION,
    TEMPORAL_RELATION,
    PROXY ///< ports directly to an 'ordinary' proxy
  };

  /// The ports define how proxies are connected to other proxies
  /// (typically, or only, relations)
  struct ProxyPort {
    PortType m_type;
    /// should only be used by proxies that are of type RELATION, used
    /// to distinguis the different rentities the relation referes to
    /// (like 'from' and 'to' etc)
    string m_label;
    /// the id of the proxy to which the port leads
    cast::cdl::WorkingMemoryID m_proxyID;
    /// the id of the proxy or union in which the ports are originally
    /// defined. Used when forming unions ports so that duplicate
    /// ports can be avoided etc.
    cast::cdl::WorkingMemoryID m_ownerProxyID;
  };

  struct ProxyPorts {
    /// duplicate of the entries in the inports... just needed
    /// occasionally... especially when the binder deletes ports from
    /// unions.
    cast::cdl::WorkingMemoryID m_ownerProxyID;
    sequence<ProxyPort> m_ports;    
  };
  
  /// Only proxies of the same basic type can be bound
  enum BindingProxyType {
    BASIC,   ///< represents singular entities such as a room, a ball, a robot, a person, a location, an abstract concept etc
    GROUP,   ///< represents a group of one or more singular entities
    RELATION ///< represents a relation between any kind of proxies (including basic, group and other relations)
  };

  /// represents the state of the proxy is in the binding process
  enum BindingProxyState {
    NEW,         ///< the proxy has just been created by a monitor and is not yet processed
    UPDATED,     ///< the proxy has just been updated by a monitor and is not yet processed
    REPROCESSED, ///< the proxy was bound, but it is being reprocessed for some reason and may be rebound
    BOUND        ///< the proxy has been processed and is now bound
  };

  /// A proxy for the binding process. Generated from modality data
  /// in a particular working memory.
  struct BindingProxy {     
    /// Features stemming from modality data. If a feature is
    /// unknown, or simply not expressed in that modality, it should
    /// also not be included
    FeaturePointers m_proxyFeatures;
    /// contains a unique string based on all the feature
    /// pointer addresses. This string is used to make sure that any
    /// updates of a proxy gets noticed by the binder, even when the
    /// score changes.
    string m_featureSignature;
    /// If the proxy is member of an union (which it
    /// should be), then the id is represented in \p
    /// m_unionID. At creation, the ID is null (i.e. an
    /// empty string). Only the Binder updates the m_unionID when it
    /// binds.
    cast::cdl::WorkingMemoryID m_unionID;
    /// a shortcut to get the proxies with which this proxy is bound
    /// (observe that the proxy is bound to itself). This can just as
    /// easily be loaded via the union (via \p m_UnionID), but this is
    /// a nice shortcut.
    WorkingMemoryIDList m_proxyIDs;
    /// a shortcut to get the sourceID of the proxy (is also among the
    /// features, \p BindingFeatures::SourceID)
    cast::cdl::SubarchitectureID m_sourceID;

    

    /// points to the BestUnionsForProxy for this proxy,
    /// which includes the score etc.
    cast::cdl::WorkingMemoryID m_bestUnionsForProxyID;
    /// points to a list of nonmatching unions
    cast::cdl::WorkingMemoryID m_nonMatchingUnionID;

    /// the type of proxy
    BindingProxyType m_type;

    /// connects to other proxies in an ordered and strong manner. Can
    /// only be used by N-ary relation proxies. For example, a spatial
    /// relation has three outPorts 
    ProxyPorts m_outPorts;    
    /// connects to other proxies, for example if this proxy is part of
    /// a spatial relation, then the ID of the spatial relation proxy
    /// is found in the inPortsID. The inPorts are stored separately
    /// so that the addition of new relations onto binding WM does not
    /// require that the whole candidate needs to be updated.
    cast::cdl::WorkingMemoryID m_inPortsID;

    /// if set to true, then the proxy is going to be scored and all,
    /// but it will not be bound.
    boolean m_hypothetical;
    /// Number of times the binding has been updated
    long m_updates;
    /// Number of times the proxy has been bound
    long m_bindingCount;
    /// This is the most reliable way of determining if the proxy is bound or not.
    BindingProxyState m_proxyState;    
  };
  
  /// For proxy deletion. All features etc must be deleted.
  struct DeletedBindingProxy {
    BindingProxy m_deletedProxy;
    /// the ID of the now deleted proxy
    cast::cdl::WorkingMemoryID m_deletedProxyID;
  };
  
  /// After binding proxies and all relevant relations are written
  /// to the WM, then a BindTheseProxies object containing a list
  /// of all unbound proxies should be written to the WM.
  struct BindTheseProxies {
    /// the list of proxies that should be bound
    WorkingMemoryIDList m_proxyIDs;
  };
  
  
  /// BindingScore...
  struct BindingScore {
    boolean m_comparable;
    boolean m_mismatch;
    long m_matches;
    boolean m_relationMismatch;
    long m_relationMatches;
    // only used when binding to a union dedicated for this proxy alone (until sth else binds )
    long m_sticky;
    /// only used when several scores are equivalent, to make a decent guess...
    double m_salienceHeuristics; 
    /// the number of times the proxy had been updated when this score was
    /// was computed. 
    long m_proxyUpdatesWhenThisComputed;
    /// conventient for crosschecking etc
    cast::cdl::WorkingMemoryID m_proxyID;
    /// used to to know whether or not a proxy is updated with new features
    string m_proxyFeatureSignature;
    /// conventient for crosschecking etc
    cast::cdl::WorkingMemoryID m_unionID;
  };

  typedef sequence <BindingScore> BindingScoreList;
  
  /// A binding that represents a cross-subarchitecture(modal)
  /// object.   
  struct BindingUnion {
    
    /// References to the BindingProxies that are collected in this binding.
    WorkingMemoryIDList m_proxyIDs;
    
    /// matches the feature signatures of each proxy (same indexing as
    /// m_proxyIDs). If there is a msmatch after a proxy is updated,
    /// it means that the union needs to be updated.
    sequence<string> m_featureSignatures;


    /// Number of times the union has been updated
    long m_updates;
        
    /// Merged binding feature data. Non-conflicting data added.
    FeaturePointers m_unionFeatures;


    /// the type of proxies that are bound to this binding
    BindingProxyType m_type;

    /// connects to other unions (but via the proxies) in an
    /// ordered and strong manner. Can only be used by N-ary relation
    /// proxies. For example, a spatial relation has three outPorts
    ProxyPorts m_outPorts;
    
    /// connects to other proxies, for example if the proxy is part of
    /// a spatial relation, then the ID of the spatial relation proxy
    /// is found in the inPortsID. The inPorts are stored separately
    /// so that the addition of new relations onto binding WM does not
    /// require that the whole candidate needs to be updated.
    ProxyPorts m_inPorts;
  };  

  /// The result of testing if features are identical. This is only
  /// stored onto WM if the features cannot be evaluated internally in
  /// the binder.
  struct FeatureComparison {
    /// points to the feature of the proxy
    FeaturePointer m_proxyFeature;
    /// the proxy which this feature is a member of
    cast::cdl::WorkingMemoryID m_proxyID;
    /// points to the feature of the union
    FeaturePointer m_unionFeature;
    /// are the two features matching? true, indeterminate or
    /// false... We could use probability, degree of belief, fuzzy
    /// logics or rough sets, but a simple modal logic approach may be
    /// a good start.
    cast::cdl::TriBool m_featuresEquivalent;
    /// an explicit reference to the ID of the binding SA. Used to
    /// make sure several binders can be run. The comparators just
    /// need to write the results back into the right WM...
    cast::cdl::SubarchitectureID m_bindingSubarchitectureID;
    /// if set, external comparator should always write back result
    boolean m_insistOnExternalComparison;
  };
    
  /// Explicitly specifies that there is a feature scoring task for
  /// someone...
  struct FeatureComparisonTask {
    cast::cdl::WorkingMemoryID m_comparisonID;
    /// an explicit reference to the ID of the binding SA. Used to
    /// make sure several binders can be run.
    cast::cdl::SubarchitectureID m_bindingSubarchitectureID;
  };

  /// describes if the external comparator "trust" the internal
  /// comparator
  enum ComparisonTrust {
    TRUST_COMPLETELY,   ///< trust the internal comparator completely (i.e. no external task will be proposed)
    TRUST_BUT_VALIDATE, ///< trust internal comparator to generate a result, but insist on getting the external task too
    DONT_USE ///< don't trust the internal binder at all... i.e. don't use it (applicable also if no internal comparison exists)
  };
  
  /// determines the competence of the internal comparator
  /// w.r.t. true, false and indeterminate answers from it.
  struct ComparisonTrustSpecification{
    /// determines what to do if the internal comparison returns false
    ComparisonTrust m_trustInternalFalse;
    /// determines what to do if the internal comparison returns indeterminate
    ComparisonTrust m_trustInternalIndeterminate;
    /// determines what to do if the internal comparison returns true
    ComparisonTrust m_trustInternalTrue;
  };
  /// used to register the competence to perform comparisons of
  /// features
  struct FeatureComparisonCompetence {
    cast::cdl::OntologyEntry m_proxyFeatureType;
    cast::cdl::OntologyEntry m_unionFeatureType;
    ComparisonTrustSpecification m_comparisonTrustSpecification;
  };
  
  /// Used to answer queries that involve one feature, but require the
  /// answer through another, comparable feature.
  struct FeatureComparatorQuery {
    /// A known feature, from some proxy on the binder, e.g. a VisualColour
    FeaturePointer m_knownFeature;
    /// A set of features that are equivalent to the original
    /// feature. For example, if VisualColour = red, and the
    /// Comparator has the competence to compare VisualColour with
    /// Colour, it can perhaps infer that one Colour matches,
    /// e.g. 'red'. Another example is when the Reasoner generates all
    /// Concepts matching with "kitchen", e.g. "room" etc, to answer
    /// the question, "This is a kitchen.... Is this a room?". to The
    /// resulting features should be stored on the subarchitectureWM.
    FeaturePointers m_equivalentFeatures;
    /// specifies what bindingSA from which the question comes
    cast::cdl::SubarchitectureID m_bindingSubarchitectureID;
    /// set to false by the component that asks the question and to
    /// true when answered by the comparator.
    boolean m_answered;
  };
  
  /// The result of scoring a proxy vs a union. Each union is scored
  /// w.r.t. a proxy.
  struct ProxyUnionScore {
    cast::cdl::WorkingMemoryID m_proxyID;
    cast::cdl::WorkingMemoryID m_unionID;
    BindingScore m_score;
    
    /// to be true if the similarity of the feature sets of the
    /// proxy and binding is fully scored, and false if they have
    /// been updated and rescoring is needed.
    boolean m_updated;
  };

  /// Triggers the computation of a FeatureSetComparison by the
  /// BindingScorer
  struct ScoringTask {
    cast::cdl::WorkingMemoryID m_proxyUnionScoreID;
  };
  
  struct BindingTask {
    cast::cdl::WorkingMemoryID m_bestUnionsForProxyID;
  };

  /// this signals that a particular proxy has been bound, or does not
  /// need to be bound. The signal is used by the bindingscorer to
  /// know when to release the \p BinderToken
  struct ProxyProcessingFinished {
    /// the proxy in question
    cast::cdl::WorkingMemoryID m_proxyID;
  };
  
  /// The best unions for a proxy together with the score. This
  /// is what should trigger the binder to bind a proxy when it
  /// has been updated.
  struct BestUnionsForProxy {
    /// the proxy for which the result has been computed
    cast::cdl::WorkingMemoryID m_proxyID;
    /// used to to know whether or not a proxy is updated with new features
    string m_proxyFeatureSignature;
    /// the number of times the proxy had been updated when the
    /// best-list was computed. If it mismatches the proxy.m_updates
    /// at time of binding, then binding is aborted.
    long m_proxyUpdatesWhenThisComputed;
    /// the resulting best bindings to bind with. If the list is
    /// empty, it means that no binding was found. If the list has
    /// more than one item, it means that we have a disambiguation
    /// issue.
    WorkingMemoryIDList m_unionIDs;
    /// the score the binding vs. the proxy 
    BindingScore m_score;
  };
  
  struct NonMatchingUnions {
    /// the proxy for which the result has been computed
    cast::cdl::WorkingMemoryID m_proxyID;
    /// These unions do NOT match the proxy, updated when the \p
    /// BestUnionsForProxy
    WorkingMemoryIDList m_nonMatchingUnionIDs;
  };
  
  /// address to no binding, i.e. if nothing matched the proxy
  const string NO_UNION = "NIL";
  
  struct BinderStatus {
    /// should be true iff the binder is not performing any tasks and all proxies are bound
    boolean m_stable;
    /// number of currently executed scoring tasks
    long m_scoringTasks;
    /// number of currently executed binding tasks
    long m_bindingTasks;
    /// number of unbound proxies on WM (excluding hypothetical ones)
    long m_unboundProxies;
    /// number of bound proxies on WM (excluding hypothetical ones)
    long m_boundProxies;
  };

  //////////////////////////////////////////
  // disambiguation related stuff
  //////////////////////////////////////////

    
  /// Contains a set of instantiated features of different unions that
  /// could be used for disambiguation (see \p
  /// UnionDisambiguationIssue)
  struct DisambiguatingUnionFeatureInstance {
    FeaturePointers m_unionFeatures;
    OntologyEntries m_disambiguatingFeatureTypes;
  };

  /// ...
  typedef sequence <DisambiguatingUnionFeatureInstance> DisambiguatingUnionFeatureInstances;
  
  /// contains the description of an instance of a ambiguity
  /// in which one proxy matches equally well with several
  /// unions.
  struct Ambiguity {
    /// the proxy involved in the disambiguation issue
    cast::cdl::WorkingMemoryID m_proxyID;
    /// the unions involved in the disambiguation issue
    WorkingMemoryIDList m_unionIDs;
    /// Zero, one or more features that exist in the proxy, but not in
    /// the unions, and could help to disambiguate the unions
    /// w.r.t. the proxy.
    OntologyEntries m_missingUnionFeatures; // was m_disambiguatingProxyFeatureTypes
    /// Zero, one or more features that exist in the unions, but not
    /// in the proxy and could help to disambiguate between them.
    OntologyEntries m_missingProxyFeatures; // was m_disambiguatingUnionFeatureTypes
    /// Zero, one or more sets of instantiated features from the
    /// involved unions that would, if also instantiated (to one
    /// matching value) in the proxy, help to disambiguate. One
    /// example is if two unions are blue and red respectively, and
    /// the proxy has no colour info currently.
//    DisambiguatingUnionFeatureInstances m_disambiguatingUnionFeatureInstances;    
  };
  
/*  
  /// for question answering
  module CommunicativeGoals {
    
    
    enum CommandSort {
      Action,
      Motion
    };
    
    struct CommCommand {
      CommandSort m_csort;
      // cast::cdl::TriBool m_ack;
      BindingData::WorkingMemoryIDList m_actionProxyIDs;
    };
    
    
    enum QuestionSort {
      Polar,
      Factual
    };
    
    struct CommQuestion {
      QuestionSort m_qsort;
      // cast::cdl::TriBool m_answer;
      BindingData::WorkingMemoryIDList m_restrictedProxyIDs;
      BindingData::FeaturePointers m_featuresInQuestion;
    }; 
    
    
    enum AssertionSort {
      Attributive,
      Relational
    };
    
    struct CommAssertion {
      AssertionSort m_asort;
      // cast::cdl::TriBool m_ack;
    };
    
    enum CommunicativeGoalSort {
      Question, Assertion, Command
    };
    
    // since no inheritance is allowed,
    // we encapsulate all goals in one struct
    // this means that you first have to check
    // the sort and only then read the respective field!0
    
    struct CommunicativeGoal {
      CommunicativeGoalSort m_sort;
      
      CommQuestion m_question;
      CommAssertion m_assertion;
      CommCommand m_command;
      
      cast::cdl::TriBool m_answer;
    };
  };
*/
  
  /// when written to binding WM, the dotviewer gets triggered to write a dotfile. 
  /// \remark The \p BindingData::DotViewer removes the entry right away
  struct TriggerDotViewer {
    /// not used for anything
    boolean m_dummy;
  };

  /// when written to binding WM, the dotviewer gets triggered to write a dotfile with the specified title.
  /// \remark The \p BindingData::DotViewer removes the entry right away
  struct TriggerDotViewerWithTitle {
    string m_title;
  };

  /*!
  There will be one entry of this type per mutex operation. The
  monitor must have this locked in order to be allowed to perform
  certain operations.
  \msc
  hscale = "2.4";
*/
  struct MonitorToken {
    /// not used for anything
    boolean m_dummy;
  };

  // document the locks here
  //  YourMonitor,[URL = "\ref Binding::AbstractMonitor"],BindingSubarchitecture;
  //    --- [label="ready to start new proxy", ID="ready"];
  //    YourMonitor=>AbstractMonitor [label="startNewBasicProxy()", URL="\ref Binding::AbstractMonitor::startNewBasicProxy()", ID="1"];
  //    YourMonitor=>AbstractMonitor [label="addFeatureToCurrentProxy(FeatureType)", URL="\ref Binding::AbstractMonitor::addFeatureToCurrentProxy"];
  //    AbstractMonitor->BindingWorkingMemory [label="add feature"];
  //    YourMonitor<<AbstractMonitor [label="BindingData::FeaturePointer", URL="\ref BindingData::FeaturePointer"];
  //    ... [label = "Add any number of features from BindingData::Feature", URL="\ref BindingData::Feature", ID ="2"];
  //    YourMonitor=>AbstractMonitor [label="addFeatureToCurrentProxy(FeatureType)", URL="\ref Binding::AbstractMonitor::addFeatureToCurrentProxy"];
  //    AbstractMonitor->BindingWorkingMemory [label="add feature"];
  //    YourMonitor<<AbstractMonitor [label="BindingData::FeaturePointer", URL="\ref BindingData::FeaturePointer"];
  //    YourMonitor=>AbstractMonitor [label="storeCurrentProxy()", URL="\ref Binding::AbstractMonitor::storeCurrentProxy()"];
  //    AbstractMonitor->BindingWorkingMemory [label="add proxy", ID="3"];
  //    BindingWorkingMemory->broadcast [label="proxy added"];
  //    --- [label="ready to start new proxy", ID="ready"];
  //   \endmsc

  

  /// the WM ID for a token needed to write a \p BindTheseProxies to
  /// binding WM.   
  const string bindTheseProxiesMonitorTokenID = "BindThisProxiesMonitorToken";
  /// the WM ID for a token needed to update a \p BindingProxy to
  /// binding WM.   
  const string updateProxyMonitorTokenID = "UpdateProxyMonitorToken";
  
  
  /// There will be only one entry of this type which the monitor must
  /// have locked in order to be allowed to performed. Normally this
  /// entry will be locked by the binder. It should only be lock
  /// attempted once a specific task token is already given (e.g.
  /// "BindThisProxiesMonitorToken").
  struct BinderToken {
    /// not used for anything
    boolean m_dummy;
  };

  /// the WM ID of the \p BinderToken
  const string binderTokenID = "BinderToken";
  /// the WM ID of an internal \p BinderToken
  const string internalBindingTokenID = "InternalBindingToken";
  /// another token  needed...
  const string binderTokenTokenID = "BinderTokenToken";
  /// a token used to make certain lock/unlock sequences mutually exclusive
  const string binderLockTokenID = "BinderLockToken";

  /// used to signal the binding scorer that all is stable and
  /// well. The scorer can then release the BinderToken
//  struct YoScorerStatusIsNowStable {
    /// not used for anything
//    boolean m_dummy;
//  };

  
}; // BindingData

#endif // BINDING_DATA_IDL_
