#ifndef BINDING_QUERIES_IDL_
#define BINDING_QUERIES_IDL_

#include "BindingData.idl"

/// the module \p BindingQueries encapsulates all types of queries to
/// the bindingWM
module BindingQueries {    
  
  /// see detailed explanation in \p QueryParameters
  enum IncludeBoundProxies {
    INCLUDE_BOUND, ///< the bound proxies will be included when computing the answer to a query
    EXCLUDE_BOUND  ///< proxies will be treated in isoation
  };

  /// wraps parameters that are convenient for queries
  struct QueryParameters {
    /// if \p INCLUDE_BOUND, then the features of the union of the
    /// proxy will be used to generate an answer. That means, for
    /// example, that a colourless proxy could be considered "red" if
    /// it is bound to some proxy which is red.
    IncludeBoundProxies m_boundProxyInclusion;
  };

  /// A query that just results in a \p cast::cdl::TriBool. Adding the
  /// struct triggers the binder to answer it. An overwrite signals
  /// that it has been answered.
  /// \remark The client is responsoble for deleting the \p BasicQuery after receiving the results.
  /// \remark Obviously, the answer may be incorrect almost instantaneously since proxies and unions may get updated or removed at any time
  struct BasicQuery {
    /// contains parameters...
    QueryParameters m_parameters;
    /// refers to a proxy that the query is about. The answer will be based on the union of the proxy, however.
    cast::cdl::WorkingMemoryID m_proxyID;
    /// This should point to a feature stored on the bindingWM. Stored
    /// there only for the purpose of generating an answer to the
    /// query (it'll be removed by the binder as soon as it is
    /// answered, so keep it locally if you want to keep track of what
    /// your query was
    /// about). 
    /// \remark \p BindingFeaturesCommon::ParentFeature::m_immediateProxyID must be an empty string!
    BindingData::FeaturePointer m_featurePointer;
    /// The result of the query. As soon as the BasicQuery is
    /// answered, it will be overwritten, and then m_answer contains
    /// the correct answer. The result is indeterminate if the feature
    /// or proxy could not be found.
    cast::cdl::TriBool m_answer;
    /// is true after the answer has been processed by the binder. When the query is created, it should be set to false.
    boolean m_processed;
  };
  
  /// a query that returns a set of proxy and union IDs that has, or
  /// haven't got matching feature
  /// \remark The client is responsoble for deleting the \p BasicQuery after receiving the results.
  /// \remark Obviously, the answer may be incorrect almost instantaneously since proxies and unions may get updated or removed at any time
  struct AdvancedQuery {
    /// contains parameters...
    QueryParameters m_parameters;
    /// This should point to a feature stored on the bindingWM. Stored
    /// there only for the purpose of generating an answer to the
    /// query (it'll be removed by the binder as soon as it is
    /// answered, so keep it locally if you want to keep track of what
    /// your query was
    /// about). 
    /// If you keep the \p
    /// BindingData::FeaturePointer::m_address-field empty, then only
    /// the \p m_hasTheFeatureProxyIDs and \p m_hasTheFeatureUnionIDs
    /// are updated 
    /// \remark \p
    /// BindingFeaturesCommon::ParentFeature::m_immediateProxyID must
    /// be an empty string!
    BindingData::FeaturePointer m_featurePointer;
    /// proxies that has the feature, matching or nonmatching doesn't matter
    BindingData::WorkingMemoryIDList m_hasTheFeatureProxyIDs;
    /// unions that has the feature, matching or nonmatching doesn't matter
    BindingData::WorkingMemoryIDList m_hasTheFeatureUnionIDs;
    /// proxies that have the feature, and it matches
    BindingData::WorkingMemoryIDList m_matchingProxyIDs;
    /// unions that have the feature, and it matches
    BindingData::WorkingMemoryIDList m_matchingUnionIDs;
    /// proxies that have the feature, and it does not match
    BindingData::WorkingMemoryIDList m_nonMatchingProxyIDs;
    /// unions that have the feature, and it does not match
    BindingData::WorkingMemoryIDList m_nonMatchingUnionIDs;    
    /// is true after the answer has been processed by the binder. When the query is created, it should be set to false.
    boolean m_processed;
  };


  ///A request written by a component to add a new feature to an
  ///existing proxy.
  struct FeatureRequest {
    ///A description of the request in the query format
    BasicQuery m_request;
    ///the sa that generated  the req
    cast::cdl::SubarchitectureID m_fromSA;
  };

  ///An assertion written by a component to describe a feature of an
  ///existing proxy.
  struct FeatureAssertion {
    ///A description of the request in the query format
    BasicQuery m_assertion;
    ///the sa that is providing the information
    cast::cdl::SubarchitectureID m_fromSA;
  };


  ///A struct for registering the competence to generate a feature
  struct FeatureGenerationRegistration {
    /// Type of feature which can be generated
    cast::cdl::OntologyEntry m_type;
    /// The subarchitecture where the feature will be created
    cast::cdl::SubarchitectureID m_subarchitecture;
  };

  
  /// a request to make a proxy unavailable
  struct MakeProxyUnavailable {
    /// the proxy that should be made unavailable
    cast::cdl::WorkingMemoryID m_proxyID;
  };
  
//  typedef sequence<MakeProxyUnavailable> MakeProxyUnavailableSequence;
//  
//  /// A struct which requests that a set of proxies should be deleted
//  /// by the owner monitors
//  struct MakeProxiesUnavailable {
//    MakeProxyUnavailableSequence m_proxies;
//  };

}; // module BindingQueries

#endif // BINDING_QUERIES_IDL_
