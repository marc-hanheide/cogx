/**
 * 
 */
package binding.monitors.examples;

import java.util.Properties;

import binding.abstr.AbstractMonitor;
import binding.autogen.BindingData.BindingProxy;
import binding.autogen.BindingData.BindingUnion;
import binding.autogen.BindingFeatures.Concept;
import binding.common.BindingComponentException;
import binding.ontology.BindingOntologyFactory;
import binding.util.ProxyMonitor;
import binding.util.ProxyMonitorCallback;
import cast.architecture.subarchitecture.SubarchitectureProcessException;
import cast.core.data.CASTData;

/**
 * @author nah
 * 
 */
public class WaitExample extends AbstractMonitor {

    public Object m_lockObject;

    /**
         * @param _id
         */
    public WaitExample(String _id) {
	super(_id);
	setOntology(BindingOntologyFactory.getOntology());
    }

    /*
         * (non-Javadoc)
         * 
         * @see binding.abstr.AbstractMonitor#configure(java.util.Properties)
         */
    @Override
    public void configure(Properties _config) {
	super.configure(_config);
	m_sourceID = m_subarchitectureID;
	setBindingSA(m_subarchitectureID);
    }

    /*
         * (non-Javadoc)
         * 
         * @see cast.architecture.subarchitecture.ManagedProcess#taskAdopted(java.lang.String)
         */
    @Override
    protected void taskAdopted(String _taskID) {

    }

    /*
         * (non-Javadoc)
         * 
         * @see cast.architecture.subarchitecture.ManagedProcess#taskRejected(java.lang.String)
         */
    @Override
    protected void taskRejected(String _taskID) {

    }

    private class NotifyOnRebindCallback implements ProxyMonitorCallback {

	/**
         * @param _lockObject
         */
	public NotifyOnRebindCallback(Object _lockObject) {
	    m_lockObject = _lockObject;
	}

	/**
         * Called when our proxy is rebound, including the very first rebinding
         */
	public void bindingEvent(CASTData<BindingProxy> _proxy,
		CASTData<BindingUnion> _union, ProxyMonitor _pm) {

	    try {
		println("rebind callback, notifying all waiting threads");

		// get lock ownership
		synchronized (m_lockObject) {
		    m_lockObject.notifyAll();
		}

		// ok we no longer care about events
		_pm.remove();
	    } catch (SubarchitectureProcessException e) {
		e.printStackTrace();
		System.exit(1);
	    }
	}

    }

    /*
         * (non-Javadoc)
         * 
         * @see cast.architecture.subarchitecture.ManagedProcess#runComponent()
         */
    @Override
    protected void runComponent() {

	// this is my generic doing some processing on a proxy method

	try {
	    // step one, create my proxy
	    startNewBasicProxy();
	    addSourceIDToCurrentProxy();
	    Concept con = new Concept("fakey wakey", false, "");
	    addFeatureToCurrentProxy(con);
	    String proxyID = storeCurrentProxy();

	    // IMPORTANT add the monitor before triggering binding
	    // this static method creates the monitor AND adds it as a
	    // change filter
	    ProxyMonitor monitor = ProxyMonitor.newProxyMonitor(this, proxyID);

	    // create an object that we will use to sync with
	    Object lockObject = new Object();
	    // now lets register a callback that calls notify on this object
	    monitor.registerRebindCallback(new NotifyOnRebindCallback(
		    lockObject));

	    // now get things bound up
	    bindNewProxies();

	    // and now we wait

	    // IMPORTANT to avoid nasty timing issues, always check the
	    // condition before and after waiting

	    //

	    // NOTE if you want to be triggered on conditions, then
	    // you'll need to work them in here too

	    while (!monitor.proxyIsBound()) {
		println("waiting for binding");
		// get monitor ownership
		synchronized (lockObject) {
		    lockObject.wait();
		}
		println("waiting is over... time for a beer");
	    }

	} catch (BindingComponentException e) {
	    e.printStackTrace();
	    System.exit(1);
	} catch (SubarchitectureProcessException e) {
	    e.printStackTrace();
	    System.exit(1);
	} catch (InterruptedException e) {
	    e.printStackTrace();
	    System.exit(1);
	}

    }
}
