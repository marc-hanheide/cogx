package Planner;


/**
* Planner/PlannerServerPOATie.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from Planner.idl
* Freitag, 13. MŠrz 2009 17.31 Uhr CET
*/


/* The PlannerServer provides the external interface with the
	   planner and monitoring components.  Additionally, it provides
	   methods for storing and querying plan memories,
	   i.e. histories of plan execution and plan changes.
	*/
public class PlannerServerPOATie extends PlannerServerPOA
{

  // Constructors

  public PlannerServerPOATie ( Planner.PlannerServerOperations delegate ) {
      this._impl = delegate;
  }
  public PlannerServerPOATie ( Planner.PlannerServerOperations delegate , org.omg.PortableServer.POA poa ) {
      this._impl = delegate;
      this._poa      = poa;
  }
  public Planner.PlannerServerOperations _delegate() {
      return this._impl;
  }
  public void _delegate (Planner.PlannerServerOperations delegate ) {
      this._impl = delegate;
  }
  public org.omg.PortableServer.POA _default_POA() {
      if(_poa != null) {
          return _poa;
      }
      else {
          return super._default_POA();
      }
  }

  /* Register a new task with the planner.
  		   Side effect: sets a unique TaskID for that task */
  public void new_task (Planner.PlanningTaskHolder task)
  {
    _impl.new_task(task);
  } // new_task


  /* Load a MAPL task, convert it to a PlanningTask as specified
  		   here, and register it with the planner */
  public Planner.PlanningTask load_mapl_task (String task_fn, String domain_fn, String planning_agent)
  {
    return _impl.load_mapl_task(task_fn, domain_fn, planning_agent);
  } // load_mapl_task


  /* change task data during the continual planning process.
  		   clear_first==False means that unchanged data is kept, whereas
  		   clear_first==True will delete all old info first. */
  public void change_task (Planner.PlanningTask task, boolean clear_first)
  {
    _impl.change_task(task, clear_first);
  } // change_task


  /* returns the task as stored by the planner */
  public Planner.PlanningTask current_task_state (String task_id)
  {
    return _impl.current_task_state(task_id);
  } // current_task_state


  /* Checks if current plan is still valid and, if not, replans.
  		   This more or less hides the whole planning and monitoring
  		   process.  Returns information about the results and the state of
  		   the CCP algorithm. */
  public Planner.CCPState continual_planning (String task_id) throws Planner.Failure
  {
    return _impl.continual_planning(task_id);
  } // continual_planning


  //SimplePOPlan current_plan(in TaskID task_id);
  public Planner.Command[] next_executable_plan_steps (String task_id)
  {
    return _impl.next_executable_plan_steps(task_id);
  } // next_executable_plan_steps

  public Planner.Fact[] expected_changes (String task_id, Planner.Command cmd)
  {
    return _impl.expected_changes(task_id, cmd);
  } // expected_changes


  //CommandSeq get_execution_history(in TaskID task_id);
  public void command_was_executed (String task_id, Planner.Command cmd, boolean success)
  {
    _impl.command_was_executed(task_id, cmd, success);
  } // command_was_executed


  // expected value
  public void negative_sensing (String task_id, Planner.GroundAction sensing_action)
  {
    _impl.negative_sensing(task_id, sensing_action);
  } // negative_sensing


  // Do a test of all functionality with some sample input.
  public void self_test ()
  {
    _impl.self_test();
  } // self_test


  // Shut down the planner server
  public void kill_me ()
  {
    _impl.kill_me();
  } // kill_me

  private Planner.PlannerServerOperations _impl;
  private org.omg.PortableServer.POA _poa;

} // class PlannerServerPOATie
