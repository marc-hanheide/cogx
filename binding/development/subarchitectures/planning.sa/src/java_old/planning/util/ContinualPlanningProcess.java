/**
 * 
 */
package planning.util;

import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Properties;

import org.omg.CORBA.ORB;

import planning.autogen.Planner.Failure;
import planning.autogen.Planner.MonitorOutput;
import planning.autogen.Planner.ObjectDeclaration;
import planning.autogen.Planner.PlannerServer;
import planning.autogen.Planner.PlanningTask;
import planning.autogen.Planner.SimplePOPlan;
import planning.autogen.PlanningData.PlanningState;
import balt.corba.impl.RemoteConnectionManager;

/**
 * This is an object that wraps up planner interactions into a slightly less
 * strange interface! Just creat a new one each time a plan is created and
 * executed.
 * 
 * @author nah
 */
public class ContinualPlanningProcess {

	private SimplePOPlan m_currentPlan;

	private String m_currentPMID;

	private MonitorOutput m_currentValidation;

	private SimplePOPlan m_emptyPlan = new SimplePOPlan(new String[0],
			new short[0][0]);

	private boolean m_goalAchieved;

	private boolean m_log;

	private String m_nextStep;

	private PlannerServer m_planner;

	// the current planning task
	private PlanningTask m_planningTask;

	// HACK
	private short m_planTime = 0;

	private LinkedList<PlanningState> m_stateList;

	/**
	 * @param _string
	 */
	public ContinualPlanningProcess(String _string) {
		this(_string, false);
	}

	/**
	 * @param The
	 *            MAPL domain file to use for all operations in this process;
	 */
	public ContinualPlanningProcess(String _domain, boolean _log) {
		m_log = _log;
		m_stateList = new LinkedList<PlanningState>();

		m_planner = PlannerServerFactory.getPlannerServer();
		m_currentValidation = null;

		m_planningTask = new PlanningTask();
		m_planningTask.goal = null;
		m_planningTask.domain_fn = verify(_domain);
		// m_planningTask.facts = new String[0];
		// m_planningTask.objects = new ObjectDeclaration[0];

		log("domain set to: " + m_planningTask.domain_fn);
	}

	/**
	 * Get the state currently expected by the CPP.
	 * 
	 * @return The last state generated by stepTaken, or the initial state if no
	 *         execution has taken place.
	 */
	public PlanningState getCurrentState() {
		if (m_stateList.isEmpty()) {
			throw new RuntimeException(
					"No intial state. Ensure setInitialState is called first.");
		}
		return m_stateList.getLast();
	}

	/**
	 * Get the next step to take from the plan.
	 * 
	 * @return The next step.
	 */
	public String getNextStep() {
		return m_nextStep;
	}

	/**
	 * Get a plan to achieve the goal from the current state. If a plan has
	 * already been created for the state then it is returned, otherwise a new
	 * one is created then returned.
	 * 
	 * @return
	 * @throws Failure
	 */
	public SimplePOPlan getPlan() throws Failure {

		if (m_stateList.isEmpty()) {
			throw new RuntimeException(
					"No intial state. Ensure setInitialState is called first.");
		}
		if (m_planningTask.goal == null) {
			throw new RuntimeException(
					"No goal set. Ensure setGoal is called first.");
		}

		// log("getPlan: setting up planning task");

		// copy stored state into input struct
		stateToPlanningTask();

		log("getPlan: aiming for goal" + m_planningTask.goal);
		// register the task
		m_currentPMID = m_planner.new_task(m_planningTask);
		// get the plan
		m_currentPlan = m_planner.find_plan(m_planningTask);
		m_planner.add_plan(m_currentPMID, m_currentPlan);

		// m_currentPlan = m_planner.current_plan(m_currentPMID);
		// log("getplan: got current_plan()");

		// m_planner.update_planning_memory(m_currentPMID, m_currentPlan,
		// m_stateList.getLast().m_objects, m_stateList.getLast().m_facts,
		// m_planningTask.goal, m_planningTask.domain_fn);
		// log("Survived updatePM()");

		// store the next step of the plan
		updateNextStep();
		// log("getplan: survived updateNextStep()");

		// also update monitor list
		updateMonitoringStatus();
		return m_currentPlan;
	}

	/**
	 * Does the current state satisfy the goal state?
	 * 
	 * @return True if it does.
	 */
	public boolean goalAchieved() {
		return m_goalAchieved;
	}

	/**
	 * Does the current plan achieve the goal?
	 * 
	 * @return True if it does.
	 */
	public boolean planAchievesGoal() {
		return m_currentValidation.goal_achieved;
	}

	/**
	 * Is the current plan executable?
	 * 
	 * @return True if it is.
	 */
	public boolean planIsExecutable() {
		return m_currentValidation.executable;
	}

	/*
	 * Informs execution monitoring of the current state of the world.
	 */
	public void setCurrentState(PlanningState _state) throws Failure {
		if (m_stateList.isEmpty()) {
			setInitialState(_state);
		} else {
			m_stateList.add(_state);
			updateMonitoringStatus();
		}
	}

	/**
	 * @param _goal
	 */
	public void setGoal(String _goal) {
		m_planningTask.goal = _goal;
	}

	/**
	 * Set the current state of the world, all operations are performed relative
	 * to this
	 * 
	 * @param _planningState
	 */
	public void setInitialState(PlanningState _planningState) {
		// log("setInitialState()");
		m_stateList.add(_planningState);
		// log("setCurrentState:\n" + PlanningUtils.toString(_planningState));
	}

	/**
	 * Inform the CPP that a step has been taken in the plan.
	 * 
	 * @return The state expected to result from this.
	 * @throws Failure
	 */
	public PlanningState stepTaken(String _step) throws Failure {

		if (m_currentPMID == null) {
			throw new RuntimeException(
					"no current plan being monitored, ensure getPlan() is used first");
		}

//		log("stepTaken: advancing using step: " + _step);
		// move the plan forward
		m_planner.advance(m_currentPMID, _step, m_planTime++);

		// and save locally so monitoring etc. works
		m_currentPlan = m_planner.current_plan(m_currentPMID);

		// nah: don't do this any more, because it breaks the link to the states
		// coming from subarchitectures
		//
		// create a new state on the list containing the objects from
		// the last step (nah: do we really need to store these in the
		// stack?), and the contents of the state resulting from
		// executing the given step
		// m_stateList.add(new PlanningState(m_stateList.getLast().m_objects,
		// m_planner.current_state_estimation(m_currentPMID)));

		// store the next step of the plan
		updateNextStep();

		// nah: don't do this any more... it's not really in the contract
		//
		// also update monitor list
		// updateMonitoringStatus();

		return m_stateList.getLast();
	}

	/**
	 * @throws Failure
	 */
	private void checkGoalAcheived() throws Failure {
		// log("m_planner.goal_achieved: "
		// + PlanningUtils.toString(m_stateList.getLast()) + " " +
		// m_planningTask.goal);

		// log("checkGoalAcheived(): "+ Arrays.toString(m_currentPlan.nodes) + "
		// " + m_currentValidation.executable + " "
		// + m_currentValidation.goal_achieved);

		// m_goalAchieved = m_planner.monitor_plan(m_emptyPlan,
		// m_planningTask).goal_achieved;
		m_goalAchieved = (m_currentPlan.nodes.length == 0)
				&& (m_currentValidation.goal_achieved);
		// System.out.println("checkGoalAcheived(): " + m_goalAchieved);
	}

	/**
	 * @throws Failure
	 */
	private void checkPlanValid() throws Failure {
		// double check state is in place
		stateToPlanningTask();
		m_currentValidation = m_planner.monitor_plan(m_currentPlan,
				m_planningTask);
//		log("checkPlanValid(): " + Arrays.toString(m_currentPlan.nodes) + " "
//				+ m_currentValidation.executable + " "
//				+ m_currentValidation.goal_achieved);
	}

	private void log(Object _o) {
		if (m_log) {
			System.out.println("[LOG CPP: " + _o + "]");
		}
	}

	/**
	 * Copies the current state information into the planning task struct for
	 * communication with the planner.
	 * 
	 */
	private void stateToPlanningTask() {

		assert !m_stateList.isEmpty() : "must have a state before copying";

		PlanningState lastState = m_stateList.getLast();
		int factLen = lastState.m_facts.length;
		m_planningTask.facts = new String[factLen];

		int objsLen = lastState.m_objects.length;
		m_planningTask.objects = new ObjectDeclaration[objsLen];

		// System.out.println("CPP: stateToPlanningTask: last state size "
		// + factLen + " " + objsLen);
		// for (String s : lastState.m_facts) {
		// System.out.println("lastState fact: " + s);
		// }
		// for (ObjectDeclaration d : lastState.m_objects) {
		// System.out.println("lastState object: " + d.name + " " + d.type);
		// }

		System
				.arraycopy(lastState.m_facts, 0, m_planningTask.facts, 0,
						factLen);
		// log("stateToPlanningTask: copied facts: "
		// + Arrays.toString(m_planningTask.facts));

		System.arraycopy(lastState.m_objects, 0, m_planningTask.objects, 0,
				objsLen);

		// log("stateToPlanningTask: copied objects: ");
		// for (ObjectDeclaration d : m_planningTask.objects) {
		// System.out.println("m_planningTask object: " + d.name + " "
		// + d.type);
		// }

	}

	/**
	 * @throws Failure
	 */
	private void updateMonitoringStatus() throws Failure {
//		log("updateMonitoringStatus()");
		checkPlanValid();
		checkGoalAcheived();
	}

	/**
	 * 
	 */
	private void updateNextStep() {

		System.out.println("CPP: updateNextStep: current pmid: "
				+ m_currentPMID);

		// TODO something smart with all options
		String[] steps = m_planner.possible_next_steps(m_currentPMID);

		// System.out.println("CPP: updateNextStep: steplength= " +
		// steps.length);
		// for (int i = 0; i < steps.length; ++i) {
		// log(" step: " + steps[i]);
		// }

		if (steps.length > 0) {
			m_nextStep = steps[0];
		} else {
			m_nextStep = null;
		}
	}

	/**
	 * @param _domain
	 */
	private String verify(String _domain) {
		File f = new File(_domain);
		if (f.exists()) {
			try {
				return f.getCanonicalPath();
			} catch (IOException e) {
				throw new RuntimeException("Unable to find planning domain: "
						+ _domain, e);
			}
		} else {
			throw new RuntimeException("Unable to find planning domain: "
					+ _domain);
		}
	}

	/**
	 * @param args
	 * @throws Failure
	 */
	public static void main(String[] args) throws Failure {
		// Setup the ugly CORBA bits
		Properties props = new Properties();
		props.put("org.omg.CORBA.ORBInitialPort", "1050");
		props.put("org.omg.CORBA.ORBInitialHost", "localhost");
		// initialise orb
		ORB.init(new String[] {}, props);
		// initialise balt
		RemoteConnectionManager.init(new String[] {}, props);

		// tell the planner server where the server executable is
		PlannerServerFactory
				.setPlannerExecutablePath("./subarchitectures/planning.sa/src/python/mapsim/planning/server.py");

		// server.self_test();
		// System.out.println("self_test done");

		// ContinualPlanningProcess cpp = setupClarificationProblem();
		// ContinualPlanningProcess cpp = setupGridProblem();
		// ContinualPlanningProcess cpp = setupMGridProblem();
		ContinualPlanningProcess cpp = setupVisRegionProblem();
		// ContinualPlanningProcess cpp = setupPlaymateProblem();
		System.out.println("plan: " + Arrays.toString(cpp.getPlan().nodes));

		// System.exit(1);

		// tum te tum, could run forever
		while (true) {

			System.out.println("Current state: "
					+ Arrays.toString(cpp.getCurrentState().m_facts));

			boolean goalAchieved = cpp.goalAchieved();
			if (goalAchieved) {
				System.out.println("Goal Achieved!");
				break;
			} else if (!cpp.planAchievesGoal()) {
				System.out.println("Plan no longer achieves goal!");
				break;
			} else if (!cpp.planIsExecutable()) {
				System.out.println("Plan no longer executable!");
				break;
			}

			String nextStep = cpp.getNextStep();
			System.out.println("taking step: " + nextStep);
			cpp.stepTaken(nextStep);
		}

		// normal users wouldn't usually do this
		PlannerServerFactory.shutdown();
	}

	public static ContinualPlanningProcess setupClarificationProblem() {
		// try a grid world problem... this is from the mapsim code
		ObjectDeclaration objects[] = {
				new ObjectDeclaration("MrChips", "agent"),
				new ObjectDeclaration("Michael", "agent"),
				new ObjectDeclaration("MrChips", "planning_agent"),
				new ObjectDeclaration("vp1", "vision_proxy"),
				new ObjectDeclaration("vp2", "vision_proxy"),
				new ObjectDeclaration("vp3", "vision_proxy"),
				new ObjectDeclaration("lp1", "language_proxy") };

		String[] facts = { "in_feature_domain red colour",
				"in_feature_domain blue colour",
				"in_feature_domain green colour",
				"in_feature_domain mug object_class",
				"has_access_to_modality Michael vision",
				"has_access_to_modality Michael language",
				"has_access_to_modality vision_sa vision",
				"has_access_to_modality vp1 vision",
				"distinctive_feature colour vp1",
				"distinctive_feature object_class vp1",
				"kd__feature_val vision_sa colour vp1",
				"kd__feature_val vision_sa object_class vp1",
				"in_binding_candidates vp1 lp1",
				"has_access_to_modality vp2 vision",
				"distinctive_feature colour vp2",
				"distinctive_feature object_class vp2",
				"kd__feature_val vision_sa colour vp2",
				"kd__feature_val vision_sa object_class vp2",
				"in_binding_candidates vp2 lp1",
				"has_access_to_modality vp3 vision",
				"distinctive_feature colour vp3",
				"distinctive_feature object_class vp3",
				"kd__feature_val vision_sa colour vp3",
				"kd__feature_val vision_sa object_class vp3",
				"in_binding_candidates vp3 lp1",
				"has_access_to_modality lp1 language",
				"distinctive_feature colour lp1",
				"distinctive_feature object_class lp1",
				"kd__feature_val Michael colour lp1",
				"kd__feature_val Michael object_class lp1",
				"feature_val object_class vp1 : mug",
				"feature_val object_class vp2 : mug",
				"feature_val object_class vp3 : mug",
				"feature_val object_class lp1 : mug",
				"feature_val colour lp1 : blue" };

		String goal = "(exists (?p - binding_proxy) (is_bound lp1 ?p))";
		String domainFile = "./subarchitectures/planning.sa/src/python/mapsim/domains/clarification/mapl_files/domain.mapl";

		ContinualPlanningProcess cpp = new ContinualPlanningProcess(domainFile,
				true);
		cpp.setInitialState(new PlanningState(objects, facts));
		cpp.setGoal(goal);
		return cpp;
	}

	public static ContinualPlanningProcess setupGridProblem() {
		// try a grid world problem... this is from the mapsim code
		ObjectDeclaration objects[] = {
				new ObjectDeclaration("c11", "gridcell"),
				new ObjectDeclaration("c00", "gridcell"),
				new ObjectDeclaration("agt0", "gridcontent"),
				new ObjectDeclaration("c01", "gridcell"),
				new ObjectDeclaration("c10", "gridcell"),
				new ObjectDeclaration("agt0", "planning_agent") };

		String[] facts = { "connected c00 c01", "connected c00 c10",
				"connected c01 c00", "connected c01 c11", "connected c10 c00",
				"connected c10 c11", "connected c11 c01", "connected c11 c10",

				// ;; dynamic facts
				"occupant c00 empty", "occupant c01 empty",
				"occupant c10 empty", "occupant c11 agt0", };

		String goal = "(and (occupant c00 agt0))";
		String domainFile = "./subarchitectures/planning.sa/src/python/mapsim/domains/gridworld/mapl_files/gridworld-static-domain.mapl";

		ContinualPlanningProcess cpp = new ContinualPlanningProcess(domainFile,
				true);
		cpp.setInitialState(new PlanningState(objects, facts));
		cpp.setGoal(goal);
		return cpp;
	}

	public static ContinualPlanningProcess setupMGridProblem() {
		// try a grid world problem... this is from the mapsim code
		ObjectDeclaration objects[] = {
				// A 3X3 grid world...
				new ObjectDeclaration("c0", "gridcell"),
				new ObjectDeclaration("c1", "gridcell"),
				new ObjectDeclaration("c2", "gridcell"),
				new ObjectDeclaration("c3", "gridcell"),
				new ObjectDeclaration("c4", "gridcell"),
				new ObjectDeclaration("c5", "gridcell"),
				new ObjectDeclaration("c6", "gridcell"),
				new ObjectDeclaration("c7", "gridcell"),
				new ObjectDeclaration("c8", "gridcell"),
				// Then some agents as well..
				new ObjectDeclaration("agt0", "gridcontent"),
				new ObjectDeclaration("agt1", "gridcontent"),
				new ObjectDeclaration("agt0", "planning_agent"),
				new ObjectDeclaration("agt1", "planning_agent") };

		String[] facts = {
				// Establish the connectivity between the different cells...
				"connected c0 c1", "connected c0 c3", "connected c1 c0",
				"connected c1 c2", "connected c1 c4", "connected c2 c1",
				"connected c2 c5", "connected c3 c0",
				"connected c3 c4",
				"connected c3 c6",
				"connected c4 c1",
				"connected c4 c3",
				"connected c4 c5",
				"connected c4 c7",
				"connected c5 c2",
				"connected c5 c4",
				"connected c5 c8",
				"connected c6 c3",
				"connected c6 c7",
				"connected c7 c4",
				"connected c7 c6",
				"connected c7 c8",
				"connected c8 c5",
				"connected c8 c7",

				// Facts about the world that could change over time (well
				// the obstacles cannot be moved but anyway it makes sense
				// to leave it here to give an initial picture of the
				// world...
				"occupant c0 empty", "occupant c1 obstacle",
				"occupant c2 agt1", "occupant c3 empty", "occupant c4 empty",
				"occupant c5 empty", "occupant c6 agt0",
				"occupant c7 obstacle", "occupant c8 empty", };

		String goal = "(and ( occupant c2 agt0 ) ( occupant c6 agt1 ) )";
		String domainFile = "./subarchitectures/planning.sa/src/python/mapsim/domains/gridworld/mapl_files/gridworld-static-domain.mapl";

		ContinualPlanningProcess cpp = new ContinualPlanningProcess(domainFile,
				true);
		cpp.setInitialState(new PlanningState(objects, facts));
		cpp.setGoal(goal);
		return cpp;
	}

	/**
	 * Mohan: And while we are at it, we may as well get started on the problem
	 * with visual regions and their associated planning...
	 */
	public static ContinualPlanningProcess setupVisRegionProblem() {
		ObjectDeclaration objects[] = {
				// Let us also have three visual regions...
				new ObjectDeclaration("vr0", "visRegion"),
				new ObjectDeclaration("vr1", "visRegion"),
				new ObjectDeclaration("vr2", "visRegion") };

		String[] facts = {
				// Color properties of the regions...
				"colorProp-val vr0 red",
				"colorProp-val vr1 blue",
				"colorProp-val vr2 blue",
				// Sift properties of the regions...
				"objectType-val vr0 picture", "objectType-val vr1 mug",
				"objectType-val vr2 cuboid",
				// Shape properties of the regions...
				"shapeProp-val vr0 circular", "shapeProp-val vr1 circular",
				"shapeProp-val vr2 squared", };

		String goal = "(and (exists (?vr - visRegion) (and ( colorProp-val ?vr blue ) ( containsObject ?vr mug ) ( containsShape ?vr circular ) ) ) )";

		String domainFile = "./subarchitectures/planning.sa/src/python/mapsim/domains/blocksworld/mapl_files/blocksworld-domain.mapl";

		ContinualPlanningProcess cpp = new ContinualPlanningProcess(domainFile,
				true);
		cpp.setInitialState(new PlanningState(objects, facts));
		cpp.setGoal(goal);
		return cpp;
	}

	/**
	 * @return
	 */
	private static ContinualPlanningProcess setupPlaymateProblem() {
		// try a grid world problem... this is from the mapsim code
		ObjectDeclaration objects[] = {
				new ObjectDeclaration("proxyd", "waypoint"),
				new ObjectDeclaration("proxyA", "waypoint"),
				new ObjectDeclaration("proxyK", "thing"),
				new ObjectDeclaration("proxyT", "waypoint"),
				new ObjectDeclaration("proxy0", "thing") };

		String[] facts = { "pos proxyK proxyT", "pos proxy0 proxyA",

		// "near proxyA proxyT", "near proxyT proxyA",

				"near proxyA proxyd", "near proxyd proxyA",

				"colour proxy0 blue", "colour proxyK red",

		};

		// red things near blue thing
		// String goal = "(forall (?o0 - thing) (imply(and (initially (colour
		// ?o0 blue))) (exists (?p0 - waypoint) (exists (?o1 - thing ?p1 -
		// waypoint) (and (initially (colour ?o1 red))(pos ?o0 ?p0) (initially
		// (pos ?o1 ?p1)) (near ?p0 ?p1))))))";

		// nah: initially has now been removed
		String goal = "(forall (?o0 - thing) (imply (and  (colour ?o0 red)) (exists (?p0 - waypoint) (exists (?o1 - thing ?p1 - waypoint) (and  (colour ?o1 blue)(pos ?o0 ?p0)   (pos ?o1 ?p1)                   (near ?p0 ?p1))))))";
		// tests
		// String goal = "(near proxyA proxyT)";

		String domainFile = "./subarchitectures/planning.sa/config/domains/playmate-domain.mapl";

		ContinualPlanningProcess cpp = new ContinualPlanningProcess(domainFile,
				true);
		cpp.setInitialState(new PlanningState(objects, facts));
		cpp.setGoal(goal);
		return cpp;
	}

}
