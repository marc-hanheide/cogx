(define (domain playmate)
	(:requirements :mapl :adl)
	
	(:types 
	 ;;; general things in the world
	 agent phys_object object_pos  feature - object

	 ;;; places where things can be ... an abstract_waypoint can't
 	 ;;; be used to move things

	 agent abstract_waypoint  - object_pos
	 waypoint - abstract_waypoint

	 ;;; special types of waypoints that define targets for the game
	 waypoint_table_left waypoint_table_right - abstract_waypoint

	 ;;; features we care about
	 shape colour size - feature

 	 ;;; things that we can move
	 movable - phys_object
	 ball cube block pyramid - movable
	 
	 ;;; things we can't
	 flag - phys_object		
	 
	 ;;;agents that are involved
	 robot human subarchitecture - agent
	 )
	
	(:constants
	 blue red green black white - colour
	 small big - size
	 triangle square circle - shape
	 )
	
	(:predicates

	 (wp_right_of ?wp1 ?wp2 - abstract_waypoint)
	 (wp_left_of ?wp1 ?wp2 - abstract_waypoint)
	 (wp_front_of ?wp1 ?wp2 - abstract_waypoint)
	 (wp_back_of ?wp1 ?wp2 - abstract_waypoint)
	 (wp_near ?wp1 ?wp2 - abstract_waypoint)

	 (right_of ?o1 ?o2 - phys_object)
	 (left_of ?o1 ?o2 - phys_object)
	 (front_of ?o1 ?o2 - phys_object)
	 (back_of ?o1 ?o2 - phys_object)
	 (near ?o1 ?o2 - phys_object)

	 (pos ?obj - phys_object : ?wp - object_pos)
	 (colour ?obj - phys_object : ?col - colour)	
	 (size ?obj - phys_object : ?s - size)
	 (shape ?obj - phys_object : ?s - shape)		

	 (on_table_left ?flg - flag)
	 (on_table_right ?flg - flag)
	 
	 (in-answer-set ?o - object)

	 (knows_about__colour ?comp - subarchitecture)
	 (not_knows_about__colour ?comp - subarchitecture ?obj - phys_object)
	 (knows_about__shape ?comp - subarchitecture)
	 (not_knows_about__shape ?comp - subarchitecture ?obj - phys_object)
	 (knows_about__area-id ?comp - subarchitecture)
	 (not_knows_about__area-id ?comp - subarchitecture ?obj - phys_object)
	 (knows_about__asserted-position ?comp - subarchitecture)
	 (not_knows_about__asserted-position ?comp - subarchitecture ?obj - phys_object)


	 (subarchitecture_of ?c - agent : ?a - agent)

	 )
	
;;; sensors ;;;

(:sensor sense-pos
 :agent (?a - agent)
 :parameters (?o - phys_object)
 :sense (pos ?o))

;;; axioms ;;;

	(:derived (can_talk_to ?a1 - agent ?a2 - agent)
		(and )
		)

	(:derived (right_of ?o1 ?o2 - phys_object) 
		(exists (?wp1 ?wp2 - abstract_waypoint) (and
			(pos ?o1 : ?wp1)
			(pos ?o2 : ?wp2)
			(wp_right_of ?wp1 ?wp2))
		))

	(:derived (left_of ?o1 ?o2 - phys_object) 
		(exists (?wp1 ?wp2 - abstract_waypoint) (and
			(pos ?o1 : ?wp1)
			(pos ?o2 : ?wp2)
			(wp_left_of ?wp1 ?wp2))
		))

	(:derived (front_of ?o1 ?o2 - phys_object) 
		(exists (?wp1 ?wp2 - abstract_waypoint) (and
			(pos ?o1 : ?wp1)
			(pos ?o2 : ?wp2)
			(wp_front_of ?wp1 ?wp2))
		))

	(:derived (back_of ?o1 ?o2 - phys_object) 
		(exists (?wp1 ?wp2 - abstract_waypoint) (and
			(pos ?o1 : ?wp1)
			(pos ?o2 : ?wp2)
			(wp_back_of ?wp1 ?wp2))
		))

	(:derived (near ?o1 ?o2 - phys_object) 
		(exists (?wp1 ?wp2 - abstract_waypoint) (and
			(pos ?o1 : ?wp1)
			(pos ?o2 : ?wp2)
			(wp_near ?wp1 ?wp2))
		))

	(:derived (on_table_right ?flg - flag) 
		(exists (?flg_wp - abstract_waypoint ?table_wp - waypoint_table_right) (and
			(pos ?flg : ?flg_wp)
			(wp_near ?table_wp ?flg_wp))
		))

	(:derived (on_table_left ?flg - flag) 
		(exists (?flg_wp - abstract_waypoint ?table_wp - waypoint_table_left) (and
			(pos ?flg : ?flg_wp)
			(wp_near ?table_wp ?flg_wp))
		))


;; speech acts 

	(:action tell_val ??svar
	 :agent (?speaker - agent)
	 :parameters (?hearer - agent)
	 :precondition (and
          (K ?speaker (??svar ??args))
		  (can_talk_to ?speaker ?hearer)
		)
	 :effect (and
		(K ?hearer (??svar ??args))
	))


;; special

	(:action guess__colour
	 :agent (?ag - planning_agent)
	 :parameters (?obj - phys_object ?c - colour)
	 :precondition (and
         ;; that's how the general scheme for guessing
		 ;; should look like: enforce an appropriate
		 ;; sensing action before (makes K true) and
		 ;; only permit values from the (current) restricted
		 ;; domain as known to the agent
	     (K ?ag (colour ?obj))
		 (in_domain (colour ?obj) ?c)
		)
	 :effect (colour ?obj : ?c))

	(:action __assume_knowledge__colour
	 :agent (?ag - planning_agent ?obj - phys_object)
	 :parameters (?comp - subarchitecture)
	 :precondition (and
		  (knows_about__colour ?comp)
		  (not (not_knows_about__colour ?comp ?obj : true))
		  ;(not (K ?comp (colour ?obj) : true))
		)
	 :effect (and
	      (K ?comp (colour ?obj))
        ))

	(:action guess__shape
	 :agent (?ag - planning_agent)
	 :parameters (?obj - phys_object ?c - shape)
	 :precondition (and
         ;; that's how the general scheme for guessing
		 ;; should look like: enforce an appropriate
		 ;; sensing action before (makes K true) and
		 ;; only permit values from the (current) restricted
		 ;; domain as known to the agent
	     (K ?ag (shape ?obj))
		 (in_domain (shape ?obj) ?c)
		)
	 :effect (shape ?obj : ?c))

	(:action __assume_knowledge__shape
	 :agent (?ag - planning_agent ?obj - phys_object)
	 :parameters (?comp - subarchitecture)
	 :precondition (and
		  (knows_about__shape ?comp)
		  (not (not_knows_about__shape ?comp ?obj : true))
		  ;(not (K ?comp (shape ?obj) : true))
		)
	 :effect (and
	      (K ?comp (shape ?obj))
        ))


    (:action __add-to-answer-set
	 :agent (?ag - planning_agent)
	 :parameters (?obj - object)
	 :precondition (and
		)
	 :effect (in-answer-set ?obj))

;;;     (:action assign-square-flag
;;; 	 :agent (?a - robot)	 
;;; 	 :parameters (?flg - flag)
;;; 	 :variables (?flg_wp - waypoint ?table_wp - waypoint_table_right)
;;; 	 :precondition (and
;;; 		(pos ?flg : ?flg_wp) 
;;; 		(wp_near ?table_wp ?flg_wp))
;;; 	 :effect (and
;;; 		(shape ?flg : square)
;;; 	))

	



;;; actions ;;;


	(:action move
	 :agent (?a - robot)	 
	 :parameters (?obj - movable)
	 :variables (?wp - abstract_waypoint ?np - waypoint)
	 :precondition (and
		(pos ?obj : ?wp) 
		(not (exists (?obj2 - phys_object) (pos ?obj2 : ?np))))
	 :effect (and
		(pos ?obj : ?np)
	))
	
	
	;;; reposition a waypoint so that it satifies a left relation
      (:action reposition_left
         :agent (?a - robot)
         :parameters (?target - waypoint ?landmark - abstract_waypoint)
         :precondition (and
                (not (exists (?obj - phys_object) (pos ?obj : ?target))))
         :effect (and
                (wp_left_of ?target ?landmark : true))
        )	

	;;; reposition a waypoint so that it satifies a right relation
      (:action reposition_right
         :agent (?a - robot)
         :parameters (?target - waypoint ?landmark - abstract_waypoint)
         :precondition (and
                (not (exists (?obj - phys_object) (pos ?obj : ?target))))
         :effect (and
                (wp_right_of ?target ?landmark : true))
        )	

  	;;; reposition a waypoint so that it satifies a near relation
      (:action reposition_near
         :agent (?a - robot)
         :parameters (?target - waypoint ?landmark - abstract_waypoint)
         :precondition (and
                (not (exists (?obj - phys_object) (pos ?obj : ?target))))
         :effect (and
                (wp_near ?target ?landmark : true))
        )	


)
