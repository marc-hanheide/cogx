<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TooN: TooN::SVD&lt; Rows, Cols, Precision &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="namespaceTooN.html">TooN</a>::<a class="el" href="classTooN_1_1SVD.html">SVD</a></div>
<h1>TooN::SVD&lt; Rows, Cols, Precision &gt; Class Template Reference<br>
<small>
[<a class="el" href="group__gDecomps.html">Matrix decompositions</a>]</small>
</h1><!-- doxytag: class="TooN::SVD" -->Performs SVD and back substitute to solve equations.  
<a href="#_details">More...</a>
<p>

<p>
<a href="classTooN_1_1SVD-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#cce097ee1e3f023532f4ff22f690dc5c">SVD</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#9d5a0c85e789a9c7ead898dc26663803">SVD</a> (int rows, int cols)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int R2, int C2, typename P2, typename B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#fca60d704b87d0ce791f3c5581ac248b">SVD</a> (const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;m)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int R2, int C2, typename P2, typename B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#86e1fba41693781dec1aace6f692406d">compute</a> (const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;m)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ae32de7dd492d74831e2979ba5646915"></a><!-- doxytag: member="TooN::SVD::do_compute" ref="ae32de7dd492d74831e2979ba5646915" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>do_compute</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="be3797bb1afa644f890ce534917ff9b2"></a><!-- doxytag: member="TooN::SVD::is_vertical" ref="be3797bb1afa644f890ce534917ff9b2" args="()" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>is_vertical</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="491d2e42154fb8bb4891b3acc6c64dd7"></a><!-- doxytag: member="TooN::SVD::min_dim" ref="491d2e42154fb8bb4891b3acc6c64dd7" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>min_dim</b> ()</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int Rows2, int Cols2, typename P2, typename B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Cols2,<br>
 typename <br>
Internal::MultiplyType<br>
&lt; Precision, P2 &gt;<br>
::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#6b5c4082e745346ba8ef0a2c40a4fab5">backsub</a> (const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;int Size, typename P2, typename B2&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Cols,<br>
 typename <br>
Internal::MultiplyType<br>
&lt; Precision, P2 &gt;<br>
::type &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#171069e6a1eb342a3b39532080f0ce87">backsub</a> (const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Size, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Cols, Rows &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#e62a0969821226ac22fd9feaa3e87938">get_pinv</a> (const Precision condition=condition_no)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Precision&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#791d48dd464d2bfb101f79f295a46162">determinant</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#e103e32062a85bf3cebe91251f72838f">rank</a> (const Precision condition=condition_no)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Rows,<br>
 Min_Dim, Precision,<br>
 Reference::RowMajor &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#e91fb2ee885977cd88b5d498180be748">get_U</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Min_Dim,<br>
 Precision &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#96409b9ff4963704e9991e751873c3b4">get_diagonal</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Min_Dim,<br>
 Cols, Precision,<br>
 Reference::RowMajor &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTooN_1_1SVD.html#ed67d44bde8f88928223508616471796">get_VT</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d36439b4bb0e5e7604c1799a9556c287"></a><!-- doxytag: member="TooN::SVD::get_inv_diag" ref="d36439b4bb0e5e7604c1799a9556c287" args="(Vector&lt; Min_Dim &gt; &amp;inv_diag, const Precision condition)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_inv_diag</b> (<a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Min_Dim &gt; &amp;inv_diag, const Precision condition)</td></tr>

<tr><td colspan="2"><br><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7b033d88ef012f3069e0cd574a7cc61"></a><!-- doxytag: member="TooN::SVD::Min_Dim" ref="a7b033d88ef012f3069e0cd574a7cc61" args="" -->
static const int&nbsp;</td><td class="memItemRight" valign="bottom"><b>Min_Dim</b> = Rows&lt;Cols?Rows:Cols</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt;<br>
 class TooN::SVD&lt; Rows, Cols, Precision &gt;</h3>

Performs SVD and back substitute to solve equations. 
<p>
Singular value decompositions are more robust than <a class="el" href="classTooN_1_1LU.html" title="Performs LU decomposition and back substitutes to solve equations.">LU</a> decompositions in the face of singular or nearly singular matrices. They decompose a matrix (of any shape) <img class="formulaInl" alt="$M$" src="form_10.png"> into: <p class="formulaDsp">
<img class="formulaDsp" alt="\[M = U \times D \times V^T\]" src="form_30.png">
<p>
 where <img class="formulaInl" alt="$D$" src="form_31.png"> is a diagonal matrix of positive numbers whose dimension is the minimum of the dimensions of <img class="formulaInl" alt="$M$" src="form_10.png">. If <img class="formulaInl" alt="$M$" src="form_10.png"> is tall and thin (more rows than columns) then <img class="formulaInl" alt="$U$" src="form_13.png"> has the same shape as <img class="formulaInl" alt="$M$" src="form_10.png"> and <img class="formulaInl" alt="$V$" src="form_32.png"> is square (vice-versa if <img class="formulaInl" alt="$M$" src="form_10.png"> is short and fat). The columns of <img class="formulaInl" alt="$U$" src="form_13.png"> and the rows of <img class="formulaInl" alt="$V$" src="form_32.png"> are orthogonal and of unit norm (so one of them lies in SO(N)). The inverse of <img class="formulaInl" alt="$M$" src="form_10.png"> (or pseudo-inverse if <img class="formulaInl" alt="$M$" src="form_10.png"> is not square) is then given by <p class="formulaDsp">
<img class="formulaDsp" alt="\[M^{\dagger} = V \times D^{-1} \times U^T\]" src="form_33.png">
<p>
<p>
If <img class="formulaInl" alt="$M$" src="form_10.png"> is nearly singular then the diagonal matrix <img class="formulaInl" alt="$D$" src="form_31.png"> has some small values (relative to its largest value) and these terms dominate <img class="formulaInl" alt="$D^{-1}$" src="form_34.png">. To deal with this problem, the inverse is conditioned by setting a maximum ratio between the largest and smallest values in <img class="formulaInl" alt="$D$" src="form_31.png"> (passed as the <code>condition</code> parameter to the various functions). Any values which are too small are set to zero in the inverse (rather than a large number)<p>
It can be used as follows to solve the <img class="formulaInl" alt="$M\underline{x} = \underline{c}$" src="form_9.png"> problem as follows: <div class="fragment"><pre class="fragment"><span class="comment">// construct M</span>
Matrix&lt;3&gt; M;
M[0] = makeVector(1,2,3);
M[1] = makeVector(4,5,6);
M[2] = makeVector(7,8.10);
<span class="comment">// construct c</span>
 Vector&lt;3&gt; c;
c = 2,3,4;
<span class="comment">// create the SVD decomposition of M</span>
SVD&lt;3&gt; svdM(M);
<span class="comment">// compute x = M^-1 * c</span>
Vector&lt;3&gt; x = svdM.backsub(c);
</pre></div><p>
SVD&lt;&gt; (= <a class="el" href="classTooN_1_1SVD.html" title="Performs SVD and back substitute to solve equations.">SVD</a>&lt;-1&gt;) can be used to create an <a class="el" href="classTooN_1_1SVD.html" title="Performs SVD and back substitute to solve equations.">SVD</a> whose size is determined at run-time. <hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="cce097ee1e3f023532f4ff22f690dc5c"></a><!-- doxytag: member="TooN::SVD::SVD" ref="cce097ee1e3f023532f4ff22f690dc5c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::<a class="el" href="classTooN_1_1SVD.html">SVD</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
default constructor for Rows&gt;0 and Cols&gt;0 
<p>

</div>
</div><p>
<a class="anchor" name="9d5a0c85e789a9c7ead898dc26663803"></a><!-- doxytag: member="TooN::SVD::SVD" ref="9d5a0c85e789a9c7ead898dc26663803" args="(int rows, int cols)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::<a class="el" href="classTooN_1_1SVD.html">SVD</a>           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
constructor for Rows=-1 or Cols=-1 (or both) 
<p>

</div>
</div><p>
<a class="anchor" name="fca60d704b87d0ce791f3c5581ac248b"></a><!-- doxytag: member="TooN::SVD::SVD" ref="fca60d704b87d0ce791f3c5581ac248b" args="(const Matrix&lt; R2, C2, P2, B2 &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
<div class="memtemplate">
template&lt;int R2, int C2, typename P2, typename B2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::<a class="el" href="classTooN_1_1SVD.html">SVD</a>           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Construct the SVD decomposition of a matrix. 
<p>
This initialises the class, and performs the decomposition immediately. 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="86e1fba41693781dec1aace6f692406d"></a><!-- doxytag: member="TooN::SVD::compute" ref="86e1fba41693781dec1aace6f692406d" args="(const Matrix&lt; R2, C2, P2, B2 &gt; &amp;m)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
<div class="memtemplate">
template&lt;int R2, int C2, typename P2, typename B2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::compute           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; R2, C2, P2, B2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>m</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the SVD decomposition of M, typically used after the default constructor. 
<p>

</div>
</div><p>
<a class="anchor" name="6b5c4082e745346ba8ef0a2c40a4fab5"></a><!-- doxytag: member="TooN::SVD::backsub" ref="6b5c4082e745346ba8ef0a2c40a4fab5" args="(const Matrix&lt; Rows2, Cols2, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
<div class="memtemplate">
template&lt;int Rows2, int Cols2, typename P2, typename B2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt;Cols,Cols2, typename Internal::MultiplyType&lt;Precision,P2&gt;::type &gt; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::backsub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt; Rows2, Cols2, P2, B2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Precision&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>condition_no</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate result of multiplying the (pseudo-)inverse of M by another matrix. 
<p>
For a matrix <img class="formulaInl" alt="$A$" src="form_14.png">, this calculates <img class="formulaInl" alt="$M^{\dagger}A$" src="form_35.png"> by back substitution (i.e. without explictly calculating the (pseudo-)inverse). See the detailed description for a description of condition variables. 
</div>
</div><p>
<a class="anchor" name="171069e6a1eb342a3b39532080f0ce87"></a><!-- doxytag: member="TooN::SVD::backsub" ref="171069e6a1eb342a3b39532080f0ce87" args="(const Vector&lt; Size, P2, B2 &gt; &amp;rhs, const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
<div class="memtemplate">
template&lt;int Size, typename P2, typename B2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt;Cols, typename Internal::MultiplyType&lt;Precision,P2&gt;::type &gt; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::backsub           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt; Size, P2, B2 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Precision&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>condition_no</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate result of multiplying the (pseudo-)inverse of M by a vector. 
<p>
For a vector <img class="formulaInl" alt="$b$" src="form_16.png">, this calculates <img class="formulaInl" alt="$M^{\dagger}b$" src="form_36.png"> by back substitution (i.e. without explictly calculating the (pseudo-)inverse). See the detailed description for a description of condition variables. 
</div>
</div><p>
<a class="anchor" name="e62a0969821226ac22fd9feaa3e87938"></a><!-- doxytag: member="TooN::SVD::get_pinv" ref="e62a0969821226ac22fd9feaa3e87938" args="(const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt;Cols,Rows&gt; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::get_pinv           </td>
          <td>(</td>
          <td class="paramtype">const Precision&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>condition_no</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate (pseudo-)inverse of the matrix. 
<p>
This is not usually needed: if you need the inverse just to multiply it by a matrix or a vector, use one of the <a class="el" href="classTooN_1_1SVD.html#6b5c4082e745346ba8ef0a2c40a4fab5" title="Calculate result of multiplying the (pseudo-)inverse of M by another matrix.">backsub()</a> functions, which will be faster. See the detailed description of the pseudo-inverse and condition variables. 
</div>
</div><p>
<a class="anchor" name="791d48dd464d2bfb101f79f295a46162"></a><!-- doxytag: member="TooN::SVD::determinant" ref="791d48dd464d2bfb101f79f295a46162" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Precision <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::determinant           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the product of the singular values for square matrices this is the determinant. 
<p>

</div>
</div><p>
<a class="anchor" name="e103e32062a85bf3cebe91251f72838f"></a><!-- doxytag: member="TooN::SVD::rank" ref="e103e32062a85bf3cebe91251f72838f" args="(const Precision condition=condition_no)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::rank           </td>
          <td>(</td>
          <td class="paramtype">const Precision&nbsp;</td>
          <td class="paramname"> <em>condition</em> = <code>condition_no</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the rank of the matrix. 
<p>
See the detailed description of the pseudo-inverse and condition variables. 
</div>
</div><p>
<a class="anchor" name="e91fb2ee885977cd88b5d498180be748"></a><!-- doxytag: member="TooN::SVD::get_U" ref="e91fb2ee885977cd88b5d498180be748" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt;Rows,Min_Dim,Precision,Reference::RowMajor&gt; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::get_U           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the U matrix from the decomposition The size of this depends on the shape of the original matrix it is square if the original matrix is wide or tall if the original matrix is tall. 
<p>

</div>
</div><p>
<a class="anchor" name="96409b9ff4963704e9991e751873c3b4"></a><!-- doxytag: member="TooN::SVD::get_diagonal" ref="96409b9ff4963704e9991e751873c3b4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTooN_1_1Vector.html">Vector</a>&lt;Min_Dim,Precision&gt;&amp; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::get_diagonal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the singular values as a vector. 
<p>

</div>
</div><p>
<a class="anchor" name="ed67d44bde8f88928223508616471796"></a><!-- doxytag: member="TooN::SVD::get_VT" ref="ed67d44bde8f88928223508616471796" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Rows = Dynamic, int Cols = Rows, typename Precision = DefaultPrecision&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTooN_1_1Matrix.html">Matrix</a>&lt;Min_Dim,Cols,Precision,Reference::RowMajor&gt; <a class="el" href="classTooN_1_1SVD.html">TooN::SVD</a>&lt; Rows, Cols, Precision &gt;::get_VT           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the VT matrix from the decomposition The size of this depends on the shape of the original matrix it is square if the original matrix is tall or wide if the original matrix is wide. 
<p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu May 7 20:28:42 2009 for TooN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
