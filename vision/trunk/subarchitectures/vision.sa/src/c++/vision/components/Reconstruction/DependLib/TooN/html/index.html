<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TooN: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>TooN Documentation</h1>
<p>
<h3 align="center">2.0.0-beta2 </h3><h2><a class="anchor" name="sIntro">
Introduction</a></h2>
The TooN library is a set of C++ header files which provide basic numerics facilities:<ul>
<li><a class="el" href="structTooN_1_1Vector.html">Vectors</a> and <a class="el" href="classTooN_1_1Matrix.html">matrices</a></li><li><a class="el" href="group__gDecomps.html">Matrix decompositions</a></li><li><a class="el" href="group__gOptimize.html">Function optimization</a></li><li><a class="el" href="group__gTransforms.html">Parameterized matrices (eg transformations)</a></li><li><a class="el" href="group__gEquations.html">linear equations</a></li></ul>
<p>
It provides classes for statically- (known at compile time) and dynamically- (unknown at compile time) sized vectors and matrices and it delegates advanced functions (like SVD or multiplication of large matrices) to LAPACK and BLAS (this means you will need libblas and liblapack).<p>
The library makes substantial internal use of templates to achieve run-time speed efficiency whilst retaining a clear programming syntax.<p>
Why use this library?<ul>
<li>Because it supports statically sized vectors and matrices very efficiently.</li><li>Because it provides extensive type safety for statically sized vectors and matrices (you can't attempt to multiply a 3x4 matrix and a 2-vector).</li><li>Because it supports transposition, subscripting and slicing of matrices (to obtain a vector) very efficiently.</li><li>Because it interfaces well to other libraries.</li><li>Because it exploits LAPACK and BLAS (for which optimised versions exist on many platforms).</li></ul>
<h2><a class="anchor" name="sUsage">
How to use TooN</a></h2>
This section is arranged as a FAQ. Most answers include code fragments. Assume <code>using namespace <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a>;</code>.<p>
<ul>
<li><a class="el" href="index.html#sDownload">Getting the code and installing</a></li><li><a class="el" href="index.html#sStart">Getting started</a></li><li><a class="el" href="index.html#sCreateVector">How do I create a vector?</a></li><li><a class="el" href="index.html#sCreateMatrix">How do I create a matrix?</a></li><li><a class="el" href="index.html#sFunctionVector">How do I write a function taking a vector?</a></li><li><a class="el" href="index.html#sGenericCode">How do I write generic code?</a></li><li><a class="el" href="index.html#sElemOps">What elementary operations are supported?</a></li><li><a class="el" href="index.html#sInitialize">How I initialize a vector/matrix?</a></li><li><a class="el" href="index.html#sScalars">How do I add a scalar to every element of a vector/matrix?</a></li><li><a class="el" href="index.html#ssExamples">Are there any examples?</a></li><li><a class="el" href="index.html#sNoResize">Why does assigning mismatched dynamic vectors fail?</a></li><li><a class="el" href="index.html#sDebug">What debugging options are there?</a></li><li><a class="el" href="index.html#sSlices">What are slices?</a></li><li><a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a></li><li><a class="el" href="index.html#sSolveLinear">How do I invert a matrix / solve linear equations?</a></li><li><a class="el" href="index.html#sOtherStuff">What other stuff is there:</a></li><li><a class="el" href="index.html#sHandyFuncs">What handy functions are there (normalize, identity, fill, etc...)?</a></li><li><a class="el" href="index.html#sNoInplace">Why don't functions work in place?</a></li><li><a class="el" href="index.html#sColMajor">Can I have a column major matrix?</a></li><li><a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a></li><li><a class="el" href="index.html#sWrap">How do I interface to other libraries?</a></li><li><a class="el" href="index.html#sImplementation">How is it implemented</a></li></ul>
<h3><a class="anchor" name="sDownload">
Getting the code and installing</a></h3>
To get the code from cvs use:<p>
cvs -z3 -d:pserver:<a href="mailto:anoncvs@cvs.savannah.nongnu.org">anoncvs@cvs.savannah.nongnu.org</a>:/cvsroot/toon co <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a><p>
The home page for the library with a version of this documentation is at:<p>
<a href="http://mi.eng.cam.ac.uk/~er258/cvd/toon.html">http://mi.eng.cam.ac.uk/~er258/cvd/toon.html</a><p>
The code will work as-is, and comes with a default configuration, which should work on any system.<p>
On a unix system, <code>./configure &amp;&amp; make install </code> will install <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> to the correct place. Note there is no code to be compiled, but the configure script performs some basic checks.<h3><a class="anchor" name="sStart">
Getting started</a></h3>
To begin, just in include the right file:<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">        #include &lt;TooN/TooN.h&gt;</span>
</pre></div><p>
Everything lives in the <code><a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a></code> namespace.<p>
Then, make sure the directory containing <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> is in your compiler's search path. If you use any decompositions, you will need to link against LAPACK, BLAS and any required support libraries. On a modern unix system, linking against LAPACK will do this automatically.<h3><a class="anchor" name="sCreateVector">
How do I create a vector?</a></h3>
Vectors can be statically sized or dynamically sized.<p>
<div class="fragment"><pre class="fragment">            Vector&lt;3&gt; v1;    <span class="comment">//Create a static sized vector of size 3</span>
            Vector&lt;&gt;  v2(4); <span class="comment">//Create a dynamically sized vector of size 4</span>
            Vector&lt;Dynamic&gt;  v2(4); <span class="comment">//Create a dynamically sized vector of size 4</span>
</pre></div><p>
See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>.<h3><a class="anchor" name="sCreateMatrix">
How do I create a matrix?</a></h3>
Matrices can be statically sized or dynamically sized.<p>
<div class="fragment"><pre class="fragment">            Matrix&lt;3&gt; m;              <span class="comment">//A 3x3 matrix (statically sized)</span>
            Matrix&lt;3,2&gt;  m;           <span class="comment">//A 3x2 matrix (statically sized)</span>
            Matrix&lt;&gt;  m(5,6);         <span class="comment">//A 5x6 matrix (dynamically sized)</span>
            Matrix&lt;3,Dynamic&gt; m(3,6); <span class="comment">//A 3x6 matrix with a dynamic number of columns and static number of rows.</span>
            Matrix&lt;Dynamic,2&gt; m(3,2); <span class="comment">//A 2x3 matrix with a dynamic number of rows and static number of columns.</span>
</pre></div><p>
See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>.<h3><a class="anchor" name="sFunctionVector">
How do I write a function taking a vector?</a></h3>
To write a function taking a local copy of a vector: <div class="fragment"><pre class="fragment">            <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size&gt; <span class="keywordtype">void</span> func(Vector&lt;Size&gt; v);
</pre></div><p>
To write a function taking any type of vector by reference: <div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">typename</span> Base&gt; <span class="keywordtype">void</span> func(<span class="keyword">const</span> Vector&lt;Size, double, Base&gt;&amp; v);
</pre></div> See also <a class="el" href="index.html#sPrecision">Can I have a precision other than double?</a>, <a class="el" href="index.html#sGenericCode">How do I write generic code?</a> and <a class="el" href="index.html#sNoInplace">Why don't functions work in place?</a><h3><a class="anchor" name="sElemOps">
What elementary operations are supported?</a></h3>
Assignments are performed using <code>=</code>. See also <a class="el" href="index.html#sNoResize">Why does assigning mismatched dynamic vectors fail?</a>.<p>
These operators apply to vectors or matrices and scalars. The operator is applied to every element with the scalar. <div class="fragment"><pre class="fragment">        *=, /=, *, / 
</pre></div><p>
Vector and vectors or matrices and matrices: <div class="fragment"><pre class="fragment">        +, -, +=, -= 
</pre></div><p>
Dot product: <div class="fragment"><pre class="fragment">        Vector * Vector
</pre></div><p>
Matrix multiply: <div class="fragment"><pre class="fragment">        Matrix * Matrix
</pre></div><p>
Matrix multiplying a column vector: <div class="fragment"><pre class="fragment">        Matrix * Vector
</pre></div><p>
Row vector multiplying a matrix: <div class="fragment"><pre class="fragment">        Vector * Matrix
</pre></div><p>
3x3 Vector cross product: <div class="fragment"><pre class="fragment">        Vector&lt;3&gt; ^ Vector&lt;3&gt; 
</pre></div><p>
All the functions listed below return slices. The slices are simply references to the original data and can be used as lvalues.<p>
Getting the transpose of a matrix: <div class="fragment"><pre class="fragment">            Matrix.T()
</pre></div><p>
Accessing elements: <div class="fragment"><pre class="fragment">        Vector[i]     <span class="comment">//get element i</span>
        Matrix(i,j)   <span class="comment">//get element i,j</span>
        Matrix[i]     <span class="comment">//get row i as a vector</span>
        Matrix[i][j]  <span class="comment">//get element i,j</span>
</pre></div><p>
Turning vectors in to matrices: <div class="fragment"><pre class="fragment">        Vector.as_row() <span class="comment">//vector as a 1xN matrix</span>
        Vector.as_col() <span class="comment">//vector as a Nx1 matrix</span>
</pre></div><p>
Slicing: <div class="fragment"><pre class="fragment">        Vector.slice&lt;Start, End&gt;();                            <span class="comment">//Static slice</span>
        Vector.slice&lt;&gt;(start, end);                            <span class="comment">//Dynamic slice</span>
        Matrix.slice&lt;RowStart, ColStart, NumRows, NumCols&gt;();  <span class="comment">//Static slice</span>
        Matrix.slice&lt;&gt;(rowstart, colstart, numrows, numcols);  <span class="comment">//Dynamic slice</span>
</pre></div><p>
See also <a class="el" href="index.html#sSlices">What are slices?</a><h3><a class="anchor" name="sInitialize">
How I initialize a vector/matrix?</a></h3>
Vectors and matrices start off uninitialized (filled with random garbage). They can be easily filled with zeros, or ones (see also TooN::Ones): <div class="fragment"><pre class="fragment">            Vector&lt;3&gt; v = Zeros;
            Matrix&lt;3&gt; m = Zeros
            Vector&lt;&gt;  v2 = Zeros(2); <span class="comment">//Note in they dynamic case, the size must be specified</span>
            Matrix&lt;&gt;  m2 = Zeros(2,2); <span class="comment">//Note in they dynamic case, the size must be specified</span>
</pre></div><p>
Vectors can be filled with makeVector: <div class="fragment"><pre class="fragment">            Vector&lt;&gt; v = makeVector(2,3,4,5,6);
</pre></div><p>
Matrices can be initialized to the identity matrix: <div class="fragment"><pre class="fragment">            Matrix&lt;2&gt; m = Idendity;
            Matrix&lt;&gt; m2 = Identity(3);
</pre></div> note that you need to specify the size in the dynamic case.<p>
They can also be initialized with data from another source. See also <a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a>.<h3><a class="anchor" name="sScalars">
How do I add a scalar to every element of a vector/matrix?</a></h3>
Addition to every element is not an elementary operation in the same way as multiplication by a scalar. It is supported throught the Ones object:<p>
<div class="fragment"><pre class="fragment">            Vector&lt;3&gt; a, b;
            ...
            b = a + Ones*3;       <span class="comment">// b_i = a_i + 3</span>
            a+= Ones * 3;         <span class="comment">// a_i &lt;- a_i + 3</span>
</pre></div><p>
It is supported the same way on Matrix and slices.<h3><a class="anchor" name="sNoResize">
Why does assigning mismatched dynamic vectors fail?</a></h3>
Vectors are not generic containers, and dynamic vectors have been designed to have the same semantics as static vectors where possible. Therefore trying to assign a vector of length 2 to a vector of length 3 is an error, so it fails. See also <a class="el" href="index.html#sResize">How do I resize a dynamic vector/matrix?</a><h3><a class="anchor" name="sResize">
How do I resize a dynamic vector/matrix?</a></h3>
You can't. Preventing resize allow all sorts of things to be const which is great for optimization. If you want a genuinely resizable structure, you may consider using a <code>std::vector</code>, and accessing it as a <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> object when appropriate. See <a class="el" href="index.html#sWrap">I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a>. Also, the speed and complexity of resizable matrices depends on the memory layout, so you may wish to use column major matrices as opposed to the default row major layout.<h3><a class="anchor" name="sDebug">
What debugging options are there?</a></h3>
By default, everything which is checked at compile time in the static case is checked at run-time in the dynamic case. In other words, slices and sizes are checked at run-time if need be. These checks can be disabled by defining the macros <code>TOON_NDEBUG_SLICE</code> and <code>TOON_NDEBUG_SIZE</code> respectively. Bounds are not checked by default. Bounds checking can be enabled by defining the macro <code>TOON_CHECK_BOUNDS</code>. None of these macros change the interface, so debugging code can be freely mixed with optimized code.<p>
Errors are manifested to a call to <code>std::abort()</code>.<p>
<a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> does not initialize data in a Vector or Matrix. For debugging purposes the following macros can be defined:<ul>
<li><code>TOON_INITIALIZE_QNAN</code> Sets every element of newly defined Vectors or Matrixs to quiet NaN, if it exists, and 0 otherwise. Your code will not compile if you have made a Vector or Matrix of a type which cannot be constructed from a number.</li><li><code>TOON_INITIALIZE_SNAN</code> Sets every element of newly defined Vectors or Matrixs to signalling NaN, if it exists, and 0 otherwise.</li><li><code>TOON_INITIALIZE_VAL</code> Sets every element of newly defined Vectors or Matrixs to the expansion of this macro.</li><li><code>TOON_INITIALIZE_RANDOM</code> Fills up newly defined Vectors and Matrixs with random bytes, to trigger non repeatable behaviour. The random number generator is automatically seeded with a granularity of 1 second. Your code will not compile if you have a Vector or Matrix of a non-POD type.</li></ul>
<h3><a class="anchor" name="sSlices">
What are slices?</a></h3>
Slices are references to data belonging to another vector or matrix. Modifying the data in a slice modifies the original object. Likewise, if the original object changes, the change will be reflected in the slice. Slices can be used as lvalues. For example:<p>
<div class="fragment"><pre class="fragment">        Matrix&lt;3&gt; m = Identity;

        m.slice&lt;0,0,2,2&gt;() *= 3; <span class="comment">//Multiply the top-left 2x2 submatrix of m by 3.</span>

        m[2] /=10; <span class="comment">//Divide the third row of M by 10.</span>

        m.T()[2] +=2; <span class="comment">//Add 2 to every element of the second column of M.</span>

        m[1].slice&lt;1,2&gt;() = makeVector(3,4); <span class="comment">//Set m_1,1 to 3 and m_1,2 to 4</span>
        
        m[0][0]=6;
</pre></div><h3><a class="anchor" name="sPrecision">
Can I have a precision other than double?</a></h3>
Yes! <div class="fragment"><pre class="fragment">        Vector&lt;3, float&gt; v;          <span class="comment">//Static sized vector of floats</span>
        Vector&lt;Dynamic, float&gt; v(4); <span class="comment">//Dynamic sized vector of floats</span>
</pre></div><p>
Likewise for matrix.<h3><a class="anchor" name="sSolveLinear">
How do I invert a matrix / solve linear equations?</a></h3>
You use the decomposition objects (see <a class="el" href="index.html#sDecompos">below</a>), for example to solve Ax=b:<p>
<div class="fragment"><pre class="fragment">    Matrix&lt;3&gt; A;
    A[0]=makeVector(1,2,3);
    A[1]=makeVector(2,3,4);
    A[2]=makeVector(3,2,1);

    Vector&lt;3&gt; b = makeVector (2,4,5);

    <span class="comment">// solve Ax=b using LU</span>
    LU&lt;3&gt; luA(A);
    Vector&lt;3&gt; x1 = luA.backsub(b);

    <span class="comment">// solve Ax=b using SVD</span>
    SVD&lt;3&gt; svdA(A);
    Vector&lt;3&gt; x2 = svdA.backsub(b);
</pre></div><p>
Similarly for the other <a class="el" href="index.html#sDecompos">decomposition objects</a><h3><a class="anchor" name="sDecompos">
Which decomposisions are there?</a></h3>
For general size matrices (not necessarily square) there are: <a class="el" href="classTooN_1_1LU.html">LU </a>, <a class="el" href="classTooN_1_1SVD.html">SVD </a> and gauss_jordan<p>
For square symmetric matrices there are: <a class="el" href="classTooN_1_1SymEigen.html">SymEigen </a> and <a class="el" href="classTooN_1_1Cholesky.html">Cholesky </a><p>
If all you want to do is solve a single Ax=b then you may want gaussian_elimination<h3><a class="anchor" name="sOtherStuff">
What other stuff is there:</a></h3>
Optimization: WLS, IRLS, downhill_simplex, SO2, SE2, SO3, SE3<h3><a class="anchor" name="sHandyFuncs">
What handy functions are there (normalize, identity, fill, etc...)?</a></h3>
<h3><a class="anchor" name="sNoInplace">
Why don't functions work in place?</a></h3>
Consider the function: <div class="fragment"><pre class="fragment">        <span class="keywordtype">void</span> func(Vector&lt;3&gt;&amp; v);
</pre></div> It can accept a <code>Vector&lt;3&gt;</code> by reference, and operate on it in place. A <code>Vector&lt;3&gt;</code> is a type which allocates memory on the stack. A slice merely references memory, and is a subtly different type. To write a function taking any kind of vector (including slices) you can write:<p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Base&gt; <span class="keywordtype">void</span> func(Vector&lt;3, double, Base&gt;&amp; v);
</pre></div><p>
A slice is a temporary object, and according to the rules of C++, you can't pass a temporary to a function as a non-const reference. <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> provides the <code>.ref()</code> method to escape from this restriction, by returning a reference as a non-temporary. You would then have to write: <div class="fragment"><pre class="fragment">        Vector&lt;4&gt; v;
        ...
        func(v.slice&lt;0,3&gt;().ref());
</pre></div> to get func to accept the slice.<p>
Alternatively, you can observe that only <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> objects with the default base class own the data. All other sorts are references, so copying them only copies the reference, and the referred data is the same. You could therefore write a function to forward on <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> objects with the default base:<p>
<div class="fragment"><pre class="fragment">        <span class="keyword">template</span>&lt;<span class="keyword">class</span> Base&gt; <span class="keywordtype">void</span> func(Vector&lt;3, double, Base&gt; v); <span class="comment">//This will operate in-place only on slices</span>

        <span class="keywordtype">void</span> func(Vector&lt;3&gt;&amp; v) <span class="comment">//This will catch any non-slices and forward them on.</span>
        {
            func(v.as_slice());
        }
</pre></div><p>
However, please consider writing functions that do not modify structures in place. The <code>unit</code> function of <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> computes a unit vector given an input vector. In the following context, the code: <div class="fragment"><pre class="fragment">        <span class="comment">//There is some Vector, which may be a slice, etc called v;</span>
        v = unit(v);
</pre></div> produces exactly the same compiler output as the hypothetical <code>Normalize(v)</code> which operates in place (for static vectors). Consult the ChangeLog entries dated ``Wed 25 Mar, 2009 20:18:16'' and ``Wed 1 Apr, 2009 16:48:45'' for further discussion.<h3><a class="anchor" name="sColMajor">
Can I have a column major matrix?</a></h3>
Yes! <div class="fragment"><pre class="fragment">        Matrix&lt;3, 3, double, ColMajor&gt; m;          <span class="comment">//3x3 Column major matrix</span>
</pre></div><h3><a class="anchor" name="sWrap">
I have a pointer to a bunch of data. How do I turn it in to a vector/matrix without copying?</a></h3>
To create a vector use: <div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4};
    Vector&lt;4,double,Reference&gt; v1(d);
    Vector&lt;Dynamic,double,Reference&gt; v2(d,4);
</pre></div> Or, a functional form can be used: <div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4};

    wrapVector&lt;4&gt;(d);         <span class="comment">//Returns a Vector&lt;4&gt;</span>
    wrapVector&lt;4,double&gt;(d);  <span class="comment">//Returns a Vector&lt;4&gt;</span>
    
    wrapVector(d,3);          <span class="comment">//Return a Vector&lt;Dynamic&gt; of size 3</span>
    wrapVector&lt;Double&gt;(d,3);  <span class="comment">//Return a Vector&lt;Dynamic&gt; of size 3</span>
</pre></div><p>
To crate a matrix use <div class="fragment"><pre class="fragment">    <span class="keywordtype">double</span> d[]={1,2,3,4,5,6};
    Matrix&lt;2,3,double,Reference::RowMajor&gt; m1(d);
    Matrix&lt;2,3,double,Reference::ColMajor&gt; m2(d);
    Matrix&lt;Dynamic, Dynamic, double, Reference::RowMajor&gt; m3(d, 2, 3);
    Matrix&lt;Dynamic, 3, double, Reference::RowMajor&gt; m4(d, 2, 3); <span class="comment">// note two size arguments are required for semi-dynamic matrices</span>
</pre></div><h3><a class="anchor" name="sGenericCode">
How do I write generic code?</a></h3>
The constructors for <a class="el" href="namespaceTooN.html" title="All classes and functions are within this namespace.">TooN</a> objects are very permissive in that they accept run-time size arguments for statically sized objects, and then discard the values, This allows you to easily write generic code which works for both static and dynamic inputs.<p>
Here is a function which mixes up a vector with a random matrix: <div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision, <span class="keyword">class</span> Base&gt; Vector&lt;Size, Precision&gt; mixup(<span class="keyword">const</span> Vector&lt;Size, Precision, Base&gt;&amp; v)
    {
        <span class="comment">//Create a square matrix, of the same size as v. If v is of dynamic</span>
        <span class="comment">//size, then Size == Dynamic, and so Matrix will also be dynamic. In</span>
        <span class="comment">//this case, TooN will use the constructor arguments to select the</span>
        <span class="comment">//matrix size. If Size is a real size, then TooN will simply ighore</span>
        <span class="comment">//the constructor values.</span>

        Matrix&lt;Size, Size, Precision&gt; m(v.size(), v.size());
        
        <span class="comment">//Fill the matrix with random values that sum up to 1.</span>
        Precision sum=0;
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; v.size(); i++)
            <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j &lt; v.size(); j++)
                sum += (m[i][j] = rand());
        
        m/= sum;

        <span class="keywordflow">return</span> m * v;
    }
</pre></div><p>
Writing functions which safely accept multiple objects requires assertions on the sizes since they may be either static or dynamic. TooN's built in size check will fail at compile time if mismatched static sizes are given, and at run-time if mismatched dynamic sizes are given:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> S1, <span class="keyword">class</span> B1, <span class="keywordtype">int</span> S2, <span class="keyword">class</span> B2&gt; <span class="keywordtype">void</span> func_of_2_vectors(<span class="keyword">const</span> Vector&lt;S1, double, B1&gt;&amp; v1, <span class="keyword">const</span> Vector&lt;S2, double, B2&gt;&amp; v2)
    {
        <span class="comment">//Ensure that vectors are the same size</span>
        SizeMismatch&lt;S1, S2&gt;::test(v1.num_rows(), v2.num_rows());


    }
</pre></div><h3><a class="anchor" name="ssExamples">
Are there any examples?</a></h3>
Create two vectors and work out their inner (dot), outer and cross products <div class="fragment"><pre class="fragment"><span class="comment">// Initialise the vectors</span>
Vector&lt;3&gt; a = makeVector(3,5,0);
Vector&lt;3&gt; b = makeVector(4,1,3);

<span class="comment">// Now work out the products</span>
<span class="keywordtype">double</span> dot = a*b;                            <span class="comment">// Dot product</span>
Matrix&lt;3,3&gt; outer = a.as_col() * b.as_row(); <span class="comment">// Outer product</span>
Vector&lt;3&gt; cross = a ^ b;                     <span class="comment">// Cross product</span>

cout &lt;&lt; <span class="stringliteral">"a:"</span> &lt;&lt; endl &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">"b:"</span> &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">"Outer:"</span> &lt;&lt; endl &lt;&lt; outer &lt;&lt; endl;
cout &lt;&lt; <span class="stringliteral">"Cross:"</span> &lt;&lt; endl &lt;&lt; cross &lt;&lt; endl;
</pre></div><p>
Create a vector and a matrix and multiply the two together <div class="fragment"><pre class="fragment"><span class="comment">// Initialise a vector</span>
Vector&lt;3&gt; v = makeVector(1,2,3);

<span class="comment">// Initialise a matrix</span>
Matrix&lt;2,3&gt; M(d);
M[0] = makeVector(2,4,5);
M[1] = makeVector(6,8,9);

<span class="comment">// Now perform calculations</span>
Vector&lt;2&gt; v2 = M*v;  <span class="comment">// OK - answer is a static 2D vector</span>
Vector&lt;&gt; v3 = M*v;   <span class="comment">// OK - vector is determined to be 2D at runtime</span>
Vector&lt;&gt; v4 = v*M;   <span class="comment">// Compile error - dimensions of matrix and vector incompatible</span>
</pre></div><h3><a class="anchor" name="sImplementation">
How is it implemented</a></h3>
<h4><a class="anchor" name="ssStatic">
Static-sized vectors and matrices</a></h4>
One aspect that makes this library efficient is that when you declare a 3-vector, all you get are 3 doubles - there's no metadata. So <code>sizeof(Vector&lt;3&gt;)</code> is 24. This means that when you write <code>Vector&lt;3&gt; v;</code> the data for <code>v</code> is allocated on the stack and hence <code>new</code>/<code>delete</code> (<code>malloc</code>/<code>free</code>) overhead is avoided. However, for large vectors and matrices, this would be a Bad Thing since <code>Vector&lt;1000000&gt; v;</code> would result in an object of 8 megabytes being allocated on the stack and potentially overflowing it. TooN gets around that problem by having a cutoff at which statically sized vectors are allocated on the heap. This is completely transparent to the programmer, the objects' behaviour is unchanged and you still get the type safety offered by statically sized vectors and matrices. The cutoff size at which the library changes the representation is defined in <code><a class="el" href="TooN_8h-source.html">TooN.h</a></code> as the <code>const int TooN::Internal::max_bytes_on_stack=1000;</code>.<p>
When you apply the subscript operator to a <code>Matrix&lt;3,3&gt;</code> and the function simply returns a vector which points to the the apropriate hunk of memory as a reference (i.e. it basically does no work apart from moving around a pointer). This avoids copying and also allows the resulting vector to be used as an l-value. Similarly the transpose operation applied to a matrix returns a matrix which referes to the same memory but with the opposite layout which also means the transpose can be used as an l-value so <code>M1 = M2.T();</code> and <code>M1.T() = M2;</code> do exactly the same thing.<p>
<b> Warning: This also means that <code>M = M.T();</code> does the wrong thing.</b> However, since .T() essentially costs nothing, it should be very rare that you need to do this.<h4><a class="anchor" name="ssDynamic">
Dynamic sized vectors and matrices</a></h4>
These are implemented in the obvious way using metadata with the rule that the object that allocated on the heap also deallocates. Other objects may reference the data (e.g. when you subscript a matrix and get a vector).<h3><a class="anchor" name="ssLazy">
Return value optimisation vs Lazy evaluation</a></h3>
When you write <code>v1 = M * v2;</code> a naive implementation will compute <code>M * v2</code> and store the result in a temporary object. It will then copy this temporary object into <code>v1</code>. A method often advanced to avoid this is to have <code>M * v2</code> simply return an special object <code>O</code> which contains references to <code>M</code> and <code>v2</code>. When the compiler then resolves <code>v1 = O</code>, the special object computes <code>M*v2</code> directly into <code>v1</code>. This approach is often called lazy evaluation and the special objects lazy vectors or lazy matrices. Stroustrup (The C++ programming language Chapter 22) refers to them as composition closure objects or compositors.<p>
The killer is this: <b>What if v1 is just another name for v2?</b> i.e. you write something like <code>v = M * v;</code>. In this case the semantics have been broken because the values of <code>v</code> are being overwritten as the computation progresses and then the remainder of the computation is using the new values. In this library <code>v1</code> in the expression could equally well alias part of <code>M</code>, thus you can't even solve the problem by having a clever check for aliasing between <code>v1</code> and <code>v2</code>. This aliasing problem means that the only time the compiler can assume it's safe to omit the temporary is when <code>v1</code> is being constructed (and thus cannot alias anything else) i.e. <code>Vector&lt;3&gt; v1 = M * v2;</code>.<p>
TooN provides this optimisation by providing the compiler with the opportunity to use a return value optimisation. It does this by making <code>M * v2</code> call a special constructor for <code>Vector&lt;3&gt;</code> with <code>M</code> and <code>v2</code> as arguments. Since nothing is happening between the construction of the temporary and the copy construction of <code>v1</code> from the temporary (which is then destroyed), the compiler is permitted to optimise the construction of the return value directly into <code>v1</code>.<p>
Because a naive implemenation of this strategy would result in the vector and matrix classes having a very large number of constructors, these classes are provided with template constructors that take a standard form. The code that does this, declared in the header of class <code>Vector</code> is:<p>
<div class="fragment"><pre class="fragment">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Op&gt;
    <span class="keyword">inline</span> Vector(<span class="keyword">const</span> Operator&lt;Op&gt;&amp; op)
        : Base::template VLayout&lt;Size, Precision&gt; (op)
    {
        op.eval(*<span class="keyword">this</span>);
    }
</pre></div><h4><a class="anchor" name="ssHow">
How it all really works</a></h4>
This documentation is generated from a cleaned-up version of the interface, hiding the implementation that allows all of the magic to work. If you want to know more and can understand idioms like: <div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt;<span class="keywordtype">int</span>, <span class="keyword">typename</span>, <span class="keywordtype">int</span>, <span class="keyword">typename</span>&gt; <span class="keyword">struct </span>GenericVBase;
<span class="keyword">template</span>&lt;<span class="keywordtype">int</span>, <span class="keyword">typename</span>&gt; <span class="keyword">struct </span>VectorAlloc;

<span class="keyword">struct </span>VBase {
    <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision&gt;
    <span class="keyword">struct </span>VLayout : <span class="keyword">public</span> GenericVBase&lt;Size, Precision, 1, VectorAlloc&lt;Size, Precision&gt; &gt; {
        ...
    };
};

<span class="keyword">template</span> &lt;<span class="keywordtype">int</span> Size, <span class="keyword">class</span> Precision, <span class="keyword">class</span> Base=VBase&gt;
<span class="keyword">class </span>Vector: <span class="keyword">public</span> Base::template VLayout&lt;Size, Precision&gt; {
   ...
};
</pre></div><p>
then take a look at the source code ... <hr size="1"><address style="text-align: right;"><small>Generated on Thu May 7 20:28:40 2009 for TooN by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
