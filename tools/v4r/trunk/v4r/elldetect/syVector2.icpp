//
// (C) 2010, Aitor Aldoma Buchaca,
//           Johann Prankl,
//           Gerhard Obernberger <gerhard@obernberger.at>
//
//

#ifndef _SYVECTOR2_ICPP
#define _SYVECTOR2_ICPP

#include <math.h>
#include <sstream>
#include "SMath.h"

NAMESPACE_CLASS_BEGIN( RTE )

/**
 * Fast constructor e.g. for constructing large arrays of vectors.
 * values are uninitialised
 */
inline CzVector2::CzVector2()
{
}

inline CzVector2::CzVector2(double xx, double yy)
: x(xx), y(yy)
{
}

inline CzVector2& CzVector2::operator+=(const CzVector2 &v)
{
  x += v.x;
  y += v.y;
  return *this;
}

inline CzVector2& CzVector2::operator-=(const CzVector2 &v)
{
  x -= v.x;
  y -= v.y;
  return *this;
}

inline CzVector2& CzVector2::operator*=(double s)
{
  x *= s;
  y *= s;
  return *this;
}

inline CzVector2& CzVector2::operator/=(double s) __THROW_EXCEPT
{
  if(s == 0)
    throw CzExcept(__HERE__, "division by zero");
  x /= s;
  y /= s;
  return *this;
}

inline double CzVector2::NormSquare() const
{
  return x*x + y*y;
}

inline double CzVector2::LengthSquare() const
{
  return NormSquare();
}

inline double CzVector2::Norm() const
{
  return sqrt(x*x + y*y);
}

inline double CzVector2::Length() const
{
  return Norm();
}

inline void CzVector2::Normalise()
{
  double n = Norm();
  *this /= n;
}

inline CzVector2 CzVector2::Normal()
{
  return CzVector2(-y, x);
}

/**
 * Clockwise (mathematically negative) rotation, i.e. rotation to the right.
 * ATTENTION: For typical image co-ordinate systems with x-axis pointiing to
 * the right and y-axis pointing downwards things are reversed: clockwise
 * rotation in this case means rotation to the left.
 */
inline CzVector2 CzVector2::NormalClockwise()
{
  return CzVector2(y, -x);
}

/**
 * Anti-clockwise (mathematically positive) rotation, i.e. rotation to the left.
 * ATTENTION: For typical image co-ordinate systems with x-axis pointiing to
 * the right and y-axis pointing downwards things are reversed: anti-clockwise
 * rotation in this case means rotation to the right.
 */
inline CzVector2 CzVector2::NormalAntiClockwise()
{
  return CzVector2(-y, x);
}

inline CzVector2 operator-(const CzVector2 &v)
{
  return CzVector2(-v.x, -v.y);
}

inline bool operator==(const CzVector2 &a, const CzVector2 &b)
{
  return IsEqual(a.x, b.x) && IsEqual(a.y, b.y);
}

inline bool operator!=(const CzVector2 &a, const CzVector2 &b)
{
  return !operator==(a, b);
}

inline CzVector2 operator+(const CzVector2 &a, const CzVector2 &b)
{
  return CzVector2(a.x + b.x, a.y + b.y);
}

inline CzVector2 operator-(const CzVector2 &a, const CzVector2 &b)
{
  return CzVector2(a.x - b.x, a.y - b.y);
}

inline CzVector2 operator*(const double s, const CzVector2 &v)
{
  return CzVector2(v.x*s, v.y*s);
}

inline CzVector2 operator*(const CzVector2 &v, const double s)
{
  return s*v;
}

inline CzVector2 operator/(const CzVector2 &v, const double s) __THROW_EXCEPT
{
  if(s == 0)
    throw CzExcept(__HERE__, "division by zero");
  return CzVector2(v.x/s, v.y/s);
}

inline double PolarAngle(CzVector2 &v)
{
  return atan2(v.y, v.x);
}

inline double Length(const CzVector2 &v)
{
  return v.Norm();
}

inline CzVector2 Normalise(const CzVector2 &v)
{
  double n = v.Norm();
  return v/n;
}

inline double Dot(const CzVector2 &a, const CzVector2 &b)
{
  return a.x*b.x + a.y*b.y;
}

/**
 * Vector cross product.
 * note: positive cross product a x b means b counterclockwise (i.e. left) to a
 */
inline double Cross(const CzVector2 &a, const CzVector2 &b)
{
  return a.x*b.y - a.y*b.x;
}

/**
 * Returns true if b is left of a.
 * Same as counterclockwise.
 */
inline bool LeftOf(const CzVector2 &a, const CzVector2 &b)
{
  return Cross(a, b) > 0.;
}

/**
 * Returns true if b is counterclockwise to a.
 * Same as left of.
 */
inline bool CounterClockwiseTo(const CzVector2 &a, const CzVector2 &b)
{
  return Cross(a, b) > 0.;
}

/**
 * Returns true if b is right of a.
 * Same as clockwise.
 */
inline bool RightOf(const CzVector2 &a, const CzVector2 &b)
{
  return Cross(a, b) < 0.;
}

/**
 * Returns true if b is clockwise to a.
 * Same as right of.
 */
inline bool ClockwiseTo(const CzVector2 &a, const CzVector2 &b)
{
  return Cross(a, b) < 0.;
}

inline double DistanceSquare(const CzVector2 &a, const CzVector2 &b)
{
  return Sqr(a.x - b.x) + Sqr(a.y - b.y);
}

inline double Distance(const CzVector2 &a, const CzVector2 &b)
{
  return sqrt(Sqr(a.x - b.x) + Sqr(a.y - b.y));
}

/*
 * Calculate center of circle from 3 points.
 * note: throws an exception if center cannot be calculated.
 */
inline CzVector2 CircleCenter(const CzVector2 &pi, const CzVector2 &pj,
   const CzVector2 &pk)
{
  // throws an exception if intersection cannot be calculated
  return LineIntersection(
      CzVector2((pi.x + pj.x)/2., (pi.y + pj.y)/2.),
      CzVector2(pj.y - pi.y, pi.x - pj.x),
      CzVector2((pj.x + pk.x)/2., (pj.y + pk.y)/2.),
      CzVector2(pk.y - pj.y, pj.x - pk.x));
}

/**
 * Returns signed distance of point q from line defined by point p and unit
 * direction vector d.
 */
inline double DistPointToLine(const CzVector2 &q, const CzVector2 &p,
    const CzVector2 &d)
{
  CzVector2 p_to_q = q - p;
  return Cross(p_to_q, d);
}

inline double AbsDistPointToLine(const CzVector2 &q, const CzVector2 &p,
    const CzVector2 &d)
{
  return fabs(DistPointToLine(q, p, d));
}

inline CzVector2 Rotate(const CzVector2 &a, double phi)
{
  double si = sin(phi), co = cos(phi);
  return CzVector2(co*a.x - si*a.y, si*a.x + co*a.y);
}

inline CzVector2 MidPoint(const CzVector2 &a, const CzVector2 &b)
{
  return CzVector2((a.x + b.x)/2., (a.y + b.y)/2.);
}

/**
 * Print a vector to a stream: '[x y]`
 */
inline ostream& operator<<(ostream &os, const CzVector2 &v)
{
  return os << '[' << v.x << ' ' << v.y <<  ']';
}

/**
 * Read a vector from a stream.
 * The expected format is: '[x y]', white spaces are ignored.
 */
inline istream& operator>>(istream &is, CzVector2 &v) __THROW_EXCEPT
{
  char c;
  is >> c;
  if(c == '[')
  {
    is >> v.x >> v.y >> c;
    if(c != ']')
      throw CzExcept(__HERE__, "error reading CzVector2: ']' expected");
  }
  else
  {
    throw CzExcept(__HERE__, "error reading CzVector2: '[' expected");
  }
  return is;
}

/**
 * Append a vector to a string: '[x y]`
 * Actually You should use stringstreams instead.
 */
inline string& operator<<(string &s, const CzVector2 &v)
{
  stringstream ss;
  ss << v;
  s += ss.str();
  return s;
}

/**
 * Reads a point from the BEGINNING of a string. Subsequent calls of operator<<
 * will always return the same point.
 * The expected format is: '[x y]', white spaces are ignored.
 * Actually You should use stringstreams instead.
 */
inline const string& operator>>(const string &s, CzVector2 &v)
{
  stringstream ss(s);
  ss >> v;
  return s;
}

NAMESPACE_CLASS_END()

#endif

