//
// (C) 2010, Aitor Aldoma Buchaca,
//           Johann Prankl,
//           Gerhard Obernberger <gerhard@obernberger.at>
//
//

#ifndef  _SYARRAY_ICPP
#define  _SYARRAY_ICPP

#include "multiplatform.hpp"

#include "SMath.h"

NAMESPACE_CLASS_BEGIN( RTE )

#ifdef DEBUG_CHECKINDEX
// this non-inline, non-template function enables the debugger to set a
// breakpoint
extern void CheckIndex(unsigned i, unsigned size);
#endif

////////////////////////////////////////////////////////////////////////////////
// Constructor with supplied initial size.
template <class CzElem>
CzArray<CzElem>::CzArray(unsigned s) __THROW_EXCEPT
{
  capacity = s;
  if(capacity > 0)
  {
    array = new CzElem[capacity];
    if(array == 0)
      throw CzExcept(__HERE__, "%s: failed to allocate array");
  }
  else
    array = 0;
  size = capacity;
}

////////////////////////////////////////////////////////////////////////////////
// Constructor with initial Array
template <class CzElem>
CzArray<CzElem>::CzArray(const CzArray &a)
{
  capacity = 0;
  size = 0;
  array = 0;
  DeepCopy(a);
}

////////////////////////////////////////////////////////////////////////////////
// Destructor, just frees memory.
template <class CzElem>
CzArray<CzElem>::~CzArray()
{
  delete[] array;
}

////////////////////////////////////////////////////////////////////////////////
// Check if the given index is valid
template <class CzElem>
inline void CzArray<CzElem>::CheckIndex(unsigned i) const __THROW_EXCEPT
{
#ifdef DEBUG_CHECKINDEX
  RTE::CheckIndex(i, size);
#else
  if(i >= size)
    throw CzExcept(__HERE__, "invalid index %u, valid range [0,%u)", i, size);
#endif
}

////////////////////////////////////////////////////////////////////////////////
// Checked index operator.
template <class CzElem>
inline CzElem& CzArray<CzElem>::operator[](unsigned i)
{
  CheckIndex(i);
  return array[i];
}

////////////////////////////////////////////////////////////////////////////////
// Checked const index operator.
template <class CzElem>
inline const CzElem& CzArray<CzElem>::operator[](unsigned i) const
{
  CheckIndex(i);
  return array[i];
}

////////////////////////////////////////////////////////////////////////////////
// return first element
template <class CzElem>
inline CzElem& CzArray<CzElem>::First() __THROW_EXCEPT
{
  if(size == 0)
    throw CzExcept(__HERE__, "array empty");
  return array[0];
}

////////////////////////////////////////////////////////////////////////////////
// return first element
template <class CzElem>
inline const CzElem& CzArray<CzElem>::First() const __THROW_EXCEPT
{
  if(size == 0)
    throw CzExcept(__HERE__, "array empty");
  return array[0];
}

////////////////////////////////////////////////////////////////////////////////
// returns last element
template <class CzElem>
inline CzElem& CzArray<CzElem>::Last() __THROW_EXCEPT
{
  if(size == 0)
    throw CzExcept(__HERE__, "array empty");
  return array[size - 1];
}

////////////////////////////////////////////////////////////////////////////////
// returns last element
template <class CzElem>
inline const CzElem& CzArray<CzElem>::Last() const __THROW_EXCEPT
{
  if(size == 0)
    throw CzExcept(__HERE__, "array empty");
  return array[size - 1];
}

////////////////////////////////////////////////////////////////////////////////
// Grow the array if necessary. 
// More memory is allocated, used size remains unchanged
template <class CzElem>
void CzArray<CzElem>::EnsureCapacity(unsigned need_size) __THROW_EXCEPT
{
  if(need_size > capacity)
  {
    capacity = max(need_size, capacity > 0 ? 2*capacity : DEFAULT_SIZE);
    CzElem *new_array = new CzElem[capacity];
    if(new_array == 0)
      throw CzExcept(__HERE__, "failed to allocate array");
    for(unsigned i = 0; i < size; i++)
      new_array[i] = array[i];
    delete[] array;
    array = new_array;
  }
}

////////////////////////////////////////////////////////////////////////////////
// Set size of array, growing if necessary.
template <class CzElem>
void CzArray<CzElem>::Resize(unsigned new_size)
{
  EnsureCapacity(new_size);
  size = new_size;
}

////////////////////////////////////////////////////////////////////////////////
// Add a new element to the start of the array.
// If necessary the array grows (to double its original size).
// Note: this is an expensive operation requiring n shifts.
template <class CzElem>
void CzArray<CzElem>::PushFront(const CzElem &el)
{
  Resize(size + 1);
  for(unsigned i = size - 1; i > 0; i--)
    array[i] = array[i-1];
  array[0] = el;
}

////////////////////////////////////////////////////////////////////////////////
// Add a new element to the end of the array.
// If necessary the array grows (to double its original size).
template <class CzElem>
void CzArray<CzElem>::PushBack(const CzElem &el)
{
  Resize(size + 1);
  array[size - 1] = el;
}

////////////////////////////////////////////////////////////////////////////////
// Insert element before element i.
template <class CzElem>
void CzArray<CzElem>::InsertBefore(unsigned i, const CzElem &el)
{
  CheckIndex(i);
  Resize(size + 1);
  for(unsigned j = size - 1; j > i; j--)
    array[j] = array[j-1];
  array[i] = el;
}

////////////////////////////////////////////////////////////////////////////////
// Insert element after element i.
template <class CzElem>
void CzArray<CzElem>::InsertAfter(unsigned i, const CzElem &el)
{
  CheckIndex(i);
  Resize(size + 1);
  for(unsigned j = size - 1; j > i + 1; j--)
    array[j] = array[j-1];
  array[i + 1] = el;
}

////////////////////////////////////////////////////////////////////////////////
// Sort array according to given compare function.
template <class CzElem>
void CzArray<CzElem>::Sort(int(*compar)(const void *, const void *))
{
  qsort(array, size, sizeof(CzElem), compar);
}

////////////////////////////////////////////////////////////////////////////////
// Returns true if the given item is in the array, false otherwise.
template <class CzElem>
bool CzArray<CzElem>::Contains(const CzElem &el) const
{
  for(unsigned i = 0; i < size; i++)
    if(array[i] == el)
      return true;
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// Returns true if the given item is in the array, false otherwise.
// Starts seach at the end.
template <class CzElem>
bool CzArray<CzElem>::ContainsBackwards(const CzElem &el) const
{
  // note that size - 1 would be max unsigned int for size == 0
  for(unsigned i = size; i >= 1; i--)
    if(array[i-1] == el)
      return true;
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// Returns the index of the first occurrence of element or UNDEF_ID if element
// is not contained.
template <class CzElem>
unsigned CzArray<CzElem>::Find(const CzElem &el)
{
  for(unsigned i = 0; i < size; i++)
    if(array[i] == el)
      return i;
  return UNDEF_ID;
}

////////////////////////////////////////////////////////////////////////////////
// Returns the index of the first occurrence of element after (including) start
// or UNDEF_ID if element is not contained.
template <class CzElem>
unsigned CzArray<CzElem>::Find(unsigned start, const CzElem &el)
{
  for(unsigned i = start; i < size; i++)
    if(array[i] == el)
      return i;
  return UNDEF_ID;
}

////////////////////////////////////////////////////////////////////////////////
// Returns the index of the last occurrence of element or UNDEF_ID if element
// is not contained.
template <class CzElem>
unsigned CzArray<CzElem>::FindBackwards(const CzElem &el)
{
  // note that size - 1 would be max unsigned int for size == 0
  for(unsigned i = size; i >= 1; i--)
    if(array[i-1] == el)
      return i-1;
  return UNDEF_ID;
}

////////////////////////////////////////////////////////////////////////////////
// Swap elements i and j
template <class CzElem>
void CzArray<CzElem>::Swap(unsigned i, unsigned j)
{
  CheckIndex(i);
  CheckIndex(j);
  CzElem t = array[i];
  array[i] = array[j];
  array[j] = t;
}

////////////////////////////////////////////////////////////////////////////////
// Set all elements to given value.
template <class CzElem>
void CzArray<CzElem>::Set(const CzElem &el)
{
  for(unsigned i = 0; i < size; i++)
    array[i] = el;
}

////////////////////////////////////////////////////////////////////////////////
// Copy whole array
template <class CzElem>
void CzArray<CzElem>::DeepCopy(const CzArray &a)
{
  Resize(a.size);
  for(unsigned i = 0; i < size; i++)
    array[i] = a.array[i];
}

////////////////////////////////////////////////////////////////////////////////
// Return next element. Treat array as a ring buffer.
template <class CzElem>
inline unsigned CzArray<CzElem>::CircularNext(unsigned i)
{
  if(i < size - 1)
    return i + 1;
  else
    return 0;
}

////////////////////////////////////////////////////////////////////////////////
// Return previous element. Treat array as a ring buffer
template <class CzElem>
inline unsigned CzArray<CzElem>::CircularPrev(unsigned i)
{
  if(i > 0)
    return i - 1;
  else
    return size - 1;
}

////////////////////////////////////////////////////////////////////////////////
// remove element
template <class CzElem>
void CzArray<CzElem>::Erase(unsigned i)
{
  CheckIndex(i);
  while(++i < size)
    array[i-1] = array[i];
  size--;
}

////////////////////////////////////////////////////////////////////////////////
// remove first element
template <class CzElem>
inline void CzArray<CzElem>::EraseFirst()
{
  Erase(0);
}

////////////////////////////////////////////////////////////////////////////////
// remove last element
template <class CzElem>
inline void CzArray<CzElem>::EraseLast()
{
  Erase(size-1);
}

////////////////////////////////////////////////////////////////////////////////
// reverse array
template <class CzElem>
void CzArray<CzElem>::Reverse()
{
  if(size > 0)
  {
    CzElem t;
    unsigned l = 0, u = size - 1;
    while(l < u)
    {
      t = array[l];
      array[l] = array[u];
      array[u] = t;
      l++;
      u--;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// Insert element and sort list.
template <class CzElem>
void CzArray<CzElem>::InsertSorted(const CzElem &el,
    int(*compar)(const void *, const void *))
{
  PushBack(el);
  Sort(compar);
}

////////////////////////////////////////////////////////////////////////////////
// Returns whether both arrays share an element.
template <class CzElem>
bool CzArray<CzElem>::Intersect(const CzArray<CzElem> &a)
{
  for(unsigned i = 0; i < size; i++)
    if(a.Contains(array[i]))
      return true;
  return false;
}

////////////////////////////////////////////////////////////////////////////////
// Return a data pointer
template <class CzElem>
void* CzArray<CzElem>::Data()
{
  return (void*)array;
}


NAMESPACE_CLASS_END()

#endif
