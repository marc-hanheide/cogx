package comsys.components.tts;
import java.io.*;
import java.util.*;

import de.dfki.lt.mary.client.MaryClient;

public class EyeTrackerGenerateWavFiles {
	private static BufferedReader l_CSVbfr;	
	
	
	private static String g_Lang="";
	
	private static String l_space= new String(" ");
	private static String l_Ls = new String ("@L*");
	private static String l_HHp = new String ("HH%");
	private static String l_outputloc;
	private static String l_outputloc_mary;
	/**This function generates mary wav file. 
	 * Input Argument
	 * ## Mary voice .e.g. de07
	 * ## A csv file : A stimuli csv sheet is generated by GenEyeStimuli.java.
	 */
	public static void main(String[] args) {
		
		String l_rawmary="";
		
		if(args.length<3) {
			System.out.println("Usage: program MaryLangOpt \"CSV file containing the experiment\"");
			System.exit(0);
		}
		
		//First argument to this program in the language code
		g_Lang=args[0];
		try{
			if(g_Lang.contains("de"))
				l_rawmary = new String("./subarchitectures/comsys/src/java/comsys/components/tts/DE_RAWMARYXMLhead.xml");	
			else l_rawmary = new String("./subarchitectures/comsys/src/java/comsys/components/tts/ENG_RAWMARYXMLhead.xml");
		
			//second argument to this program is the csv file (absolute location).
			FileReader l_CSVreader = new FileReader(args[1]);
		
			//third argument to this program is the location where we save the Mary files 
			l_outputloc = new String(args[2]);
		
			//Generated Mary files are located here
			l_outputloc_mary = new String(l_outputloc.concat("/"+g_Lang+"/"));
			
			ProsodicTextToRawMARYXml l_prs2xml = new ProsodicTextToRawMARYXml(l_rawmary,l_outputloc_mary,"EyeT");
		
		
			MaryClient l_mary = new MaryClient("localhost", 59125);
			//MaryClient l_mary = MaryClient.getMaryClient();
			TTSLocal l_ttslocal = new TTSLocal(l_mary,"RAWMARYXML", g_Lang, false, "WAVE");
			SynthesisRAWMaryXMLInput l_synthsis = new SynthesisRAWMaryXMLInput(l_ttslocal);
		
			//Read the specified csv file
			l_CSVbfr = new BufferedReader(l_CSVreader);	
			String l_str = null;
			Integer l_ctr= 0;
		
			//Declare variables to store necessary columns
			String l_utter = new String();
			String l_prsutter = new String();
			String l_audioFilename = new String();
			String l_tune = new String();
			
			
			//Read each row in this csv file, and process as per columan values.
			while((l_str= l_CSVbfr.readLine())!= null){
				++l_ctr;
				if(l_ctr==1) continue; //First row is the header so skip it
				
				System.out.println(l_ctr + " : CSV string-->"+ l_str);
			
				//Since the file is a Comma Seperated File, tokenize them with a comma.
				StringTokenizer l_stkn = new StringTokenizer(l_str, ",");
			
				/*	Rest of the processing very much depends on the CSV columsn. 
					Any change in CSV columns will require changes here.
				 */
				//Get Utterance, for that skip first 8 columns
				SkipColumns(l_stkn, 8);
				l_utter=l_stkn.nextToken().trim();
				//Skip twp more for tunes
				SkipColumns(l_stkn, 2);
				l_tune = l_stkn.nextToken();
				//Skip 8 more for wave file name
				SkipColumns(l_stkn, 8);
				l_audioFilename=l_stkn.nextToken();
			
				//Check if skipping was right
				System.out.println("We have got: "+l_utter+"--"+l_tune+"--"+l_audioFilename);
			
				//So we got the important stuff we need from the CSV file, now process these
			
				//Now convert the plain text utterance to a prosodic-utterance 
				// correponding to its tune specified in the csv file
				l_prsutter = UtteranceToProsodic(l_utter, l_tune);
				
				System.out.println("Prosodic utter: "+l_prsutter);
									
				//Make a RAWMaryXML filename we want to use for Wav files (as discussed it is itemNum+tune)
				l_prs2xml.g_xmlfilename=l_audioFilename.replaceFirst("wav", "xml");
				
				//Generate RAWMaryXMl for the prosodic-utterance.
				String l_xmlfile = new String();
				l_xmlfile=l_prs2xml.ConvertToRawMarxXml(l_prsutter);
				//System.out.println("XML file written: ["+l_xmlfile+"]");
				
				//feed this RAWMaryxml to Mary to generate a audio file and save it to disk
				l_ttslocal.m_AudioFileName=l_outputloc_mary.concat(l_prs2xml.g_xmlfilename);
				l_ttslocal.m_SaveAudio2Wav=true;
				l_synthsis.Save2Wave(l_outputloc_mary.concat(l_prs2xml.g_xmlfilename));
				//Sound fine generation is done.
				if(l_ctr==2)break;	
		}//end While read csv, Now close the buffer
		 		
	}
	catch (Exception e) {
       	e.printStackTrace();
       	System.exit(0);
	}
	finally {
		try {
			l_CSVbfr.close();
		}catch(Exception e) {
	     	e.printStackTrace();
	     	System.exit(0);
		}
	}
	} //End of Main 	
	
	private static void SkipColumns(StringTokenizer i_stk, int i_skipVal) {
		for(int i=0;i<i_skipVal;i++)
		{
			i_stk.nextToken(); //Skip the first 8 column
		}
	}
	
	/**
	 * This function converts a plaing text utterance to prosodic utterance.
	 * @param i_utter Utterance
	 * @param i_tune  Intonation
	 * @return A sentence with intonation marking
	 */
	private static String UtteranceToProsodic(String i_utter, String i_tune){
		
		StringTokenizer l_uttertkn = new StringTokenizer(i_utter," ");
		String l_tkn = new String("");
		
		//System.out.println("input:" + i_utter + " tune: " +i_tune + " char:"+ i_tune.charAt(0));
		
		switch (i_tune.charAt(0)) {
		
		case 'A' : //Is that a red@L* box HH%
			while(l_uttertkn.hasMoreTokens()){
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red@L*
				l_tkn= l_tkn.concat(l_Ls);
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_HHp); //HH%
			}
			return l_tkn;
			
		
		case 'B' : //Is that a red box@L* HH%
			while(l_uttertkn.hasMoreTokens()){
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box@L*
				l_tkn= l_tkn.concat(l_Ls);
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_HHp);
			}
			return l_tkn;
			
		
		case 'C' : //Is that@L* a red box HH%
			while(l_uttertkn.hasMoreTokens()){
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that@L*
			l_tkn= l_tkn.concat(l_Ls);
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_HHp);
		}
		return l_tkn;
		
		
		
		case 'D' :while(l_uttertkn.hasMoreTokens()){
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is@L*
			l_tkn= l_tkn.concat(l_Ls);
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_HHp);
		}
		return l_tkn;
		default: System.out.println("Invalid tune. Tune has to be A, B , C or D type");
	}
		return "No Tune specified";
	}	
} //end class
