package comsys.components.tts;
import java.io.*;
import java.util.*;

import marytts.client.MaryClient;

public class EyeTrackerGenerateWavFiles {
	private static BufferedReader l_CSVbfr;	
	
	private static String l_space= new String(" ");
	private static String l_Ls = new String ("@L*");
	private static String l_Hs = new String ("@H*");
	private static String l_Hp = new String ("H-%");
	private static String l_Lp = new String ("L-%");
	
	private static String l_nclrAccent = new String ();
	private static String l_finalBnd = new String ();
	
	private static final String CR="CR";
	private static final String AS="AS";
	private static String l_outputloc;
	private static String l_outputloc_mary;
	
	//Mary related
	private static MaryClient m_mary;
	private static String m_Lang="";
	private static String m_locale="";
	private static String m_DE_NLPUnit="de";
	private static String m_EN_NLPUnit="en_US";
	private static String m_maryInputType= "RAWMARYXML";
	private static boolean m_marySilenMode= false;
	private static String m_maryAudioType= "WAVE";
	private static final String m_SpeechEffect = "TractScaler(amount:1.3;)";
	
	
	/**The main() function generates mary wav file. 
	 * Input Argument
	 * ## Mary voice .e.g. de07
	 * ## A csv file : A stimuli csv sheet is generated by GenEyeStimuli.java. Change in the order of columns in this CSV file 
	 * will require change in this code.
	 */
	public static void main(String[] args) {
		
		String l_rawmary="";
		
		if(args.length<3) {
			System.out.println("Usage: program MaryLangOpt \"CSV file containing the experiment\"");
			System.exit(0);
		}
		
		//First argument to this program in the language code
		m_Lang=args[0];
		try{
			if(m_Lang.contains("de")){
				m_locale=m_DE_NLPUnit;
				l_rawmary = new String("./subarchitectures/comsys/src/java/comsys/components/tts/DE_RAWMARYXMLhead.xml");	
			}
			else {
				l_rawmary = new String("./subarchitectures/comsys/src/java/comsys/components/tts/ENG_RAWMARYXMLhead.xml");
				m_locale=m_EN_NLPUnit;
			}
		
			//second argument to this program is the csv file (absolute location).
			FileReader l_CSVreader = new FileReader(args[1]);
		
			//third argument to this program is the location where we save the Mary files 
			l_outputloc = new String(args[2]);
		
			//Generated Mary files are located here
			l_outputloc_mary = new String(l_outputloc.concat("/"+m_Lang+"/"));
			
			ProsodicTextToRawMARYXml l_prs2xml = new ProsodicTextToRawMARYXml(l_rawmary,l_outputloc_mary,"EyeT");
		
		
			//MaryClient m_mary = new MaryClient("localhost", 59125);
			m_mary = MaryClient.getMaryClient();
			TTSLocal l_ttslocal = new TTSLocal(m_mary, m_maryInputType, m_Lang, m_marySilenMode,m_maryAudioType,m_SpeechEffect,m_locale);
			SynthesisRAWMaryXMLInput l_synthsis = new SynthesisRAWMaryXMLInput(l_ttslocal);
		
			//Read the specified csv file
			l_CSVbfr = new BufferedReader(l_CSVreader);	
			String l_str = null;
			Integer l_ctr= 0;
		
			//Declare variables to store necessary columns
			String l_utter = new String();
			String l_uttertype = new String();
			String l_prsutter = new String();
			String l_audioFilename = new String();
			String l_tune = new String();
			
			
			//Read each row in this csv file, and process as per columan values.
			while((l_str= l_CSVbfr.readLine())!= null){
				++l_ctr;
				if(l_ctr==1) continue; //First row is the header so skip it
				
				System.out.println("*********Processing item***********");
				System.out.println(l_ctr + " : CSV string-->"+ l_str);
			
				//Since the file is a Comma Seperated File, tokenize them with a comma.
				StringTokenizer l_stkn = new StringTokenizer(l_str, ",");
			
				/*	Rest of the processing very much depends on the CSV columsn. 
					Any change in CSV columns will require changes here.
				 */
				//Get Utterance, for that skip first 8 columns
				SkipColumns(l_stkn, 8);
				l_utter=l_stkn.nextToken().trim();
				//skip i to get Utterance type
				SkipColumns(l_stkn, 1);
				l_uttertype=l_stkn.nextToken().trim();
				//Skip twp more for tunes
				l_tune = l_stkn.nextToken();
				//Skip 8 more for wave file name
				SkipColumns(l_stkn, 8);
				l_audioFilename=l_stkn.nextToken();
			
				//Check if skipping was right
				System.out.println("We have got: "+l_utter+"--"+l_uttertype+"--"+l_tune+"--"+l_audioFilename);
			
				//So we got the important stuff we need from the CSV file, now process these
			
				//Now convert the plain text utterance to a prosodic-utterance 
				// correponding to its tune specified in the csv file
				l_prsutter = UtteranceToProsodic(l_utter, l_uttertype, l_tune);
				
				System.out.println("Prosodic utter: "+l_prsutter);
									
				//Make a RAWMaryXML filename we want to use for Wav files (as discussed it is itemNum+tune)
				l_prs2xml.g_xmlfilename=l_audioFilename.replaceFirst("wav", "xml");
				
				//Generate RAWMaryXMl for the prosodic-utterance.
				String l_xmlfile = new String();
				l_xmlfile=l_prs2xml.ConvertToRawMarxXml(l_prsutter);
				//System.out.println("XML file written: ["+l_xmlfile+"]");
				
				//feed this RAWMaryxml to Mary to generate a audio file and save it to disk
				l_ttslocal.m_AudioFileName=l_outputloc_mary.concat(l_prs2xml.g_xmlfilename);
				l_ttslocal.m_SaveAudio2Wav=true;
				l_synthsis.Save2Wave(l_outputloc_mary.concat(l_prs2xml.g_xmlfilename));
				//Sound fine generation is done.
				System.out.println("*********item processed***********");
				//if(l_ctr==7)break;	
		}//end While read csv, Now close the buffer
		 		
	}
	catch (Exception e) {
       	e.printStackTrace();
       	System.exit(0);
	}
	finally {
		try {
			l_CSVbfr.close();
			System.out.println("*********SUCCESS***********");
			System.out.println("MARY FILES GENERATED, execute the prepAudioForExp.sh for Speech Rate, and adding delays in the generated files.");
			System.out.println("***************************");
		}catch(Exception e) {
	     	e.printStackTrace();
	     	System.exit(0);
		}
	}
	} //End of Main 	
	
	private static void SkipColumns(StringTokenizer i_stk, int i_skipVal) {
		for(int i=0;i<i_skipVal;i++)
		{
			i_stk.nextToken(); //Skip the first 8 column
		}
	}
	
	/**
	 * This function converts a plaing text utterance to prosodic utterance.
	 * @param i_utter Utterance
	 * @param i_tune  Intonation
	 * @return A sentence with intonation marking
	 */
	private static String UtteranceToProsodic(String i_utter, String i_utterType, String i_tune){
		
		StringTokenizer l_uttertkn = new StringTokenizer(i_utter," ");
		String l_tkn = new String("");
		l_finalBnd="";
		l_nclrAccent="";
		
		//System.out.println("input:" + i_utter + " tune: " +i_tune + " char:"+ i_tune.charAt(0));
		if(i_utterType.equals(CR)){ 
			l_finalBnd=l_finalBnd.concat(l_Hp); //Boundary tone for Clarifications
			l_nclrAccent=l_nclrAccent.concat(l_Ls); //nuclear accent for CR )
			} 
		else if(i_utterType.equals(AS)) {
			l_finalBnd=l_finalBnd.concat(l_Lp);  //Boundary tone for Assertions
			l_nclrAccent=l_nclrAccent.concat(l_Hs); //nuclear accent for AS
		}
		switch (i_tune.charAt(0)) {
		
		case 'A' : //Is that a red@L* box HH%
			while(l_uttertkn.hasMoreTokens()){
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red@L*  or red@H*
				l_tkn= l_tkn.concat(l_nclrAccent);
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_finalBnd); //H-% or L-%
			}
			return l_tkn;
			
		
		case 'B' : //Is that a red box@L* HH%
			while(l_uttertkn.hasMoreTokens()){
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box@L*
				l_tkn= l_tkn.concat(l_nclrAccent);
				l_tkn= l_tkn.concat(l_space);
				l_tkn= l_tkn.concat(l_finalBnd);
			}
			return l_tkn;
			
		
		case 'C' : //Is that@L* a red box HH%
			while(l_uttertkn.hasMoreTokens()){
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that@L*
			l_tkn= l_tkn.concat(l_nclrAccent);
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_finalBnd);
		}
		return l_tkn;
		
		
		
		case 'D' :while(l_uttertkn.hasMoreTokens()){
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); // Is@L*
			l_tkn= l_tkn.concat(l_nclrAccent);
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //that
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //a
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //red
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_uttertkn.nextToken().toString()); //box
			l_tkn= l_tkn.concat(l_space);
			l_tkn= l_tkn.concat(l_finalBnd);
		}
		return l_tkn;
		default: System.out.println("Invalid tune. Tune has to be A, B , C or D type");
	}
		return "No Tune specified";
	}	
} //end class
