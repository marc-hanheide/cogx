function h = get1DKernelBWbatch( new_samples )
% solve-the-equation plug-in method
% new_samples ... currently observed samples

% currently, we will not use old inputs -- this is pure batch plug-in

scale = 1 ;
% estimate the new standard deviation
% shift=min(new_samples); X_shifted = new_samples-shift;
% scale=1/(max(X_shifted)); X_shifted_scaled=X_shifted*scale;
% new_samples = X_shifted_scaled ;

% Compute an estimate of the standard deriviation of the data
sigma=std(new_samples);
N = cols(new_samples) ;

% Estimate the density functionals ${\Phi}_6$ and ${\Phi}_8$ using the
% normal scale rule.
phi6=(-15/(16*sqrt(pi)))*(sigma^(-7));
phi8=(105/(32*sqrt(pi)))*(sigma^(-9));

% Estimate the density functionals ${\Phi}_4$ and ${\Phi}_6$ using the kernel density
% estimators with the optimal bandwidth based on the asymptotic MSE.
g1=(-6/(sqrt(2*pi)*phi6*N))^(1/7);
g2=(30/(sqrt(2*pi)*phi8*N))^(1/9);

phi4 = kernelDensityDerivative1d( new_samples, g1, 4 ) ;
phi6 = kernelDensityDerivative1d( new_samples, g2, 6 ) ;

% The bandwidth is the solution to the following  equation.

constant1=(1/(2*sqrt(pi)*N))^(1/5);
constant2=(-6*sqrt(2)*phi4/phi6)^(1/7);

h_initial=constant1*phi4^(-1/5);

options = optimset('Display','off','TolFun',1e-14,'TolX',1e-14,'LargeScale','on');
data.X=new_samples;
data.constant1=constant1;
data.constant2=constant2;

[h,resnorm,residual,exitflag,output] = lsqnonlin('opt_h_function',h_initial,[0],[],options,data) ;

h=h/scale;