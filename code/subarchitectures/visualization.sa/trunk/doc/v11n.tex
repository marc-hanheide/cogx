% vim:ft=tex:sw=3:ts=8:et:fileencoding=utf-8

\section{Installation}

\begin{itemize}
   \item Add visualization.sa to SVN externals:
   \begin{verbatim}
      $ svn pe svn:externals .
   \end{verbatim}
   Add the line:
   \begin{verbatim}
      ^/code/subarchitectures/visualization.sa/trunk   subarchitectures/visualization.sa
   \end{verbatim}

   % TODO: the script may be in another location
   \item install the required libraries; there is a script in visualization.sa/config
   that you can run:
   \begin{verbatim}
      sudo ubuntu-install-deps.sh
   \end{verbatim}

   \item enable BUILD\_VISUALIZATION\_SA in cmake
\end{itemize}

\section{General operation}

The library provieds a display server that displays objects created by its
clients.  The objects that are on the display server are groupped into views.
Initially every new object is displayed in its own view that has the same name
as the object.
% (TODO: Additional views can be defined on the server that display multiple objects).
The display server creates rendering contexts in which the views are displayed.
There are two types of contexts: 2D and OpenGL.
% (TODO: new contexts: tabular; textual; ...)

The client that wants to display an object connects to the server and sends the
serialized object to the server. Each object has a name. If an object with the
same name already exists on the srver it is updated with the new data. Some
objects are composed of multiple parts where each part can be manipulated
independently.

Currently the following types of objects are suported: images, SVG graphics and
OpenGL objects define with LuaGl script or as TomGine render-models. 

The display server can also display simple user interface elements. If a view
is active (visible) all the UI element associated with the view are also
displayed. When the state of a UI element changes, eg.  because of a muse
click, the client that owns the UI element is notified and it receives the new
state of the object.

(2010-06-09: at this time only two types of UI elements are provided: a button
and a checkbox).

\section{Sending data to the server}

The library provides a client component that interacts with the server. The
client is devised in such a way that its use is as trivial as the use of
OpenCV's function cvShowImage(). For simple objects the server can also
be used without a client if the developer is willing to use the file system
as a communication channel. This involves a CAST component that monitors
the file system and sends the newly created files to the server.

First we will show how to use the file system monitor and then we will give
instructions for the use of the real client.

\subsection{File system monitor}

The File system monitor is a CAST component that monitors the filesystem for
changes. Usualy it observes a directory on the disk and waits for files in that
directory that have been closed after they were modified. If the modified file
is one of the files the monitor is waiting for, it reads the file processes it
and sends it to the server. A single component is able to monitor multiple files
in multiple directories.

The files that the monitor can process are images, SVG files and files created
for GraphWiz.

Here is an example CAST setup of a DisplayServer and a FileMonitorDC. Note that
all text after fileviewer.cli is on the same line.

\begin{verbatim}
   HOST localhost
   SUBARCHITECTURE visualization.sa 
   CPP WM SubarchitectureWorkingMemory
   CPP TM AlwaysPositiveTaskManager

   CPP MG display.srv DisplayServer

   CPP MG fileviewer.cli FileMonitorDC --display-server "display.srv"
      --setvars "dir=subarchitectures/visualization.sa/src/c++/clients/fileviewer/test/xdata"
      --monitor "
         CurrentPlan=dot:%(dir)/{*.dot}
         AltPlan=twopi:%(dir)/{*.dot}
         ImageFile=%(dir)/{*.png;*.jpg;*.pnm;*.xpm}
         SvgFile=%(dir)/{*.svg}
         %(dir)/{*}"
         --log true --debug true
\end{verbatim}

The file monitor first connects to the server using the parameter
\code{--display-server}. If the server is not present, a display client will
operate normally except it won't be able to display its resutls.

The parameter \code{--setvars} sets some variables thata are used later when
the component configures the monitored files. The format of the parameter
string is \code{"var1=value1 var2=value2 ..."}. Later in the paramteter
\code{--monitor} a variable can be inserted with \code{\%(var1)}.

The most important and complex part is the definition of the files to be
monitored, the \code{--monitor} parameter. It is composed of multiple entries
that are separated by spaces. Each entry defines the directory where the files
are, the names of the files to monitor, the converters for the files and the
name of the object that will be created from the files. The general format of
each entry is:
\begin{verbatim}
   ObjectName=converter:directory/{filemasks}
\end{verbatim}

If the converter is omitted, one of the known converters will be selected.
If the object name is omitted, the name of the object will be the filename.

We can now decode the meanings of the above definitions:

\begin{verbatim}
   CurrentPlan=dot:%(dir)/{*.dot}
   AltPlan=twopi:%(dir)/{*.dot}
\end{verbatim}

Every new dot file in the directory will be converted with two converters: dot
and twopi. The files converted with dot will be displayed on the server as
CurrentPlan while the files converted with twopi well be displayed as AltPlan.
The file monitor also knows the following converters for dot: neato, circo and
fdp.

\begin{verbatim}
   ImageFile=%(dir)/{*.png;*.jpg;*.pnm;*.xpm}
   SvgFile=%(dir)/{*.svg}
\end{verbatim}

Images and SVG files can be sent without conversion if the file extension is
one of the known ones. If a SVG file is stored in a file with an extension
other than \code{.svg}, the converter must be specified although no conversion
will be performed:

\begin{verbatim}
   SvgFile=svg:%(dir)/{*.xml}
\end{verbatim}

The final entry will pick up any files that change in the directory. If the
type of the file (deduced from the extension) is one of the known types, the
file will be sent to the server. The name of the object on the server will be
the name of the file.

\begin{verbatim}
   %(dir)/{*}"
\end{verbatim}

\subsection{A Passive Display Client}

The library provides two types of clients: a passive client that only sends
data to the server and an active client that interacts with the server using UI
elements. We will first show how to create a passive client and then convert it
to an active client. We will use the VideoViewer component as an example. Only
the relevant parts of the code will be shown. Full code is in the VideoViewer
component in vision.sa.

Before we can start we need to prepare the project file to use the display server.
For every component that is defined in CMakeLists.txt we add the following:

\begin{verbatim}
   include_directories(${VISUALIZATION_INCLUDE_DIRS})
   link_cast_component(${CAST_COMPONENT_NAME} Video ${VISUALIZATION_LIBRARIES})
\end{verbatim}

If the component uses OpenCV's IplImage we can let the client convert the image
before it is sent to the server. To do this we need to enable the client's OpenCV
interface with

\begin{verbatim}
   add_definitions(-DFEAT_VISUALIZATION_OPENCV)
\end{verbatim}

Now the component is ready to interact with the display server. The component
will communicate with the servet through a display client:

\begin{verbatim}
   class VideoViewer : public ManagedComponent, public VideoClient
   {
   private:
   #ifdef FEAT_VISUALIZATION
     cogx::display::CDisplayClient m_display;
   #endif
   };
\end{verbatim}

Note that all the code related to visualization.sa is enclosed in conditional
blocks. The variable \code{FEAT\_VISUALIZATION} is defined when
viusalisation.sa is being built. If the visualization.sa is not used in the
project, the componetns that depend on it will continue to work, but they won't
display their data unless an alternative is provided (see VideoViewer.cpp which
uses OpenCV when visualization.sa is not used).

The client must connect to the server and for that it needs the parameters of the
connection (the parameter \code{--displaysever}):

\begin{verbatim}
   void VideoViewer::configure(const map<string,string> & _config)
   {
   #ifdef FEAT_VISUALIZATION
     m_display.configureDisplayClient(_config);
   #endif
   }
\end{verbatim}

The connection between the client and the server is established in the component's
\code{start()} method:
\begin{verbatim}
   void VideoViewer::start()
   {
   #ifdef FEAT_VISUALIZATION
      m_display.connectIceClient(*this);
   #endif
   }
\end{verbatim}

When a new image is available, the VideoServer sends the image to the VideoViewer which
passes the image to the DisplayServer:

\begin{verbatim}
   void VideoViewer::receiveImages(const std::vector<Video::Image>& images)
   {
   #ifdef FEAT_VISUALIZATION
     m_display.setImage(getComponentID(), images[0]);
   #endif
   }
\end{verbatim}

Here \code{getComponentID()} is used for the name of the object since the component
is displaying only one object. Any other string can be used instead.


\subsection{An Active Display Client}

An active display client is needed when the component wants to present some UI
elements with which it can be configured. The client receives notifications and
requests related to these elements from the display server. The component must
define two callback functions that will handle the events sent by the server.

\begin{verbatim}
   class VideoViewer : public ManagedComponent, public VideoClient
   {
   private:
   #ifdef FEAT_VISUALIZATION
     cogx::display::CActiveDisplayClient<VideoViewer> m_display;
     void handleGuiEvent(const Visualization::TEvent &event);
     std::string getControlState(const std::string& ctrlId);
   #endif
   };
\end{verbatim}

The event path from the server to the client must be initiated. This is done right
after the component connects to the client. After the connections are established,
the callback functions are registered:

\begin{verbatim}
   void VideoViewer::start()
   {
   #ifdef FEAT_VISUALIZATION
     m_display.connectIceClient(*this);
     m_display.installEventReceiver();
     m_display.setEventCallback(this, &VideoViewer::handleGuiEvent);
     m_display.setStateQueryCallback(this, &VideoViewer::getControlState);
   #endif
   }
\end{verbatim}

We define a checkbox element that will start or stop the flow of images
from the server:

\begin{verbatim}
   void VideoViewer::start()
   {
   #ifdef FEAT_VISUALIZATION
     m_display.addCheckBox(getComponentID(), "toggle.viewer.running", "&Streaming");
   #endif
   }
\end{verbatim}

Now all that is missing are the callback functions:

\begin{verbatim}
   #ifdef FEAT_VISUALIZATION
   void VideoViewer::handleGuiEvent(const Visualization::TEvent &event)
   {
     if (event.type == Visualization::evCheckBoxChange) {
       if (event.sourceId == "toggle.viewer.running") {
         bool newrcv = (event.data != "0");
         if (newrcv != receiving) {
           if(receiving) {
             videoServer->stopReceiveImages(getComponentID());
           }
           else {
             videoServer->startReceiveImages(getComponentID(), camIds, 0, 0);
           }
           receiving = !receiving;
         }
       }
     }
   }
   #endif
\end{verbatim}

\begin{verbatim}
   #ifdef FEAT_VISUALIZATION
   std::string VideoViewer::getControlState(const std::string& ctrlId)
   {
     if (ctrlId == "toggle.viewer.running") {
       return receiving ? "2" : "0";
     }
     return "";
   }
   #endif
\end{verbatim}

