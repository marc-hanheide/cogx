///////////////////////////////
// CONSTANTS
///////////////////////////////

// beliefs
existingunion = {U0_2,U2_2,U1_2}
percept = {P}
belief = {U0_2,U2_2,U1_2,P}

// possible outcomes of the grouping process
outcome = {U0_2,U3_3,U1_2,U2_2}

// feature values
colourval = {Pink,Red,Unknown,None}

///////////////////////////////
// PREDICATES
///////////////////////////////

Colour(belief, colourval)

Outcome(outcome)
UnifyWith(existingunion)

///////////////////////////////
// EXISTING UNIONS
///////////////////////////////

2.1972244 Existence(U0_2)

-2.944439 Existence(U2_2)

1.3862945 Existence(U1_2)

///////////////////////////////
// NEW PERCEPT
///////////////////////////////

1.3862945 Existence(U3_2)
0.84729785 Existence(U3_2) => colour(U3_2,red)
-0.8472978 Existence(U3_2) => colour(U3_2,pink)
Existence(U3_2) => !colour(U3_2,Pink).
Existence(U3_2) => !colour(U3_2,Red).
Existence(U3_2) => colour(U3_2,None).

///////////////////////////////
// FEATURE VALUE CONSTRAINTS
///////////////////////////////

// rules for existence dependency
!Existence(x) => y=None v !Colour(x,y).
!Existence(x) => Colour(x,None).

// mutual exclusivity and unicity constraints
Shape(x,y) ^ Colour(x,z) => y=z.
EXIST y Colour(x,y).



///////////////////////////////
// CORRELATIONS
///////////////////////////////

// general correlations
1 Existence(x) ^ Existence(P) ^ Shape(x,Cyl) ^ Label(P,Mug) => UnifyWith(x)
1 Existence(x) ^ Existence(P) ^ Shape(P,Cyl) ^ Label(x,Mug) => UnifyWith(x)
1 Existence(x) ^ Existence(P) ^ Shape(x,Sphe) ^ Label(P,Ball) => UnifyWith(x)
1 Existence(x) ^ Existence(P) ^ Shape(P,Sphe) ^ Label(x,Ball) => UnifyWith(x)
2 Existence(x) ^ Existence(P) ^ Shape(x,Sphe) ^ Label(P,Mug) => !UnifyWith(x)
2 Existence(x) ^ Existence(P) ^ Shape(P,Sphe) ^ Label(P,Mug) => !UnifyWith(x)
2 Existence(x) ^ Existence(P) ^ Shape(x,Cyl) ^ Label(P,Ball) => !UnifyWith(x)
2 Existence(x) ^ Existence(P) ^ Shape(P,Cyl) ^ Label(x,Ball) => !UnifyWith(x)

// at least one correlation must hold
UnifyWith(x) => (Shape(x,Cyl) ^ Label(P,Mug)) v (Shape(P,Cyl) ^ Label(x,Mug)) v (Shape(x,Sphe) ^ Label(P,Ball)) v (Shape(P,Sphe) ^ Label(x,Ball)).
UnifyWith(x) => Existence(x) ^ Existence(P).

///////////////////////////////
// FINAL OUTCOME
///////////////////////////////

-1.5 Existence(P) => Outcome(U3_3)
UnifyWith(U0_3) <=> Outcome(U0_2).UnifyWith(U1_3) <=> Outcome(U2_2).UnifyWith(U2_3) <=> Outcome(U1_2).-1 Outcome(x)
Outcome(x) ^ Outcome(y) => x=y.
Exist x Outcome(x).

