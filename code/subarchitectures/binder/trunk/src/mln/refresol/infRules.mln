// Inference rules

// resolution should be unique
belief(b) ^ resolution(b) ^ belief(b') ^ resolution(b') => (b = b').

// a resolution can be only about a belief that exists ...
resolution(b) => belief(b).

// one color, shape per belief
/*
belief(b) ^ color(b, c) ^ color(b, c')  => (c = c').
belief(b) ^ shape(b, s) ^ shape(b, s')  => (s = s').
color_constraint(c) ^ color_constraint(c') => (c = c').
shape_constraint(s) ^ shape_constraint(s')  => (s = s').
*/
// if there exist a belief there must be a resolution (not really necessary)
//belief(p) => (exist q belief(q) ^ resolution(q)).
//(exist c color_constraint(c)) => exist_constraint.
//(exist s shape_constraint(s)) => exist_constraint.

//(exist b belief(b) ^ resolution(b)) => !unknown.
//(forall b !resolution(b)) ^ exist_constraint => unknown.

//belief(b) ^ !(exist b' belief(b') ^ !(b = b')) ^ !exist_constraint => resolution(b).

//resolution(b) ^ resolution(b') ^ belief(b) ^ belief (b') ^ !(b = b') => ambiguity.


// ... and if there is a constraint
//resolution(b) => exist c color_constraint(c) v exist s shape_constraint(s).

// rules for reference generation

//solution(b) ^ belief(b') ^ !color_constraint(c) ^ !shape_constraint(s) ^ !ambiguity =>  (b = b').

