/*!
\page impl Implementation of Place.SA

<!-- ------------------------------------------------------------------------------------------ -->
\n\n
\section dirs Directory Structure
<hr>
\verbatim
place.sa
 |
 +--config - configuration files
 |
 +--doc - doxygen config files and doc. generation script
 |
 +--vendor - vendor branch for the external code used in place.sa
 |
 +--src - place.sa sources
     |
     +--idl - IDL files for the place.sa interface
     |
     +--c++ - C++ Sources
         |
         +--place
            |
            +--components - sources of all components
            |
            +--idl - sources generated by omniidl from the IDL
            |        interface files
            |
            +--ontology - ontology (to be removed)
            |
            +--shared - code shared between components
            |
            +--tools - internal versions of external code used by place.sa
\endverbatim


<!-- ------------------------------------------------------------------------------------------ -->
\n\n
\section thr Thread Synchronization
<hr>
The following strategy is used in place.sa for handling synchronization between the processing thread and
notification/data acquistition (from WM) threads.
<br>
\code
void runComponent()
{
  while(m_status == STATUS_RUN)
  {
    // Get current time and add 1 sec
    timespec ts;
    clock_gettime(CLOCK_REALTIME, &ts);
    ts.tv_sec += 1;

    // Wait if necessary
    pthread_mutex_lock(&_signalMutex);
    if (!_wasSignal)
      pthread_cond_timedwait(&_signalCond, &_signalMutex, &ts);

    // Handle signal if signal arrived
    if ((m_status!=STATUS_RUN) || (!_wasSignal))
      pthread_mutex_unlock(&_signalMutex);
    else
    {
      _wasSignal=false;
      pthread_mutex_unlock(&_signalMutex);

      // If there is something to grab from WM, do it.
      // If several copies exist, grab most recent one
      grab_data_from_wm();

      do_heavy_computations();
    }
  }
}

void newDataOrCommandOnWM()
{
  // If it's just a command, remove it from WM
  deleteCommandFromWM();

  pthread_mutex_lock(&_signalMutex);
  _wasSignal=true;
  pthread_cond_signal(&_signalCond);
  pthread_mutex_unlock(&_signalMutex);
}

\endcode




*/

