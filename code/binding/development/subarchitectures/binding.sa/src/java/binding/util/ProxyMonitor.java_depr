/**
 * 
 */
package binding.util;

import java.util.Vector;

import binding.abstr.AbstractBindingReader;
import binding.autogen.BindingData.BindingProxy;
import binding.autogen.BindingData.BindingUnion;
import binding.ontology.BindingOntology;
import cast.architecture.abstr.WorkingMemoryChangeReceiver;
import cast.architecture.subarchitecture.DoesNotExistOnWMException;
import cast.architecture.subarchitecture.SubarchitectureProcessException;
import cast.cdl.*;
import cast.core.data.CASTData;
import cast.core.*;

/**
 * A class for monitoring a proxy on working memory. When the proxy is
 * overwritten internal caches are updated. If the proxy is bound to a union
 * then the union is also cached.
 * 
 * @author nah
 */
public class ProxyMonitor implements WorkingMemoryChangeReceiver {

    private boolean m_deleteMe;

    private String m_unionID;

    private CASTData<BindingProxy> m_proxy;

    private CASTData<BindingUnion> m_union;

    private String m_lastUnionID;

    private boolean m_unionHasChanged;

    private int m_featureCount;

    private int m_proxyCount;

    private boolean m_proxyChangeReceived;

    private boolean m_unionChangeReceived;

    private boolean m_rebound;

    private String m_proxyID;

    private String m_bindingSA;

    private AbstractBindingReader m_parent;

    private Vector<ProxyMonitorCallback> m_onUnionChange;

    private Vector<ProxyMonitorCallback> m_onProxyChange;

    private Vector<ProxyMonitorCallback> m_onRebind;

    private boolean m_removed;

    /**
         * Create a new proxy monitor and register the appropriate change
         * filters
         * 
         * @param _abr
         * @param _proxyID
         * @return
         * @throws SubarchitectureProcessException
         */
    public static ProxyMonitor newProxyMonitor(AbstractBindingReader _abr,
	    String _proxyID) throws SubarchitectureProcessException {
	String bindingSA = _abr.getBindingSA();
	ProxyMonitor pm = new ProxyMonitor(_proxyID, bindingSA, _abr);
	_abr.addChangeFilter(BindingOntology.BINDING_PROXY_TYPE,
		WorkingMemoryOperation.OVERWRITE, "", _proxyID, bindingSA,
		false, pm);
	_abr.addChangeFilter(BindingOntology.BINDING_PROXY_TYPE,
		WorkingMemoryOperation.DELETE, "", _proxyID, bindingSA, false,
		pm);
	return pm;
    }

    public ProxyMonitor(String _proxyID, String _bindingSA,
	    AbstractBindingReader _parent) {
	m_proxyID = _proxyID;
	m_bindingSA = _bindingSA;
	m_parent = _parent;
	m_deleteMe = false;
	m_unionHasChanged = false;
	m_proxyChangeReceived = false;
	m_unionChangeReceived = false;
	m_rebound = false;
	m_unionID = "";
	m_lastUnionID = "";
	m_featureCount = 0;
	m_proxyCount = 0;
	m_removed = false;

	init();
	
// 	if(m_proxy != null) {
// 	    System.out
// 		.println("after init: " + m_unionID + " " + proxy().m_unionID);
// 	}
    }

    /**
         * 
         */
    private void init() {
	// if the parent is already there
	try {
	    if (m_parent.existsOnWorkingMemory(m_proxyID, m_bindingSA)) {
		System.out
			.println("loading previously created proxy - you may have missing previous changes");
		// create a fake event just to reuse working structure
		WorkingMemoryChange wmc = new WorkingMemoryChange(
			WorkingMemoryOperation.ADD, "",
			new WorkingMemoryAddress(m_proxyID, m_bindingSA),
			BindingOntology.BINDING_PROXY_TYPE);
		workingMemoryChanged(wmc);

		

	    }
	} catch (SubarchitectureProcessException e) {
	    e.printStackTrace();
	    System.exit(1);
	}

    }

    /**
         * Register overwrite and delete filters for the monitored proxy's
         * current union.
         * 
         * @param _unionID
         * @throws SubarchitectureProcessException
         */
    private void addUnionFilter(String _unionID)
	    throws SubarchitectureProcessException {
	m_parent.addChangeFilter(BindingOntology.BINDING_UNION_TYPE,
		WorkingMemoryOperation.OVERWRITE, "", _unionID, m_bindingSA,
		false, this);
	m_parent.addChangeFilter(BindingOntology.BINDING_UNION_TYPE,
		WorkingMemoryOperation.DELETE, "", _unionID, m_bindingSA,
		false, this);

    }

    /**
         * Determines whether the proxy's binding has changed. Called on every
         * proxy overwrite.
         * 
         * @return
         */
    private synchronized boolean bindingHasChanged() {

	// if we've yet to get the proxy, then nothing has happened
	if (m_proxy == null) {
	    return false;
	}

	// get the new union address
	String newUnionID = proxy().m_unionID;

	// if it's the same as the old binding then no change has
	// happened
	if (newUnionID.equals(m_unionID)) {
	    return false;
	} else {
	    // store last union address
	    m_lastUnionID = m_unionID;
	    // store new union address
	    m_unionID = newUnionID;
	    // and say yes
	    return true;
	}

    }

    /**
         * @param _wmc
         * @throws SubarchitectureProcessException
         */
    private void monitorProxy(WorkingMemoryChange _wmc)
	    throws SubarchitectureProcessException {

	if (_wmc.m_operation == WorkingMemoryOperation.DELETE) {
	    m_deleteMe = false;
	    // now removed
	    m_removed = true;
	    if (proxyIsBound()) {
		removeUnionFilter(m_unionID);
	    }
	    return;
	}

	// otherwise it's an add or overwrite

	// get the proxy from working memory... it will have changed so
	// no need to check counts etc
	updateProxy();

	// System.out.println("updating proxy");

	// check to see if the binding has changed
	if (bindingHasChanged()) {

	    // System.out.println("binding has changed");

	    // m_pParent->logf("ProxyMonitor::Binding has changed for
	    // proxy at: %s", m_proxyID.c_str());

	    // if we were bound to something previously
	    if (!m_lastUnionID.equals("")) {
		// System.out.println("was bound, removing that
		// filter");
		removeUnionFilter(m_lastUnionID);
	    }

	    // if we're newly bound to something
	    if (proxyIsBound()) {
		// System.out.println("is bound");

		addUnionFilter(m_unionID);

		// trigger the union monitoring code using a fake
		// change event
		WorkingMemoryChange unionChange = new WorkingMemoryChange(
			WorkingMemoryOperation.ADD, "",
			new WorkingMemoryAddress(m_unionID, m_bindingSA),
			BindingOntology.BINDING_UNION_TYPE);
		monitorUnion(unionChange);
		m_rebound = true;

		rebindCallback();
	    }
	}

    }

    /**
         * Guaranteed that the union is non-nul;
         * 
         * @param _callback
         */
    public void registerRebindCallback(ProxyMonitorCallback _callback) {
	if (m_onRebind == null) {
	    m_onRebind = new Vector<ProxyMonitorCallback>();
	}
	m_onRebind.add(_callback);
    }

    /**
         * Guaranteed that the union is non-nul;
         * 
         * @param _callback
         */
    public void registerUnionChangeCallback(ProxyMonitorCallback _callback) {
	if (m_onUnionChange == null) {
	    m_onUnionChange = new Vector<ProxyMonitorCallback>();
	}
	m_onUnionChange.add(_callback);
    }

    /**
         * No guarantee that the union is non-nul;
         * 
         * @param _callback
         */
    public void registerProxyChangeCallback(ProxyMonitorCallback _callback) {
	if (m_onProxyChange == null) {
	    m_onProxyChange = new Vector<ProxyMonitorCallback>();
	}
	m_onProxyChange.add(_callback);
    }

    /**
         * 
         */
    private void rebindCallback() {
	if (m_onRebind != null) {
	    assert (m_proxy != null);
	    assert (m_union != null);
	    for (ProxyMonitorCallback callback : m_onRebind) {
		callback.bindingEvent(m_proxy, m_union, this);
	    }
	}
    }

    /**
         * 
         */
    private void unionChangeCallback() {
	if (m_onUnionChange != null) {
	    assert (m_proxy != null);
	    assert (m_union != null);
	    for (ProxyMonitorCallback callback : m_onUnionChange) {
		callback.bindingEvent(m_proxy, m_union, this);
	    }
	}
    }

    private void proxyChangeCallback() {
	if (m_onProxyChange != null) {
	    assert (m_proxy != null);
	    for (ProxyMonitorCallback callback : m_onProxyChange) {
		callback.bindingEvent(m_proxy, m_union, this);
	    }
	}
    }

    /**
         * @param _wmc
         * @throws SubarchitectureProcessException
         */
    private void monitorUnion(WorkingMemoryChange _wmc)
	    throws SubarchitectureProcessException {

	// this will only occur internally, but is used to reset the
	// counts from previous unions
	if (_wmc.m_operation == WorkingMemoryOperation.ADD) {
	    m_featureCount = 0;
	    m_proxyCount = 0;
	}

	// all done in the proxy
	// if (_wmc.m_operation == WorkingMemoryOperation.DELETE) {
	// //
	// removeUnionFilter(_wmc.m_address.m_id);
	// // wait for the proxy to be overwritten to handle the
	// // bookkeeping
	// return;
	// }

	try {
	    // assume that the change doesn't alter the things we
	    // care about
	    m_unionHasChanged = false;
	    updateUnion();
	    // now see if anything has really changed for us
	    updateFeatureCount();
	    updateProxyCount();
	} catch (DoesNotExistOnWMException e) {
	    // the union has been deleted but we have received the
	    // change event yet
	}
    }

    /**
         * Inform monitor that all proxu changes have been noted.
         */
    private void proxyUpdatesRead() {
	m_proxyChangeReceived = false;
	m_rebound = false;
    }

    private boolean proxyUpdated() {
	return m_proxyChangeReceived;
    }

    /**
         * @param _unionID
         * @throws SubarchitectureProcessException
         */
    private void removeUnionFilter(String _unionID)
	    throws SubarchitectureProcessException {
	m_parent.removeChangeFilter(BindingOntology.BINDING_UNION_TYPE,
		WorkingMemoryOperation.OVERWRITE, "", _unionID, m_bindingSA,
		false);
	m_parent
		.removeChangeFilter(BindingOntology.BINDING_UNION_TYPE,
			WorkingMemoryOperation.DELETE, "", _unionID,
			m_bindingSA, false);

    }

    /**
         * Inform monitor that all union changes have been noted.
         */
    private void unionUpdatesRead() {
	m_unionChangeReceived = false;
    }

    private boolean unionUpdated() {
	return m_unionChangeReceived;
    }

    /**
         * 
         */
    private void updateFeatureCount() {
	assert (m_union != null);
	int currentFeatureCount = union().m_unionFeatures.length;
	if (currentFeatureCount != m_featureCount) {
	    m_unionHasChanged = true;
	    m_featureCount = currentFeatureCount;
	}
    }

    /**
         * Fetches proxy from wm.
         * 
         * @throws SubarchitectureProcessException
         */
    private void updateProxy() throws SubarchitectureProcessException {

	m_proxy = BindingUtils.getProxyData(m_parent, m_proxyID);

    }

    /**
         * 
         */
    private void updateProxyCount() {
	assert (m_union != null);
	int currentProxyCount = union().m_proxyIDs.length;
	if (currentProxyCount != m_proxyCount) {
	    m_unionHasChanged = true;
	    m_proxyCount = currentProxyCount;
	}
    }

    /**
         * @return
         */
    private BindingUnion union() {
	return m_union.getData();
    }

    /**
         * @return
         */
    private BindingProxy proxy() {
	return m_proxy.getData();
    }

    /**
         * @throws SubarchitectureProcessException
         */
    private void updateUnion() throws SubarchitectureProcessException {
	m_union = BindingUtils.getUnionData(m_parent, m_unionID);
    }

    /**
         * Determines whether the monitored proxy is bound to a union and
         * whether that union contains proxies other than the one being
         * monitored.
         * 
         * @return
         */
    public synchronized boolean boundToOtherProxies() {
	return m_proxyCount > 1;
    }

    /**
         * @return
         */
    public synchronized String getProxyID() {
	return m_proxyID;
    }

    /**
         * @return
         */
    public synchronized String getUnionID() {
	return m_unionID;
    }

    /**
         * Determines whether the monitor has received a change since the last
         * time {@link ProxyMonitor}.monitorRead() was called.
         */
    public synchronized boolean monitorUpdated() {
	return proxyUpdated() || unionUpdated();
    }

    /**
         * Inform monitor that all changes have been noted.
         */
    public void monitorRead() {
	proxyUpdatesRead();
	unionUpdatesRead();
    }

    /**
         * @return
         */
    public synchronized boolean needsDeleting() {
	return m_deleteMe;
    }

    /**
         * Determines if the proxy is currently bound.
         * 
         * @return
         */
    public synchronized boolean proxyIsBound() {
	return !m_unionID.equals("");
    }

    /**
         * Determines whether the proxy was rebound since the last called to
         * proxyChangesRead().
         * 
         * @return
         */
    public synchronized boolean proxyRebound() {
	return m_rebound;
    }

    /**
         * Determines whether the features or proxies of the current union have
         * changed since the last overwrite.
         * 
         * @return
         */
    public synchronized boolean unionChanged() {
	return m_unionHasChanged;
    }

    /**
         * Removes this monitor from the parent's change filter set.
         * 
         * @throws SubarchitectureProcessException
         */
    public void remove() throws SubarchitectureProcessException {

	m_removed = true;
	m_parent.removeChangeFilter(this);
    }

    /*
         * Synchronized to prevent concurrent access with accessor functions.
         * (non-Javadoc)
         * 
         * @see cast.architecture.abstr.WorkingMemoryChangeReceiver#workingMemoryChanged(cast.cdl.WorkingMemoryChange)
         */
    public synchronized void workingMemoryChanged(WorkingMemoryChange _wmc) {

	if (!m_removed) {
// 	    System.out.println("ProxyMonitor.workingMemoryChanged: "
// 			       + CASTUtils.toString(_wmc));

	    try {
		if (_wmc.m_type.equals(BindingOntology.BINDING_PROXY_TYPE)) {
		    m_proxyChangeReceived = true;
		    monitorProxy(_wmc);
		    if (_wmc.m_operation == WorkingMemoryOperation.OVERWRITE) {
			proxyChangeCallback();
		    }
		} else if (_wmc.m_type
			.equals(BindingOntology.BINDING_UNION_TYPE)) {
		    m_unionChangeReceived = true;
		    monitorUnion(_wmc);
		    if (_wmc.m_operation == WorkingMemoryOperation.OVERWRITE) {
			unionChangeCallback();
		    }
		}
	    } catch (SubarchitectureProcessException e) {
		e.printStackTrace();
		System.exit(1);
	    }
	}
    }

}
