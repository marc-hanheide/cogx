// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "LFPacking.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingNodeId:1.0", "PackingNodeId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingNodeId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingNodeId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId;
#endif

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdgeId = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingEdgeId:1.0", "PackingEdgeId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingEdgeId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdgeId;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingEdgeId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdgeId;
#endif

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalFormId = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedLogicalFormId:1.0", "PackedLogicalFormId", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedLogicalFormId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalFormId;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedLogicalFormId = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalFormId;
#endif

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mnominalVariable = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/nominalVariable:1.0", "nominalVariable", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/nominalVariable:1.0", "nominalVariable", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mnominalVariable, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_nominalVariable = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_nominalVariable = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable;
#endif

static const char* _0RL_enumMember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mConnectiveType[] = { "NONE", "DISJUNCTIVE", "CONJUNCTIVE", "XDISJUNCTIVE" };
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mConnectiveType = CORBA::TypeCode::PR_enum_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/ConnectiveType:1.0", "ConnectiveType", _0RL_enumMember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mConnectiveType, 4, &_0RL_tcTrack);
static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition[] = {
  {"prop", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"connective", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mConnectiveType}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/Proposition:1.0", "Proposition", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition, 2, &_0RL_tcTrack);




static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mProposition = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/Proposition:1.0", "Proposition", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mProposition, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_Proposition = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mProposition;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_Proposition = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mProposition;
#endif

static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation[] = {
  {"head", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mnominalVariable},
  {"mode", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"dep", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mnominalVariable},
  {"coIndexedDep", CORBA::TypeCode::PR_boolean_tc()}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/LFRelation:1.0", "LFRelation", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation, 4, &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mRelations = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/Relations:1.0", "Relations", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mLFRelation, &_0RL_tcTrack), &_0RL_tcTrack);




static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mRelations = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/Relations:1.0", "Relations", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mRelations, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_Relations = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mRelations;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_Relations = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mRelations;
#endif

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_montologicalSort = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/ontologicalSort:1.0", "ontologicalSort", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_montologicalSort = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/ontologicalSort:1.0", "ontologicalSort", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_montologicalSort, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_ontologicalSort = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_montologicalSort;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_ontologicalSort = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_montologicalSort;
#endif

static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mId = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFEssentials/Id:1.0", "Id", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/LogicalFormIds:1.0", "LogicalFormIds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFEssentials_mId, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_LogicalFormIds = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_LogicalFormIds = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds;
#endif

static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget[] = {
  {"pnId", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId},
  {"lfIds", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingNodeTarget:1.0", "PackingNodeTarget", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingNodeTarget = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingNodeTarget = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget;
#endif






static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingNodeTargets:1.0", "PackingNodeTargets", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingNodeTargets = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingNodeTargets = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets;
#endif


static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge[] = {
  {"peId", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdgeId},
  {"mode", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"head", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable},
  {"targets", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets},
  {"coIndexedDep", CORBA::TypeCode::PR_boolean_tc()},
  {"preferenceScore", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingEdge:1.0", "PackingEdge", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingEdge = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingEdge = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge;
#endif










static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingEdges:1.0", "PackingEdges", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingEdges = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingEdges = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges;
#endif

static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature[] = {
  {"feat", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"value", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"lfIds", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedFeature:1.0", "PackedFeature", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedFeature = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedFeature = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature;
#endif


static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort[] = {
  {"sort", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_montologicalSort},
  {"lfIds", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedOntologicalSort:1.0", "PackedOntologicalSort", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedOntologicalSort = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedOntologicalSort = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort;
#endif






static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedOntologicalSorts:1.0", "PackedOntologicalSorts", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedOntologicalSorts = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedOntologicalSorts = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts;
#endif





static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedFeatures:1.0", "PackedFeatures", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedFeatures = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedFeatures = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures;
#endif







static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal[] = {
  {"nomVar", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable},
  {"packedSorts", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts},
  {"prop", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mProposition},
  {"rels", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mRelations},
  {"feats", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures},
  {"pEdges", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedNominal:1.0", "PackedNominal", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal, 6, &_0RL_tcTrack);







#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedNominal = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedNominal = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal;
#endif






























static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedNominals:1.0", "PackedNominals", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedNominals = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedNominals = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals;
#endif



static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair[] = {
  {"head", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable},
  {"pe", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/NominalPackingEdgePair:1.0", "NominalPackingEdgePair", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_NominalPackingEdgePair = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_NominalPackingEdgePair = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair;
#endif














static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/NominalPackingEdgePairs:1.0", "NominalPackingEdgePairs", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_NominalPackingEdgePairs = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_NominalPackingEdgePairs = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs;
#endif











static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode[] = {
  {"pnId", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId},
  {"lfIds", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds},
  {"packedNoms", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals},
  {"root", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mnominalVariable},
  {"nomsPePairs", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs},
  {"preferenceScore", CORBA::TypeCode::PR_float_tc()}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingNode:1.0", "PackingNode", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode, 6, &_0RL_tcTrack);











#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingNode = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingNode = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode;
#endif














































static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes = CORBA::TypeCode::PR_alias_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackingNodes:1.0", "PackingNodes", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackingNodes = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackingNodes = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes;
#endif












static CORBA::PR_structMember _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm[] = {
  {"packedLFId", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalFormId},
  {"pNodes", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes},
  {"root", _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeId}
};

#ifdef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm
#  undef _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm
#endif
static CORBA::TypeCode_ptr _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm = CORBA::TypeCode::PR_struct_tc("IDL:org/cognitivesystems/repr/lf/autogen/LFPacking/PackedLogicalForm:1.0", "PackedLogicalForm", _0RL_structmember_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm, 3, &_0RL_tcTrack);












#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace org { namespace cognitivesystems { namespace repr { namespace lf { namespace autogen { namespace LFPacking { 
  const ::CORBA::TypeCode_ptr _tc_PackedLogicalForm = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm;
} } } } } } 
#else
const ::CORBA::TypeCode_ptr org::cognitivesystems::repr::lf::autogen::LFPacking::_tc_PackedLogicalForm = _0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm;
#endif


static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mLogicalFormIds_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::LogicalFormIds*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTarget_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTarget*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodeTargets_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodeTargets*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdge_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdge*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingEdges_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingEdges*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeature_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeature*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSort_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSort*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedOntologicalSorts_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedOntologicalSorts*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedFeatures_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedFeatures*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominal_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominal*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedNominals_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedNominals*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePair_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePair*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mNominalPackingEdgePairs_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::NominalPackingEdgePairs*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNode_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNode*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackingNodes_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackingNodes*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_marshal_fn(cdrStream& _s, void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*)_v;
  *_p >>= _s;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_unmarshal_fn(cdrStream& _s, void*& _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_destructor_fn(void* _v)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _p = (org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm& _s)
{
  org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _p = new org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm(_s);
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm* _sp)
{
  _a.PR_insert(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_marshal_fn,
               _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*& _sp)
{
  return _a >>= (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_unmarshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_marshal_fn,
                    _0RL_org_mcognitivesystems_mrepr_mlf_mautogen_mLFPacking_mPackedLogicalForm_destructor_fn,
                    _v)) {
    _sp = (const org::cognitivesystems::repr::lf::autogen::LFPacking::PackedLogicalForm*)_v;
    return 1;
  }
  return 0;
}

