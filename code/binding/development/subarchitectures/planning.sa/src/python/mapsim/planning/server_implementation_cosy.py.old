#!/usr/bin/env python

import os, os.path, sys
import random

absolute_path = os.path.dirname(os.path.abspath(sys.argv[0]))
mapsim_main_dir = absolute_path

try:
    import main
except ImportError:
    mapsim_main_dir = os.path.dirname(absolute_path)
    sys.path[1:1] = mapsim_main_dir

#print "Directory...\n", mapsim_main_dir

import config
from config import log
from constants import *
import utils
from utils import Struct
import plans
from plans import POPlan, PlanningMemory
import mapl2pddl, planner_base, eng2mapl, plan_monitor
from mapl2pddl import load_mapl_domain, load_mapl_task, compile_pddl_domain, create_subgoal_op
import state 
import Planner 
from Planner import MonitorOutput, SimplePOPlan, PlanningTask, ObjectDeclaration


TMP_DIR = os.path.join(absolute_path, "tmp")
tmp_count = 0

task_template =  """(define (problem %s)\n(:domain %s)\n""" \
                """(:objects\n%s\n)\n(:init\n%s\n)\n\n(:goal \n%s\n))"""
DEFAULT_DOM  = "cosydomain"
DEFAULT_TASK = "cosytask"

DEBUG = False
VERBOSE = True

NO_PLAN = "NO PLAN"

PM_ID = "pm1"
pm_id_counter = 0

class Planner(object):
    def __init__(self):
        # do not use the symbolic link approach of MAPSIM
        config.current_data_dir = TMP_DIR
        config.log_path = os.path.join(config.current_data_dir, "planning.log")
        config.log_file = open(config.log_path, "w")
        self.PMs = {PM_ID : PlanningMemory()}
        self.task_info = {}
        self.simple2rich = {}  # gives access to rich action format needed for PM reasoning
    
        
    def find_plan(self, task):
        pddl_info = prepare_pddl_files(task)
        plan = planner_base.find_plan(pddl_info.pddl_prob_path, pddl_info.cpddl_dom_path, make_PO=True)
        print "plan found:\n", plan
        if self.is_no_plan(plan):
            return SimplePOPlan(nodes=[], edges=[])
        else: 
            self.simple2rich.update((n.action.description,n.action) for n in plan.nodes())
            simple_plan = plan2simple_plan(plan)
            return simple_plan

    def monitor_plan(self, plan, task):
        pddl_info = prepare_pddl_files(task)
        assert isinstance(plan, SimplePOPlan)
        # do invalidity checks in the given order. stop as soon as an invalidity is detected
        check_order = ["assertions", "validity",]
        check_fct = dict(assertions=plan_contains_expandable_assertions, validity=plan_does_not_achieve_goal)
        for check in check_order:
            result = check_fct[check](plan, task, pddl_info)
            plan_invalid = not result.executable or not result.goal_achieved
            if plan_invalid:
                print "invalid plan in monitor: \n", result.executable, result.goal_achieved
                return result
        return MonitorOutput(executable=True, goal_achieved=True, advice="awaiting advice")

    def new_task(self, task):
        pmID = self.new_planning_memory()
        mapl_domain = load_mapl_domain(task.domain_fn)
        task_info = Struct(domain_fn=task.domain_fn, objects=task.objects, facts=task.facts, goal=task.goal, pmID=pmID, mapl_domain=mapl_domain)
        self.task_info[pmID] = task_info
        return pmID

    def current_plan(self, pmID):
        pm = self.PMs[pmID]
        plan = pm.current_plan()
        assert isinstance(plan, POPlan)
        simple_plan = plan2simple_plan(plan)
        return simple_plan
        
    def possible_next_steps(self, pmID):
        pm = self.PMs[pmID]
        plan = pm.current_plan()
        actions = plan.get_level1_actions()
        return [a.description for a in actions]
        
    def advance(self, pmID, step, time):
        pm = self.PMs[pmID]
        pm.advance(step, time)
        
    def current_state_estimation(self, pmID):
        pm = self.PMs[pmID]
        state = pm.current_state_estimation()
        fl = state.to_mapl_factlist(add_parens=False)
        return fl

    def set_pm_state(self, pmID, facts):
        pm = self.PMs[pmID]
        assignments = dict(state.mapl_str2assignment(fstr) for fstr in facts)
        pm.set_state(assignments)

    def update_pm_state(self, pmID, facts):
        pm = self.PMs[pmID]
        assignments = dict(state.mapl_str2assignment(fstr) for fstr in facts)
        pm.update_state(assignments)

    def add_plan(self, pmID, simple_plan):
        pm = self.PMs[pmID]
        poplan = simple_plan2plan(simple_plan, self.simple2rich)
        pm.add_plan(poplan)

    def execution_history(self, pmID):
        pm = self.PMs[pmID]
        return pm.execution_history()

    def negative_sensing(self, pmID, sensing_action):
        pm = self.PMs[pmID]
        sensing_action = sensing_action.replace(PDDL_SENSOR_PREFIX,"")
        scommand_list = sensing_action.split()
        sname, params = scommand_list[0], scommand_list[1:]
        domain_info = self.get_task_info(pmID)
        sensor = domain_info.mapl_domain.sname2sensor[sname]
        svar = sensor.analyze_sensor_command(sensing_action)
        nsvar, nval = sensor.instantiate_neg_condition(params, mark_negation=False)
        print "negative sensing: %s != %s" %  (nsvar, nval)
        id_svar = nsvar.in_domain_proposition(nval)
        k_svar = nsvar.knowledge_proposition(params[0])
        upd = {id_svar : FALSE_TUP, k_svar : FALSE_TUP}
        pm.update_state(upd)

    def self_test(self):
        print "Planner self test running..."
        run_test()

    #
    # helper methods (not in idl)
    #
        
    def new_planning_memory(self):
        global pm_id_counter
        pm_id_counter += 1
        pmID = "pm%d" % pm_id_counter
        self.PMs[pmID] = PlanningMemory()
        return pmID

    def get_task_info(self, pmID):
        return self.task_info[pmID]

    def is_no_plan(self, plan):
        #doesn't work with None objects
        #assert isinstance(plan, SimplePOPlan)
        #             return (plan is None or plan.nodes[0] == NO_PLAN)
        if plan is None:
            return True
        elif isinstance(plan, SimplePOPlan):
            return( is_empty(plan) or plan.nodes[0] == NO_PLAN )
        else:
            return False
        

        
########################

def is_empty(simple_poplan):
    return not simple_poplan.nodes
        
def plan_contains_expandable_assertions(plan, task, pddl_info):
    if DEBUG: print "checking assertions"
    from planner_base.call_planner import full_state_and_enabled_actions
    _, _, expandable_assertions = full_state_and_enabled_actions(pddl_info.pddl_prob_path, pddl_info.cpddl_dom_path)
    expandable_assertions = set(expandable_assertions)
    plan_actions = set(action for action in plan.nodes)
    expandable_in_plan = plan_actions & expandable_assertions
    executable = expandable_in_plan == set()
    if not executable:
        print "assertions must be expanded:", expandable_in_plan
    return MonitorOutput(executable=executable, goal_achieved=True, advice="awaiting advice")
    
def plan_does_not_achieve_goal(plan, task, pddl_info):
    if DEBUG: print "checking validity"
    # exploits the fact that simple plans, ie the graph structure used for modelling PO plans in CORBA,
    # have a totally ordered node list which is a valid topological sort of the original plan
    val_plan = val_format(plan.nodes)
    result = plan_monitor.monitor_plan(pddl_info.pddl_prob_path, val_plan, pddl_info.pddl_dom_path)
    return MonitorOutput(result.is_executable,result.reaches_goal_state,"awaiting advice")
    
def build_mapl_problem(objects, facts, goal, domain_name=DEFAULT_DOM, task_name=DEFAULT_TASK):
    objects = "\n".join("  %s - %s" % (obj.name, obj.type) for obj in objects)
    if DEBUG: print "the facts", facts, "endfacts"
    facts = "\n".join("  (%s)" % fact for fact in facts)
    task = task_template % (task_name, domain_name, objects, facts, goal)
    if DEBUG: print "generated MAPL task:\n", task
    return task.splitlines()

def val_format(seq_plan):
    l = ["%s: (%s)" % (i, action) for i, action in enumerate(seq_plan)]
    val_plan = "\n".join(l)
    return val_plan

def create_pddl_paths():
    global tmp_count
    tmp_count += 1
    numstr = str(tmp_count).zfill(4)
    ftypes = "task domain".split()
    return [os.path.join(TMP_DIR, "%s_%s.pddl" % (ftype, numstr)) for ftype in ftypes]

def prepare_pddl_files(task):
    # translates problem and domain and stores corresponding paths
    mapl_prob = build_mapl_problem(task.objects, task.facts, task.goal)
    pddl_prob_path, pddl_dom_path = create_pddl_paths()
    # TODO: this is called way too often currently...
    mapl_domain = mapl2pddl.translate(mapl_prob, task.domain_fn, pddl_prob_path, pddl_dom_path)
    cpddl_dom_path = pddl_dom_path.replace(".pddl", ".cpddl")
    config.get_mapl_domain = lambda : mapl_domain
    return Struct(pddl_dom_path=pddl_dom_path, cpddl_dom_path=cpddl_dom_path, pddl_prob_path=pddl_prob_path, mapl_domain=mapl_domain)

def plan2simple_plan(poplan):
    actions = [action.description for action in poplan.total_order(as_nodes=False)]
    action2num = dict((a,i) for (i,a) in enumerate(actions))
    edges = []
    for n1 in poplan.nodes():
        i1 = action2num[n1.action.description]
        for n2 in n1.successors:
            i2 = action2num[n2.action.description]
            edge = [actions[i1], actions[i2]]
            edges.append(edge)
    simple_plan = SimplePOPlan(nodes=actions, edges=edges)
    return simple_plan

def simple_plan2plan(simple_plan, simple2rich):
    rich_actions = [simple2rich[action_name] for action_name in simple_plan.nodes]
    poplan = plans.make_partial_order_plan_from_action_seq(rich_actions)
    return poplan

def choose_from_prob_distribution(distribution=dict([(True,0.5), (False,0.5)])):
    assert sum(distribution.values()) == 1
    rnd = random.random()
    s = 0.0
    for v,p in distribution.items():
        s += p
        if rnd < s:
            return v
    assert False  # should never get here

def prepare_test_task():
    dom_path = os.path.join(mapsim_main_dir, "domains/coffee")
    task_fn = os.path.join(dom_path, "scenarios/one_agent/prob001/R2D2.mapl")
    # load task and adapt to IDL structure
    task_name, domain_name, objects, init, goal = load_mapl_task(task_fn)
    objects = [ObjectDeclaration(name=o.name, type=o.type) for o in objects]
    facts = [f.as_mapl_str() for f in init]
    goal = goal.as_mapl_str()
    domain_fn = os.path.join(dom_path, "mapl_files/domain_agents.mapl")
    task = PlanningTask(objects=objects, facts=facts, goal=goal, domain_fn=domain_fn)
    return task

def run_test():
    # prepare test data
    task = prepare_test_task()
    failure_prob = 0.0
    success_distribution = {False:failure_prob, True:1-failure_prob}
    # the following test process should be easily reproducible on the CAST/Java level
    planner = Planner()  # start a planning server
    pmID = planner.new_task(task)
    while True:
        
        plan = planner.current_plan(pmID)
        # simulate full observability:
        task.facts = planner.current_state_estimation(pmID)
        if DEBUG:
            print "fcts", task.facts
        result = planner.monitor_plan(plan, task)
        is_obsolete = not result.executable or not result.goal_achieved
        if is_obsolete:
            plan = planner.find_plan(task)
            planner.add_plan(pmID, plan)
            goal_reached = is_empty(plan)
        else:
            goal_reached = is_empty(plan) and result.goal_achieved
        if goal_reached:
            break
        steps = planner.possible_next_steps(pmID)
        #print "next possible steps:", steps   # always a one-element set in this example...
        step = random.choice(steps)
        print "executing step:", step
        planner.advance(pmID, step, time)
        time += 1
        # simulate execution success
        success = choose_from_prob_distribution(success_distribution)
        # simulate perception
        if success:
            if step.startswith("__sensor__"):
                pos = step.split()[-1]
                if pos == "bedroom":
                    planner.update_pm_state(pmID, ["pos coffee : bedroom"])
                    print "positive sensing: pos coffee = bedroom"
                elif pos == "living_room" or pos == "kitchen":
                    planner.negative_sensing(pmID, step)
        else:
            print "simulated execution failure. nothing happened."
    print "problem solved by executing the following actions:"
    print planner.execution_history(pmID)

def run_test_new():
    # prepare test data
    task = prepare_test_task()
    # the following test process should be easily reproducible on the CAST/Java level
    planner = Planner()  # start a planning server
    taskID = planner.new_task(task)
    real_facts = task.facts  
    planner.set_pm_state(taskID, real_facts) # start with full world knowledge
    goal_reached = False
    time = 0
    while not goal_reached:
        plan = planner.current_plan(taskID)
        # simulate full observability:
        task.facts = planner.current_state_estimation(taskID)
        if DEBUG:
            print "fcts", task.facts
        result = planner.monitor_plan(plan, task)
        is_obsolete = not result.executable or not result.goal_achieved
        if is_obsolete:
            plan = planner.find_plan(task)
            planner.add_plan(taskID, plan)
            goal_reached = is_empty(plan)
        else:
            goal_reached = is_empty(plan) and result.goal_achieved
        if goal_reached:
            break
        steps = planner.possible_next_steps(taskID)
        #print "next possible steps:", steps   # always a one-element set in this example...
        step = random.choice(steps)
        print "executing step:", step
        planner.advance(taskID, step, time)
        time += 1
        # simulate execution success
        success = choose_from_prob_distribution(success_distribution)
        # simulate perception
        if success:
            if step.startswith("__sensor__"):
                pos = step.split()[-1]
                if pos == "bedroom":
                    planner.update_pm_state(taskID, ["pos coffee : bedroom"])
                    print "positive sensing: pos coffee = bedroom"
                elif pos == "living_room" or pos == "kitchen":
                    planner.negative_sensing(taskID, step)
        else:
            print "simulated execution failure. nothing happened."
    print "problem solved by executing the following actions:"
    print planner.execution_history(taskID)


if __name__ == "__main__":
    if "-d" in sys.argv:
        DEBUG = True
    p = Planner()
    p.self_test()
