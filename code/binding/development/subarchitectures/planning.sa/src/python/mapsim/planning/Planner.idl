/*
  
  This IDL specifies a high-level client API for the Continual
  Collaborative Planning (CCP) code in the CoSy year 4 system.

  An example of the use of this API is self_test() function of
  server_implementation_cosy.py.  This should provide a good feeling for
  the intended use.  The rest of this text describes the expected process
  flow in a little more detail:
  For describing tasks, the PlanningTask data structure is used.  The
  continual planner can maintain planning/execution models for several
  planning tasks concurrently.  Each such task can referred to uniquely by
  its task_id.  This id is produced and set when the task is first
  registered with the planner: new_task(task) This will register the task
  with the continual planner and set the ID.
  
  The current state of the task as recorded by the planner can always be
  retrieved by
        task = current_task_state(task_id)

  If you want to change the state, goal, set of objects, etc during the
  continual planning process, make the appropriate changes in the task
  object (or in a copy that uses *the same task_id*) and call:
        change_task(task, clear_first=True) or change_task(task, clear_first=False) 
  where clear_first==False means that unchanged data is kept, whereas
  clear_first==True will delete all old info first.

  When the task is brought up-to-date, the planner can be called:
        info = continual_planning(task_id)
  This returns some info about the state of planning as well as of the
  execution (CCPInformation struct).  There's of course a lot of room for
  extension here...

  If the info struct confirms that the goal is still achievable, then the
  planner will have a plan for doing this.  Currently, that plan is not
  visible from the API. (This can be changed in a blink, if
  wanted.)  Instead you can only access the set of directly
  executable actions in the plan:
        commands = next_executable_plan_steps(task_id)  
        
  (For dialogue moves, it may make sense to even return whole subplans that
  contain only planned speech acts, which may then be combined into
  utterances.  E.g.: Providing an acknowledgment and asking a clarification
  question may constitute two actions for the planner but may be combined
  into one utterance in the ComSys.  This is not in the API yet, but will
  be as soon as we work on the planner/comsys integration.)

  At their core commands are about planned physical actions, but they may
  have some "modal" (or meta) information, too.  The basic case is "execute
  this action", but other forms may be "observe", "request", "acknowledge
  request of", etc.

  The client code is supposed to somehow choose one command among those
  returned by next_executable_plan_steps() and then execute it physically.
  In order to support execution monitoring, the planner provides the
  function
         changes = expected_changes(task_id, cmd)
  This returns a list of facts that are supposed to change (or to become
  newly known) during the execution of a command.

  After having executed a command, the planner must be informed about this,
  by calling
        command_was_executed(task_id, cmd, success)  
  where success is a boolean describing whether (from the POV of the
  executing component) the execution was successful.  This will update the
  state of the planner and the current plan (i.e. the command will be
  removed from the plan).

  After this step, the whole process (beginning with updating the task with
  new observations etc) can be repeated until the goal has either beeen
  achieved or has become unachievable.

 */

module Planner {

	//////////////////////////////////////////////////////////////////
	// general definitions
	//////////////////////////////////////////////////////////////////

	const string TRUE_STR = "true";
	const string FALSE_STR = "false";

	typedef string TaskID;
 
	exception Failure {
		string message;
	};

	
	
	//////////////////////////////////////////////////////////////////
	// Structures for describing planning tasks
	//////////////////////////////////////////////////////////////////

	/* object declation for use in MAPL initial states*/
	struct ObjectDeclaration {
		string name;
		string type;
	};
	typedef sequence<ObjectDeclaration> ObjectList;

	enum ModalityEnum {NO_MODALITY, K_MODALITY};

	struct Fact {
		ModalityEnum modality;        
		string agent;  
		string name;                 /* name of the state variable used */
		sequence<string> arguments;  /* argument list */
		string value;                /* any value from the domain of 'name' + "unknown" */
	};
	typedef sequence<Fact> FactList;

	typedef string Goal;  // goal formula

	/* all information about a task in one struct */
	struct PlanningTask {
		TaskID task_id; 
		string planning_agent;  // the name of the planning agent (as in objects)
		ObjectList objects;
		FactList facts;
		sequence<Goal> goals;   // conjunction of goals
		string domain_name;
		string domain_fn;
		// maybe also have a field for the current plan here?
	};



	//////////////////////////////////////////////////////////////////
	// Structures describing the state of the continual planning process
	// for a particular task
	//////////////////////////////////////////////////////////////////

	enum ExecutionState {GOAL_ACHIEVED, GOAL_ACHIEVABLE, GOAL_UNACHIEVABLE};

	enum PlanningState {OLD_PLAN_KEPT, CHANGED_PLAN};

	/*  could contain info like: replanning was triggered
		- by state change
		- by goal change
		- by enabled assertion
	*/
	struct CCPInformation {
		string description;
	};

	/* */
	struct CCPState {
		ExecutionState execution_state;
		PlanningState planning_state;
		CCPInformation info;  // additional info, if needed
	};



	//////////////////////////////////////////////////////////////////
	// plans and plan-like structures
	//////////////////////////////////////////////////////////////////
	
	struct GroundAction {
		string name;                 /* operator name */
		sequence<string> args;  /* argument list */
	};

	typedef string CommandType;  // must somehow reflect the actual Command
								 // type hiearchy.  But how to do this best?

	/* Commands use ground actions as arguments, i.e. they are a kind of
	   meta actions.  This is mainly necessary for dialogue moves,
	   e.g. to 'request' a particular ground action from another agent.*/
	struct Command {
		CommandType type;
		sequence<string> cmd_args;
		GroundAction mapl_action;
		TaskID task_id;
	};
	typedef sequence<Command> CommandSeq;

	/* graph representation of partially-ordered plans.*/
	struct Edge {
		unsigned short predNode;  /* integer refers to the ground action with this *position* in the 'nodes' list of aSimplePOPlan */
		unsigned short succNode;  /* see above */
		string reason;  /* this field *may* be used to describe the reason why two actions have this ordering constraint */
	};

	struct SimplePOPlan {
		string planID;
		sequence<GroundAction> nodes;
		sequence<Edge> edges;
	};


	
 
	//////////////////////////////////////////////////////////////////
	// Planner API
	//////////////////////////////////////////////////////////////////

	/* The PlannerServer provides the external interface with the
	   planner and monitoring components.  Additionally, it provides
	   methods for storing and querying plan memories,
	   i.e. histories of plan execution and plan changes.
	*/
	interface PlannerServer {

		// set up a planning problem

		/* Register a new task with the planner.
		   Side effect: sets a unique TaskID for that task */
		void new_task(inout PlanningTask task);

		/* Load a MAPL task, convert it to a PlanningTask as specified
		   here, and register it with the planner */
		PlanningTask load_mapl_task(in string task_fn, in string domain_fn, in string planning_agent);
		
		/* change task data during the continual planning process.
		   clear_first==False means that unchanged data is kept, whereas
		   clear_first==True will delete all old info first. */
		void change_task(in PlanningTask task, in boolean clear_first);

		/* returns the task as stored by the planner */
		PlanningTask current_task_state(in TaskID task_id);


		// planning and monitoring

		/* Checks if current plan is still valid and, if not, replans.
		   This more or less hides the whole planning and monitoring
		   process.  Returns information about the results and the state of
		   the CCP algorithm. */
		CCPState continual_planning(in TaskID task_id) raises (Failure);


		//  access to planning information

		// currently no direct access to the plan
		//SimplePOPlan current_plan(in TaskID task_id);

		CommandSeq next_executable_plan_steps(in TaskID task_id);

		FactList expected_changes(in TaskID task_id, in Command cmd);

		// returns a list of all executed actions
		// removed for the time being: should better return a plan that
		// tries to connect commands *causally*
		// also: should include information about success of actions
		//CommandSeq get_execution_history(in TaskID task_id);

		void command_was_executed(in TaskID task_id, in Command cmd, in boolean success);


		// Report negative result of a sensing action, i.e. couldn't sense
		// expected value
		void negative_sensing(in TaskID task_id, in GroundAction sensing_action);
		
		// Do a test of all functionality with some sample input.
		void self_test();

		// Shut down the planner server
		void kill_me();

	};

};
