package Planner;


/**
* Planner/PlannerServerPOA.java .
* Generated by the IDL-to-Java compiler (portable), version "3.2"
* from Planner.idl
* Freitag, 13. MŠrz 2009 17.31 Uhr CET
*/


/* The PlannerServer provides the external interface with the
	   planner and monitoring components.  Additionally, it provides
	   methods for storing and querying plan memories,
	   i.e. histories of plan execution and plan changes.
	*/
public abstract class PlannerServerPOA extends org.omg.PortableServer.Servant
 implements Planner.PlannerServerOperations, org.omg.CORBA.portable.InvokeHandler
{

  // Constructors

  private static java.util.Hashtable _methods = new java.util.Hashtable ();
  static
  {
    _methods.put ("new_task", new java.lang.Integer (0));
    _methods.put ("load_mapl_task", new java.lang.Integer (1));
    _methods.put ("change_task", new java.lang.Integer (2));
    _methods.put ("current_task_state", new java.lang.Integer (3));
    _methods.put ("continual_planning", new java.lang.Integer (4));
    _methods.put ("next_executable_plan_steps", new java.lang.Integer (5));
    _methods.put ("expected_changes", new java.lang.Integer (6));
    _methods.put ("command_was_executed", new java.lang.Integer (7));
    _methods.put ("negative_sensing", new java.lang.Integer (8));
    _methods.put ("self_test", new java.lang.Integer (9));
    _methods.put ("kill_me", new java.lang.Integer (10));
  }

  public org.omg.CORBA.portable.OutputStream _invoke (String $method,
                                org.omg.CORBA.portable.InputStream in,
                                org.omg.CORBA.portable.ResponseHandler $rh)
  {
    org.omg.CORBA.portable.OutputStream out = null;
    java.lang.Integer __method = (java.lang.Integer)_methods.get ($method);
    if (__method == null)
      throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);

    switch (__method.intValue ())
    {

  /* Register a new task with the planner.
  		   Side effect: sets a unique TaskID for that task */
       case 0:  // Planner/PlannerServer/new_task
       {
         Planner.PlanningTaskHolder task = new Planner.PlanningTaskHolder ();
         task.value = Planner.PlanningTaskHelper.read (in);
         this.new_task (task);
         out = $rh.createReply();
         Planner.PlanningTaskHelper.write (out, task.value);
         break;
       }


  /* Load a MAPL task, convert it to a PlanningTask as specified
  		   here, and register it with the planner */
       case 1:  // Planner/PlannerServer/load_mapl_task
       {
         String task_fn = in.read_string ();
         String domain_fn = in.read_string ();
         String planning_agent = in.read_string ();
         Planner.PlanningTask $result = null;
         $result = this.load_mapl_task (task_fn, domain_fn, planning_agent);
         out = $rh.createReply();
         Planner.PlanningTaskHelper.write (out, $result);
         break;
       }


  /* change task data during the continual planning process.
  		   clear_first==False means that unchanged data is kept, whereas
  		   clear_first==True will delete all old info first. */
       case 2:  // Planner/PlannerServer/change_task
       {
         Planner.PlanningTask task = Planner.PlanningTaskHelper.read (in);
         boolean clear_first = in.read_boolean ();
         this.change_task (task, clear_first);
         out = $rh.createReply();
         break;
       }


  /* returns the task as stored by the planner */
       case 3:  // Planner/PlannerServer/current_task_state
       {
         String task_id = Planner.TaskIDHelper.read (in);
         Planner.PlanningTask $result = null;
         $result = this.current_task_state (task_id);
         out = $rh.createReply();
         Planner.PlanningTaskHelper.write (out, $result);
         break;
       }


  /* Checks if current plan is still valid and, if not, replans.
  		   This more or less hides the whole planning and monitoring
  		   process.  Returns information about the results and the state of
  		   the CCP algorithm. */
       case 4:  // Planner/PlannerServer/continual_planning
       {
         try {
           String task_id = Planner.TaskIDHelper.read (in);
           Planner.CCPState $result = null;
           $result = this.continual_planning (task_id);
           out = $rh.createReply();
           Planner.CCPStateHelper.write (out, $result);
         } catch (Planner.Failure $ex) {
           out = $rh.createExceptionReply ();
           Planner.FailureHelper.write (out, $ex);
         }
         break;
       }


  //SimplePOPlan current_plan(in TaskID task_id);
       case 5:  // Planner/PlannerServer/next_executable_plan_steps
       {
         String task_id = Planner.TaskIDHelper.read (in);
         Planner.Command $result[] = null;
         $result = this.next_executable_plan_steps (task_id);
         out = $rh.createReply();
         Planner.CommandSeqHelper.write (out, $result);
         break;
       }

       case 6:  // Planner/PlannerServer/expected_changes
       {
         String task_id = Planner.TaskIDHelper.read (in);
         Planner.Command cmd = Planner.CommandHelper.read (in);
         Planner.Fact $result[] = null;
         $result = this.expected_changes (task_id, cmd);
         out = $rh.createReply();
         Planner.FactListHelper.write (out, $result);
         break;
       }


  //CommandSeq get_execution_history(in TaskID task_id);
       case 7:  // Planner/PlannerServer/command_was_executed
       {
         String task_id = Planner.TaskIDHelper.read (in);
         Planner.Command cmd = Planner.CommandHelper.read (in);
         boolean success = in.read_boolean ();
         this.command_was_executed (task_id, cmd, success);
         out = $rh.createReply();
         break;
       }


  // expected value
       case 8:  // Planner/PlannerServer/negative_sensing
       {
         String task_id = Planner.TaskIDHelper.read (in);
         Planner.GroundAction sensing_action = Planner.GroundActionHelper.read (in);
         this.negative_sensing (task_id, sensing_action);
         out = $rh.createReply();
         break;
       }


  // Do a test of all functionality with some sample input.
       case 9:  // Planner/PlannerServer/self_test
       {
         this.self_test ();
         out = $rh.createReply();
         break;
       }


  // Shut down the planner server
       case 10:  // Planner/PlannerServer/kill_me
       {
         this.kill_me ();
         out = $rh.createReply();
         break;
       }

       default:
         throw new org.omg.CORBA.BAD_OPERATION (0, org.omg.CORBA.CompletionStatus.COMPLETED_MAYBE);
    }

    return out;
  } // _invoke

  // Type-specific CORBA::Object operations
  private static String[] __ids = {
    "IDL:Planner/PlannerServer:1.0"};

  public String[] _all_interfaces (org.omg.PortableServer.POA poa, byte[] objectId)
  {
    return (String[])__ids.clone ();
  }

  public PlannerServer _this() 
  {
    return PlannerServerHelper.narrow(
    super._this_object());
  }

  public PlannerServer _this(org.omg.CORBA.ORB orb) 
  {
    return PlannerServerHelper.narrow(
    super._this_object(orb));
  }


} // class PlannerServerPOA
