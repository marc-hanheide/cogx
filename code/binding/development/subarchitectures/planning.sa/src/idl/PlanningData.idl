//#include "LFEssentials.idl"
//#include "SpatialData.idl"

#include <CAST.idl>
#include <Planner.idl>

module planning {

  module autogen {

    /**
     * Helper struct to contain lists of facts and objects. Could be
     * used to represent a planning state, or a subset of the entities
     * in a planning state.
     **/
    struct PlanningStateLists {
      Planner::ObjectList m_objects;
      Planner::FactList m_facts;
    };


    /**
     * A struct used to request a planning state from a component.
     **/
    struct PlanningStateRequest {
      //lists to contain the state
      PlanningStateLists m_state;
      //the address of the planning process request that generated this request
      cast::cdl::WorkingMemoryAddress m_pprAddr;
    };

    /**
     * Various states that planning processes can be in.
     **/
    enum PlanningStatus {    
      PROPOSED,
      ADOPTED,
      INCOMPLETE,
      COMPLETE,
      PREPARING,
      PLANNING,
      REPLANNING,
      EXECUTING
    };



    /**
     * A struct that represents a request to start a continual planning
     * process
     */
    struct PlanningProcessRequest {
      /** the MAPL goal string **/
      string m_maplGoal; 
      /** the name of the domain **/
      string m_domainName; 
      /** the file which contains the domain that describes this
	  problem **/
      string m_domainFile; 
      /** the name of the executing agent
       **/
      string m_agent;
      /** a list of subarchitectures which can supply knowledge to
	  planning problem **/
      cast::cdl::SubarchitectureIDList m_contributors; 
    
      /**
       * Something that caused this request to be generated. A motive
       * perhaps.
       */
      cast::cdl::WorkingMemoryPointer m_cause;

      /**
       * Whether to execute or not
       */
      boolean m_execute;

      /**
       * The status of the request
       */
      PlanningStatus m_status;

      /**
       * Status after execution
       */
      cast::cdl::TriBool m_succeeded;

      /**
       * Any additional state to always be included in the planning
       * task. This is always used, but can be manipulated with the
       * add and delete lists of the Action struct.
       */
      PlanningStateLists m_additionalState;
    };


  
    /**
     * A general struct used to describe actions from a plan.
     */
    struct Action {
      /**
       * A pointer to a more detailed specification of the action.
       */
      cast::cdl::WorkingMemoryPointer m_action;

      /**
       * Something that caused this action to be generated. A motive
       * perhaps.
       */
      cast::cdl::WorkingMemoryPointer m_cause;

        
      /**
       * The current status of this action.
       */
      PlanningStatus m_status;

      /**
       * Status after execution
       */
      cast::cdl::TriBool m_succeeded;

      /**
       * After the action is complete in the planner, add this to the state.
       */
      PlanningStateLists m_addList;

      /**
       * After the action is complete in the planner, add this from the state.
       */
      PlanningStateLists m_deleteList;
    };

    /**
     * A struct used to register that an action can be performed
     */
    struct ActionRegistration {
      //the id of the component... may not be used
      FrameworkBasics::FrameworkProcessID m_component;
        
      // the subarchitecture where the component lives
      cast::cdl::SubarchitectureID m_subarchitecture;

      //the action string it can work on (put, place etc.)
      string m_action;
    };

    //older stuff...

    struct PlanningProblem {
      //bstring m_goalDescID;
      string m_maplGoal; // the MAPL goal string
      Planner::ObjectList m_objectList;
      Planner::FactList m_factList;
      string m_domainFile; //the file which contains the domain that describes this problem
    };


    struct Plan {
      //string m_goalDescID;
      ///The address of the planning problem for which this is the plan
      cast::cdl::WorkingMemoryAddress m_problem;
      ///The plan itself
      Planner::SimplePOPlan m_plan;
    };

 

  };
};
