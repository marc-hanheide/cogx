#ifndef NAV_DATA_IDL
#define NAV_DATA_IDL

#include "FrameworkBasics.idl"

module NavData {
  
  struct RobotPose {
    FrameworkBasics::BALTTime  m_time;
    double m_x;
    double m_y;
    double m_theta;
    double m_cov[9];
  };

  struct LineMapEndPt {
    long m_id;
    double m_x;
    double m_y;
  };

  struct LineMapSegement {
    LineMapEndPt m_start;
    LineMapEndPt m_end;
  };

  typedef sequence<LineMapSegement> LineMapSeq;

  struct LineMap {
    FrameworkBasics::BALTTime  m_time;
    LineMapSeq m_lines;    
  };

  struct Goal {
    double m_x;
    double m_y;
  };


  // Here is where the new code starts

  struct Obj {

    FrameworkBasics::BALTTime  m_time;
    double m_radius;
    string m_category;
    short m_mobility;
    long m_objectID;
    
  };


  struct FNode {  // Free Node

    double m_x;
    double m_y;
    double m_z;
    double m_theta;
    long m_areaID;
    string m_areaType;
    long m_nodeID;
    short m_gateway; // gateway (1) or not (0)
    double m_maxSpeed;
    double m_width;
    string m_name;
  };


  struct AEdge { // Accessibility Edge
    
    long m_startNodeID;
    long m_endNodeID;
    double m_w;   

  };


  struct ONode { // Object Node

    double m_x;
    double m_y;
    double m_z;
    long m_areaID;
    string m_areaType;
    long m_nodeID;
    string m_category;
    double m_radius;
    long m_objectID;
    
  };

  struct VEdge { // Visibility Edge

    FrameworkBasics::BALTTime  m_time;
    long m_startNodeID;
    long m_endNodeID;
    double m_w;

  };
  
  struct Area { // Area
    long m_id;
  };

  struct TopologicalRobotPos { // High-level robot pose
    long m_areaID;
  };

  typedef sequence<Obj> ObjSequence;
  typedef sequence<FNode> FNodeSequence;
  typedef sequence<AEdge> AEdgeSequence;
  typedef sequence<ONode> ONodeSequence;
  typedef sequence<VEdge> VEdgeSequence;
  typedef sequence<Area> AreaSequence;

  struct NavGraph {
    
    long m_numNodes; // |m_FNodes| + |m_ONodes|
    long m_numEdges; // |m_AEdges| + |m_VEdges|
 
    ObjSequence m_Objects;
    FNodeSequence m_FNodes;
    AEdgeSequence m_AEdges;
    ONodeSequence m_ONodes;
    VEdgeSequence m_VEdges;    
   
  };

  // NavCommand IDL which communicates commands from conceptual map
  // 

  enum Command {GOTO_OBJECT, 
		GOTO_PLACE,
		COME_FORWARD, 
		GO_BACK, 
		PERSON_FOLLOW, 
		TURN, // relative
		TURN_TO, // absolute
		EXPLORE, 
		STOP,
	    // This is a special command used by Object.sa. It makes the rest
	    // of the tasks be pending until the block_control command is
	    // removed by the sender or cancelled by an urgent task. 
	    // It allows to send NavCtrlCommands bypassing the TranslationProcess 
	    // in a safe way.
	    BLOCK_CONTROL};

  enum Completion {PENDING,     // hasnt started 
		   IN_PROGRESS, // started but not finished
		   ABORTED,     // aborted due to higher priority command
		   FAILED,      // finished unsuccessfully
		   SUCCEEDED};  // finished successfully

  enum StatusError {OBJECT_NOT_RECOGNIZED, 
                    PLACE_NOT_RECOGNIZED, 
                    PERSON_NOT_FOUND,
                    TARGET_UNREACHABLE,
                    REPLACED_BY_NEW_CMD,
                    NONE,
                    UNKNOWN};

  enum Priority {URGENT,   // removes everything else from the queue
		 HIGH,     // goes to the start of the queue
		 NORMAL};  // gets done if nothing else of higher priority
                           // is in the queue.  

  struct NavCommand {

    Command m_command;

    Priority m_priority;
   
    // the string can be things like "kitchen" or "tv" 
    // for some of the commands the string will be used 
    // and for others it will be ignored.    

    string m_target;
    
    // for commands in terms of x, y, theta
    // in case there are some humans that want to communicate
    // in those terms

    double m_xpos;
    double m_ypos;
    double m_theta;

    // for commands in polar coordinates
    
    double m_angle;

    // for movement commands in polar coordinates or 
    // commands like "go forward 1m".
    
    double m_distance;

    // Execution related feedback

    StatusError m_status;
    
    Completion m_completion;

  };
  
  // IDL NavCntlCommand which communicates from the Nav translation process to 
  // Nav Controller
  // Internal communication within the subarch.
  enum CtrlCommand {GOTO_XYA, 
		    GOTO_XY,
		    GOTO_POLAR,
		    GOTO_AREA,
		    GOTO_NODE,
		    APPROACH_XY,
		    APPROACH_XYA,
		    ROTATE_REL, 
		    lEXPLORE, 
		    ROTATE_ABS,
		    BACK_OFF,
		    FOLLOW_PERSON,
		    STOP_ROBOT};
  
  
  struct NavCtrlCommand {
    
    CtrlCommand m_command;
    
    double m_x, m_y, m_r, m_theta;
    double m_distance;
    long m_areaID;
    long m_nodeID;

    StatusError m_status;

    Completion m_completion;   
    
  };

  /// This struct contains information about a person that we are tracking
  struct Person {
    FrameworkBasics::BALTTime  m_time; // timestamp when last updated

    long m_id;

    double m_x;
    double m_y;
    double m_theta;

    double m_speed;
    double m_visibility;

    long m_areaID;
  };

  // This struct contains information about which of the tracked
  // people is followed
  struct PersonFollowed {
    FrameworkBasics::BALTTime  m_time; // timestamp when last updated
    long m_id;  // -1 means no person followed
  };

  // NOTE: so far only laser features for place classification are
  // considered. The following code may change considerably to include
  // laser features for people detection
  
  // Control command types for the place laser feature extraction
  enum PlaceLaserFeatureExtractorCommandType {
    PLACE_EXTRACT_NEXT, // extract features for the next available scan
    PLACE_EXTRACT_BEGIN, // start feature extraction
    PLACE_EXTRACT_STOP // stop feature extraction
  };

  struct PlaceLaserFeatureExtractorCommand {
     PlaceLaserFeatureExtractorCommandType m_command;
  };

  const string LASER_FEATURE_ARRAY_TYPE_STRING = "Nav:LaserFeatureArray";

  struct LaserFeatureArray {
    long m_numFeatures;
    double m_value[500];
    FrameworkBasics::BALTTime  m_time; // timestamp of the laser scan from which the features where generated
  };
  
  /* Indication sent by some component saying that "some object is here"
   * (when in following mode)
   */
  struct Indication {
  	string m_object;
  };
  
  struct Tag {
    string m_object;
    long m_areaID;
    string m_behaviour;
    double m_robot_x, m_robot_y, m_robot_theta;
    double m_user_x, m_user_y, m_user_theta;
    FrameworkBasics::BALTTime m_time;
  };
  
};

#endif
