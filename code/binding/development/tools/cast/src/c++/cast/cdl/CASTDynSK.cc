// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "CAST.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mOntologyEntry = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/OntologyEntry:1.0", "OntologyEntry", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_OntologyEntry = _0RL_tc_cast_mcdl_mOntologyEntry;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_OntologyEntry = _0RL_tc_cast_mcdl_mOntologyEntry;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryID = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryID:1.0", "WorkingMemoryID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryID = _0RL_tc_cast_mcdl_mWorkingMemoryID;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryID = _0RL_tc_cast_mcdl_mWorkingMemoryID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mSubarchitectureID = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/SubarchitectureID:1.0", "SubarchitectureID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_SubarchitectureID = _0RL_tc_cast_mcdl_mSubarchitectureID;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_SubarchitectureID = _0RL_tc_cast_mcdl_mSubarchitectureID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryIDList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryIDList:1.0", "WorkingMemoryIDList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mWorkingMemoryID, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryIDList = _0RL_tc_cast_mcdl_mWorkingMemoryIDList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryIDList = _0RL_tc_cast_mcdl_mWorkingMemoryIDList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mSubarchitectureIDList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/SubarchitectureIDList:1.0", "SubarchitectureIDList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mSubarchitectureID, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_SubarchitectureIDList = _0RL_tc_cast_mcdl_mSubarchitectureIDList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_SubarchitectureIDList = _0RL_tc_cast_mcdl_mSubarchitectureIDList;
#endif

static const char* _0RL_enumMember_cast_mcdl_mReceiverDeleteCondition[] = { "DELETE_RECEIVER", "DO_NOT_DELETE_RECEIVER" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mReceiverDeleteCondition = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/ReceiverDeleteCondition:1.0", "ReceiverDeleteCondition", _0RL_enumMember_cast_mcdl_mReceiverDeleteCondition, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_ReceiverDeleteCondition = _0RL_tc_cast_mcdl_mReceiverDeleteCondition;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_ReceiverDeleteCondition = _0RL_tc_cast_mcdl_mReceiverDeleteCondition;
#endif

static const char* _0RL_enumMember_cast_mcdl_mWorkingMemoryOperation[] = { "ADD", "OVERWRITE", "DELETE", "GET", "WILDCARD" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryOperation = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/WorkingMemoryOperation:1.0", "WorkingMemoryOperation", _0RL_enumMember_cast_mcdl_mWorkingMemoryOperation, 5, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryOperation = _0RL_tc_cast_mcdl_mWorkingMemoryOperation;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryOperation = _0RL_tc_cast_mcdl_mWorkingMemoryOperation;
#endif

static const char* _0RL_enumMember_cast_mcdl_mWorkingMemoryChangeQueueBehaviour[] = { "DISCARD", "QUEUE" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryChangeQueueBehaviour = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/WorkingMemoryChangeQueueBehaviour:1.0", "WorkingMemoryChangeQueueBehaviour", _0RL_enumMember_cast_mcdl_mWorkingMemoryChangeQueueBehaviour, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeQueueBehaviour = _0RL_tc_cast_mcdl_mWorkingMemoryChangeQueueBehaviour;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryChangeQueueBehaviour = _0RL_tc_cast_mcdl_mWorkingMemoryChangeQueueBehaviour;
#endif

static const char* _0RL_enumMember_cast_mcdl_mFilterRestriction[] = { "LOCAL_SA", "ALL_SA" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mFilterRestriction = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/FilterRestriction:1.0", "FilterRestriction", _0RL_enumMember_cast_mcdl_mFilterRestriction, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_FilterRestriction = _0RL_tc_cast_mcdl_mFilterRestriction;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_FilterRestriction = _0RL_tc_cast_mcdl_mFilterRestriction;
#endif

static const char* _0RL_enumMember_cast_mcdl_mOperationMode[] = { "BLOCKING", "NON_BLOCKING" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mOperationMode = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/OperationMode:1.0", "OperationMode", _0RL_enumMember_cast_mcdl_mOperationMode, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_OperationMode = _0RL_tc_cast_mcdl_mOperationMode;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_OperationMode = _0RL_tc_cast_mcdl_mOperationMode;
#endif

static const char* _0RL_enumMember_cast_mcdl_mWorkingMemoryPermissions[] = { "LOCKED_O", "LOCKED_OD", "LOCKED_ODR", "UNLOCKED", "DOES_NOT_EXIST", "ALREADY_LOCKED" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryPermissions = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/WorkingMemoryPermissions:1.0", "WorkingMemoryPermissions", _0RL_enumMember_cast_mcdl_mWorkingMemoryPermissions, 6, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPermissions = _0RL_tc_cast_mcdl_mWorkingMemoryPermissions;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryPermissions = _0RL_tc_cast_mcdl_mWorkingMemoryPermissions;
#endif

static const char* _0RL_enumMember_cast_mcdl_mWorkingMemoryLockRequest[] = { "REQUEST_LOCK_O", "REQUEST_LOCK_OD", "REQUEST_LOCK_ODR", "REQUEST_TRY_LOCK_O", "REQUEST_TRY_LOCK_OD", "REQUEST_TRY_LOCK_ODR", "REQUEST_UNLOCK", "REQUEST_STATUS" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryLockRequest = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/WorkingMemoryLockRequest:1.0", "WorkingMemoryLockRequest", _0RL_enumMember_cast_mcdl_mWorkingMemoryLockRequest, 8, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryLockRequest = _0RL_tc_cast_mcdl_mWorkingMemoryLockRequest;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryLockRequest = _0RL_tc_cast_mcdl_mWorkingMemoryLockRequest;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mWorkingMemoryAddress[] = {
  {"m_id", _0RL_tc_cast_mcdl_mWorkingMemoryID},
  {"m_subarchitecture", _0RL_tc_cast_mcdl_mSubarchitectureID}
};

#ifdef _0RL_tc_cast_mcdl_mWorkingMemoryAddress
#  undef _0RL_tc_cast_mcdl_mWorkingMemoryAddress
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryAddress = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/WorkingMemoryAddress:1.0", "WorkingMemoryAddress", _0RL_structmember_cast_mcdl_mWorkingMemoryAddress, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryAddress = _0RL_tc_cast_mcdl_mWorkingMemoryAddress;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryAddress = _0RL_tc_cast_mcdl_mWorkingMemoryAddress;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mWorkingMemoryPointer[] = {
  {"m_type", _0RL_tc_cast_mcdl_mOntologyEntry},
  {"m_address", _0RL_tc_cast_mcdl_mWorkingMemoryAddress}
};

#ifdef _0RL_tc_cast_mcdl_mWorkingMemoryPointer
#  undef _0RL_tc_cast_mcdl_mWorkingMemoryPointer
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryPointer = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/WorkingMemoryPointer:1.0", "WorkingMemoryPointer", _0RL_structmember_cast_mcdl_mWorkingMemoryPointer, 2, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPointer = _0RL_tc_cast_mcdl_mWorkingMemoryPointer;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryPointer = _0RL_tc_cast_mcdl_mWorkingMemoryPointer;
#endif










static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryPointerList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryPointerList:1.0", "WorkingMemoryPointerList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mWorkingMemoryPointer, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryPointerList = _0RL_tc_cast_mcdl_mWorkingMemoryPointerList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryPointerList = _0RL_tc_cast_mcdl_mWorkingMemoryPointerList;
#endif


static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mWorkingMemoryEntry[] = {
  {"m_operation", _0RL_tc_cast_mcdl_mWorkingMemoryOperation},
  {"m_address", _0RL_tc_cast_mcdl_mWorkingMemoryAddress},
  {"m_type", _0RL_tc_cast_mcdl_mOntologyEntry},
  {"m_version", CORBA::TypeCode::PR_long_tc()},
  {"m_data", CORBA::TypeCode::PR_any_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mWorkingMemoryEntry
#  undef _0RL_tc_cast_mcdl_mWorkingMemoryEntry
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryEntry = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/WorkingMemoryEntry:1.0", "WorkingMemoryEntry", _0RL_structmember_cast_mcdl_mWorkingMemoryEntry, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryEntry = _0RL_tc_cast_mcdl_mWorkingMemoryEntry;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryEntry = _0RL_tc_cast_mcdl_mWorkingMemoryEntry;
#endif










static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryEntryList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryEntryList:1.0", "WorkingMemoryEntryList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mWorkingMemoryEntry, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryEntryList = _0RL_tc_cast_mcdl_mWorkingMemoryEntryList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryEntryList = _0RL_tc_cast_mcdl_mWorkingMemoryEntryList;
#endif





static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryAddressList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryAddressList:1.0", "WorkingMemoryAddressList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mWorkingMemoryAddress, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryAddressList = _0RL_tc_cast_mcdl_mWorkingMemoryAddressList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryAddressList = _0RL_tc_cast_mcdl_mWorkingMemoryAddressList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mFrameworkProcessID = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/FrameworkProcessID:1.0", "FrameworkProcessID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mWorkingMemoryChange[] = {
  {"m_operation", _0RL_tc_cast_mcdl_mWorkingMemoryOperation},
  {"m_src", _0RL_tc_FrameworkBasics_mFrameworkProcessID},
  {"m_address", _0RL_tc_cast_mcdl_mWorkingMemoryAddress},
  {"m_type", _0RL_tc_cast_mcdl_mOntologyEntry}
};

#ifdef _0RL_tc_cast_mcdl_mWorkingMemoryChange
#  undef _0RL_tc_cast_mcdl_mWorkingMemoryChange
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryChange = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/WorkingMemoryChange:1.0", "WorkingMemoryChange", _0RL_structmember_cast_mcdl_mWorkingMemoryChange, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChange = _0RL_tc_cast_mcdl_mWorkingMemoryChange;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryChange = _0RL_tc_cast_mcdl_mWorkingMemoryChange;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mWorkingMemoryChangeFilter[] = {
  {"m_operation", _0RL_tc_cast_mcdl_mWorkingMemoryOperation},
  {"m_src", _0RL_tc_FrameworkBasics_mFrameworkProcessID},
  {"m_address", _0RL_tc_cast_mcdl_mWorkingMemoryAddress},
  {"m_type", _0RL_tc_cast_mcdl_mOntologyEntry},
  {"m_restriction", _0RL_tc_cast_mcdl_mFilterRestriction},
  {"m_filterChange", _0RL_tc_cast_mcdl_mWorkingMemoryOperation},
  {"m_origin", _0RL_tc_FrameworkBasics_mFrameworkProcessID}
};

#ifdef _0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter
#  undef _0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/WorkingMemoryChangeFilter:1.0", "WorkingMemoryChangeFilter", _0RL_structmember_cast_mcdl_mWorkingMemoryChangeFilter, 7, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeFilter = _0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryChangeFilter = _0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter;
#endif










static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mWorkingMemoryChangeList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/WorkingMemoryChangeList:1.0", "WorkingMemoryChangeList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mWorkingMemoryChange, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_WorkingMemoryChangeList = _0RL_tc_cast_mcdl_mWorkingMemoryChangeList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_WorkingMemoryChangeList = _0RL_tc_cast_mcdl_mWorkingMemoryChangeList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskName = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskName:1.0", "TaskName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskName = _0RL_tc_cast_mcdl_mTaskName;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskName = _0RL_tc_cast_mcdl_mTaskName;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskNameList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskNameList:1.0", "TaskNameList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mTaskName, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskNameList = _0RL_tc_cast_mcdl_mTaskNameList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskNameList = _0RL_tc_cast_mcdl_mTaskNameList;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskID = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskID:1.0", "TaskID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskID = _0RL_tc_cast_mcdl_mTaskID;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskID = _0RL_tc_cast_mcdl_mTaskID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskTag = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskTag:1.0", "TaskTag", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskTag = _0RL_tc_cast_mcdl_mTaskTag;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskTag = _0RL_tc_cast_mcdl_mTaskTag;
#endif

static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskTagList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskTagList:1.0", "TaskTagList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mTaskTag, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskTagList = _0RL_tc_cast_mcdl_mTaskTagList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskTagList = _0RL_tc_cast_mcdl_mTaskTagList;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mTaskDescription[] = {
  {"m_taskName", _0RL_tc_cast_mcdl_mTaskName},
  {"m_predecessors", _0RL_tc_cast_mcdl_mTaskNameList},
  {"m_superGoals", _0RL_tc_cast_mcdl_mTaskNameList},
  {"m_tags", _0RL_tc_cast_mcdl_mTaskTagList}
};

#ifdef _0RL_tc_cast_mcdl_mTaskDescription
#  undef _0RL_tc_cast_mcdl_mTaskDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskDescription = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/TaskDescription:1.0", "TaskDescription", _0RL_structmember_cast_mcdl_mTaskDescription, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskDescription = _0RL_tc_cast_mcdl_mTaskDescription;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskDescription = _0RL_tc_cast_mcdl_mTaskDescription;
#endif






static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskDescriptionList = CORBA::TypeCode::PR_alias_tc("IDL:cast/cdl/TaskDescriptionList:1.0", "TaskDescriptionList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mTaskDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskDescriptionList = _0RL_tc_cast_mcdl_mTaskDescriptionList;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskDescriptionList = _0RL_tc_cast_mcdl_mTaskDescriptionList;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mInformationProcessingTask[] = {
  {"m_id", _0RL_tc_cast_mcdl_mTaskID},
  {"m_taskName", _0RL_tc_cast_mcdl_mTaskName}
};

#ifdef _0RL_tc_cast_mcdl_mInformationProcessingTask
#  undef _0RL_tc_cast_mcdl_mInformationProcessingTask
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mInformationProcessingTask = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/InformationProcessingTask:1.0", "InformationProcessingTask", _0RL_structmember_cast_mcdl_mInformationProcessingTask, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_InformationProcessingTask = _0RL_tc_cast_mcdl_mInformationProcessingTask;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_InformationProcessingTask = _0RL_tc_cast_mcdl_mInformationProcessingTask;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mTaskGoal[] = {
  {"m_id", _0RL_tc_cast_mcdl_mTaskID},
  {"m_goalName", _0RL_tc_cast_mcdl_mTaskName},
  {"m_taskAddresses", _0RL_tc_cast_mcdl_mWorkingMemoryAddressList}
};

#ifdef _0RL_tc_cast_mcdl_mTaskGoal
#  undef _0RL_tc_cast_mcdl_mTaskGoal
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskGoal = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/TaskGoal:1.0", "TaskGoal", _0RL_structmember_cast_mcdl_mTaskGoal, 3, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskGoal = _0RL_tc_cast_mcdl_mTaskGoal;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskGoal = _0RL_tc_cast_mcdl_mTaskGoal;
#endif


static const char* _0RL_enumMember_cast_mcdl_mTaskManagementDecision[] = { "GOAL_ADOPTED", "GOAL_REJECTED", "GOAL_WAITING" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskManagementDecision = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/TaskManagementDecision:1.0", "TaskManagementDecision", _0RL_enumMember_cast_mcdl_mTaskManagementDecision, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskManagementDecision = _0RL_tc_cast_mcdl_mTaskManagementDecision;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskManagementDecision = _0RL_tc_cast_mcdl_mTaskManagementDecision;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mTaskManagementResult[] = {
  {"m_id", _0RL_tc_cast_mcdl_mTaskID},
  {"m_decision", _0RL_tc_cast_mcdl_mTaskManagementDecision}
};

#ifdef _0RL_tc_cast_mcdl_mTaskManagementResult
#  undef _0RL_tc_cast_mcdl_mTaskManagementResult
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskManagementResult = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/TaskManagementResult:1.0", "TaskManagementResult", _0RL_structmember_cast_mcdl_mTaskManagementResult, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskManagementResult = _0RL_tc_cast_mcdl_mTaskManagementResult;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskManagementResult = _0RL_tc_cast_mcdl_mTaskManagementResult;
#endif


static const char* _0RL_enumMember_cast_mcdl_mTaskOutcome[] = { "PROCESSING_INCOMPLETE", "PROCESSING_COMPLETE", "PROCESSING_COMPLETE_SUCCESS", "PROCESSING_COMPLETE_FAILURE" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskOutcome = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/TaskOutcome:1.0", "TaskOutcome", _0RL_enumMember_cast_mcdl_mTaskOutcome, 4, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskOutcome = _0RL_tc_cast_mcdl_mTaskOutcome;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskOutcome = _0RL_tc_cast_mcdl_mTaskOutcome;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mTaskResult[] = {
  {"m_id", _0RL_tc_cast_mcdl_mTaskID},
  {"m_outcome", _0RL_tc_cast_mcdl_mTaskOutcome}
};

#ifdef _0RL_tc_cast_mcdl_mTaskResult
#  undef _0RL_tc_cast_mcdl_mTaskResult
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTaskResult = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/TaskResult:1.0", "TaskResult", _0RL_structmember_cast_mcdl_mTaskResult, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TaskResult = _0RL_tc_cast_mcdl_mTaskResult;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TaskResult = _0RL_tc_cast_mcdl_mTaskResult;
#endif




static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mtesting_mCASTTestStruct[] = {
  {"m_count", CORBA::TypeCode::PR_long_tc()},
  {"m_change", _0RL_tc_cast_mcdl_mWorkingMemoryChange}
};

#ifdef _0RL_tc_cast_mcdl_mtesting_mCASTTestStruct
#  undef _0RL_tc_cast_mcdl_mtesting_mCASTTestStruct
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mtesting_mCASTTestStruct = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/testing/CASTTestStruct:1.0", "CASTTestStruct", _0RL_structmember_cast_mcdl_mtesting_mCASTTestStruct, 2, &_0RL_tcTrack);



#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace testing { 
  const ::CORBA::TypeCode_ptr _tc_CASTTestStruct = _0RL_tc_cast_mcdl_mtesting_mCASTTestStruct;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::testing::_tc_CASTTestStruct = _0RL_tc_cast_mcdl_mtesting_mCASTTestStruct;
#endif


static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mtesting_mTestDummyStruct[] = {
  {"m_dummy", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_cast_mcdl_mtesting_mTestDummyStruct
#  undef _0RL_tc_cast_mcdl_mtesting_mTestDummyStruct
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mtesting_mTestDummyStruct = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/testing/TestDummyStruct:1.0", "TestDummyStruct", _0RL_structmember_cast_mcdl_mtesting_mTestDummyStruct, 1, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace testing { 
  const ::CORBA::TypeCode_ptr _tc_TestDummyStruct = _0RL_tc_cast_mcdl_mtesting_mTestDummyStruct;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::testing::_tc_TestDummyStruct = _0RL_tc_cast_mcdl_mtesting_mTestDummyStruct;
#endif


static const char* _0RL_enumMember_cast_mcdl_mui_mOutputType[] = { "PRINT", "DEBUG", "LOG" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mui_mOutputType = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/ui/OutputType:1.0", "OutputType", _0RL_enumMember_cast_mcdl_mui_mOutputType, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace ui { 
  const ::CORBA::TypeCode_ptr _tc_OutputType = _0RL_tc_cast_mcdl_mui_mOutputType;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::ui::_tc_OutputType = _0RL_tc_cast_mcdl_mui_mOutputType;
#endif

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mui_mTextOutput[] = {
  {"m_type", _0RL_tc_cast_mcdl_mui_mOutputType},
  {"m_string", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)}
};

#ifdef _0RL_tc_cast_mcdl_mui_mTextOutput
#  undef _0RL_tc_cast_mcdl_mui_mTextOutput
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mui_mTextOutput = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/ui/TextOutput:1.0", "TextOutput", _0RL_structmember_cast_mcdl_mui_mTextOutput, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace ui { 
  const ::CORBA::TypeCode_ptr _tc_TextOutput = _0RL_tc_cast_mcdl_mui_mTextOutput;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::ui::_tc_TextOutput = _0RL_tc_cast_mcdl_mui_mTextOutput;
#endif


static const char* _0RL_enumMember_cast_mcdl_mui_mComponentEventType[] = { "ADD", "OVERWRITE", "DELETE", "GET", "START", "END", "PROPOSED" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mui_mComponentEventType = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/ui/ComponentEventType:1.0", "ComponentEventType", _0RL_enumMember_cast_mcdl_mui_mComponentEventType, 7, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace ui { 
  const ::CORBA::TypeCode_ptr _tc_ComponentEventType = _0RL_tc_cast_mcdl_mui_mComponentEventType;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::ui::_tc_ComponentEventType = _0RL_tc_cast_mcdl_mui_mComponentEventType;
#endif

static CORBA::PR_structMember _0RL_structmember_FrameworkBasics_mBALTTime[] = {
  {"m_s", CORBA::TypeCode::PR_long_tc()},
  {"m_us", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_FrameworkBasics_mBALTTime
#  undef _0RL_tc_FrameworkBasics_mBALTTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mBALTTime = CORBA::TypeCode::PR_struct_tc("IDL:FrameworkBasics/BALTTime:1.0", "BALTTime", _0RL_structmember_FrameworkBasics_mBALTTime, 2, &_0RL_tcTrack);

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mui_mComponentEvent[] = {
  {"m_event", _0RL_tc_cast_mcdl_mui_mComponentEventType},
  {"m_componentID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_target", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_dataType", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_dataID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_time", _0RL_tc_FrameworkBasics_mBALTTime}
};

#ifdef _0RL_tc_cast_mcdl_mui_mComponentEvent
#  undef _0RL_tc_cast_mcdl_mui_mComponentEvent
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mui_mComponentEvent = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/ui/ComponentEvent:1.0", "ComponentEvent", _0RL_structmember_cast_mcdl_mui_mComponentEvent, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace ui { 
  const ::CORBA::TypeCode_ptr _tc_ComponentEvent = _0RL_tc_cast_mcdl_mui_mComponentEvent;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::ui::_tc_ComponentEvent = _0RL_tc_cast_mcdl_mui_mComponentEvent;
#endif


static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mui_mComponentStatus[] = {
  {"m_component", _0RL_tc_FrameworkBasics_mFrameworkProcessID},
  {"m_subarchitecture", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_log", CORBA::TypeCode::PR_boolean_tc()},
  {"m_debug", CORBA::TypeCode::PR_boolean_tc()},
  {"m_locked", CORBA::TypeCode::PR_boolean_tc()},
  {"m_sleeping", CORBA::TypeCode::PR_boolean_tc()},
  {"m_changeQueue", CORBA::TypeCode::PR_long_tc()},
  {"m_totalChangeEventsFiltered", CORBA::TypeCode::PR_long_tc()},
  {"m_totalChangeEventsReceived", CORBA::TypeCode::PR_long_tc()},
  {"m_totalAdds", CORBA::TypeCode::PR_long_tc()},
  {"m_totalOverwrites", CORBA::TypeCode::PR_long_tc()},
  {"m_totalDeletes", CORBA::TypeCode::PR_long_tc()},
  {"m_totalReads", CORBA::TypeCode::PR_long_tc()},
  {"m_totalProposals", CORBA::TypeCode::PR_long_tc()},
  {"m_totalStarts", CORBA::TypeCode::PR_long_tc()},
  {"m_totalEnds", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mui_mComponentStatus
#  undef _0RL_tc_cast_mcdl_mui_mComponentStatus
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mui_mComponentStatus = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/ui/ComponentStatus:1.0", "ComponentStatus", _0RL_structmember_cast_mcdl_mui_mComponentStatus, 16, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace ui { 
  const ::CORBA::TypeCode_ptr _tc_ComponentStatus = _0RL_tc_cast_mcdl_mui_mComponentStatus;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::ui::_tc_ComponentStatus = _0RL_tc_cast_mcdl_mui_mComponentStatus;
#endif


static const char* _0RL_enumMember_cast_mcdl_mTriBool[] = { "triTrue", "triFalse", "triIndeterminate" };
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mTriBool = CORBA::TypeCode::PR_enum_tc("IDL:cast/cdl/TriBool:1.0", "TriBool", _0RL_enumMember_cast_mcdl_mTriBool, 3, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { 
  const ::CORBA::TypeCode_ptr _tc_TriBool = _0RL_tc_cast_mcdl_mTriBool;
} } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::_tc_TriBool = _0RL_tc_cast_mcdl_mTriBool;
#endif

static void _0RL_cast_mcdl_mWorkingMemoryIDList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryIDList* _p = (cast::cdl::WorkingMemoryIDList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryIDList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryIDList* _p = new cast::cdl::WorkingMemoryIDList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryIDList_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryIDList* _p = (cast::cdl::WorkingMemoryIDList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryIDList& _s)
{
  cast::cdl::WorkingMemoryIDList* _p = new cast::cdl::WorkingMemoryIDList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryIDList,
               _0RL_cast_mcdl_mWorkingMemoryIDList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryIDList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryIDList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryIDList,
               _0RL_cast_mcdl_mWorkingMemoryIDList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryIDList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryIDList*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryIDList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryIDList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryIDList,
                    _0RL_cast_mcdl_mWorkingMemoryIDList_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryIDList_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryIDList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryIDList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mSubarchitectureIDList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::SubarchitectureIDList* _p = (cast::cdl::SubarchitectureIDList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mSubarchitectureIDList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::SubarchitectureIDList* _p = new cast::cdl::SubarchitectureIDList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mSubarchitectureIDList_destructor_fn(void* _v)
{
  cast::cdl::SubarchitectureIDList* _p = (cast::cdl::SubarchitectureIDList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::SubarchitectureIDList& _s)
{
  cast::cdl::SubarchitectureIDList* _p = new cast::cdl::SubarchitectureIDList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mSubarchitectureIDList,
               _0RL_cast_mcdl_mSubarchitectureIDList_marshal_fn,
               _0RL_cast_mcdl_mSubarchitectureIDList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::SubarchitectureIDList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mSubarchitectureIDList,
               _0RL_cast_mcdl_mSubarchitectureIDList_marshal_fn,
               _0RL_cast_mcdl_mSubarchitectureIDList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::SubarchitectureIDList*& _sp)
{
  return _a >>= (const cast::cdl::SubarchitectureIDList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::SubarchitectureIDList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mSubarchitectureIDList,
                    _0RL_cast_mcdl_mSubarchitectureIDList_unmarshal_fn,
                    _0RL_cast_mcdl_mSubarchitectureIDList_marshal_fn,
                    _0RL_cast_mcdl_mSubarchitectureIDList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::SubarchitectureIDList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mReceiverDeleteCondition_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ReceiverDeleteCondition* _p = (cast::cdl::ReceiverDeleteCondition*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mReceiverDeleteCondition_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ReceiverDeleteCondition* _p = (cast::cdl::ReceiverDeleteCondition*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ReceiverDeleteCondition _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mReceiverDeleteCondition,
               _0RL_cast_mcdl_mReceiverDeleteCondition_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ReceiverDeleteCondition& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mReceiverDeleteCondition,
                       _0RL_cast_mcdl_mReceiverDeleteCondition_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mWorkingMemoryOperation_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryOperation* _p = (cast::cdl::WorkingMemoryOperation*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryOperation_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryOperation* _p = (cast::cdl::WorkingMemoryOperation*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryOperation _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryOperation,
               _0RL_cast_mcdl_mWorkingMemoryOperation_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryOperation& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryOperation,
                       _0RL_cast_mcdl_mWorkingMemoryOperation_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mWorkingMemoryChangeQueueBehaviour_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryChangeQueueBehaviour* _p = (cast::cdl::WorkingMemoryChangeQueueBehaviour*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryChangeQueueBehaviour_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryChangeQueueBehaviour* _p = (cast::cdl::WorkingMemoryChangeQueueBehaviour*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeQueueBehaviour _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChangeQueueBehaviour,
               _0RL_cast_mcdl_mWorkingMemoryChangeQueueBehaviour_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeQueueBehaviour& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryChangeQueueBehaviour,
                       _0RL_cast_mcdl_mWorkingMemoryChangeQueueBehaviour_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mFilterRestriction_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::FilterRestriction* _p = (cast::cdl::FilterRestriction*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mFilterRestriction_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::FilterRestriction* _p = (cast::cdl::FilterRestriction*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::FilterRestriction _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mFilterRestriction,
               _0RL_cast_mcdl_mFilterRestriction_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::FilterRestriction& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mFilterRestriction,
                       _0RL_cast_mcdl_mFilterRestriction_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mOperationMode_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::OperationMode* _p = (cast::cdl::OperationMode*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mOperationMode_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::OperationMode* _p = (cast::cdl::OperationMode*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::OperationMode _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mOperationMode,
               _0RL_cast_mcdl_mOperationMode_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::OperationMode& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mOperationMode,
                       _0RL_cast_mcdl_mOperationMode_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mWorkingMemoryPermissions_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryPermissions* _p = (cast::cdl::WorkingMemoryPermissions*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryPermissions_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryPermissions* _p = (cast::cdl::WorkingMemoryPermissions*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPermissions _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryPermissions,
               _0RL_cast_mcdl_mWorkingMemoryPermissions_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPermissions& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryPermissions,
                       _0RL_cast_mcdl_mWorkingMemoryPermissions_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mWorkingMemoryLockRequest_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryLockRequest* _p = (cast::cdl::WorkingMemoryLockRequest*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryLockRequest_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryLockRequest* _p = (cast::cdl::WorkingMemoryLockRequest*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryLockRequest _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryLockRequest,
               _0RL_cast_mcdl_mWorkingMemoryLockRequest_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryLockRequest& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryLockRequest,
                       _0RL_cast_mcdl_mWorkingMemoryLockRequest_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mWorkingMemoryAddress_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryAddress* _p = (cast::cdl::WorkingMemoryAddress*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryAddress_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryAddress* _p = new cast::cdl::WorkingMemoryAddress;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryAddress_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryAddress* _p = (cast::cdl::WorkingMemoryAddress*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddress& _s)
{
  cast::cdl::WorkingMemoryAddress* _p = new cast::cdl::WorkingMemoryAddress(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryAddress,
               _0RL_cast_mcdl_mWorkingMemoryAddress_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryAddress_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryAddress* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryAddress,
               _0RL_cast_mcdl_mWorkingMemoryAddress_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryAddress_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryAddress*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryAddress*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddress*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryAddress,
                    _0RL_cast_mcdl_mWorkingMemoryAddress_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryAddress_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryAddress_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryAddress*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryPointer_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryPointer* _p = (cast::cdl::WorkingMemoryPointer*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryPointer_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryPointer* _p = new cast::cdl::WorkingMemoryPointer;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryPointer_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryPointer* _p = (cast::cdl::WorkingMemoryPointer*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointer& _s)
{
  cast::cdl::WorkingMemoryPointer* _p = new cast::cdl::WorkingMemoryPointer(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryPointer,
               _0RL_cast_mcdl_mWorkingMemoryPointer_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryPointer_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPointer* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryPointer,
               _0RL_cast_mcdl_mWorkingMemoryPointer_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryPointer_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPointer*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryPointer*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointer*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryPointer,
                    _0RL_cast_mcdl_mWorkingMemoryPointer_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryPointer_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryPointer_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryPointer*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryPointerList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryPointerList* _p = (cast::cdl::WorkingMemoryPointerList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryPointerList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryPointerList* _p = new cast::cdl::WorkingMemoryPointerList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryPointerList_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryPointerList* _p = (cast::cdl::WorkingMemoryPointerList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointerList& _s)
{
  cast::cdl::WorkingMemoryPointerList* _p = new cast::cdl::WorkingMemoryPointerList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryPointerList,
               _0RL_cast_mcdl_mWorkingMemoryPointerList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryPointerList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryPointerList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryPointerList,
               _0RL_cast_mcdl_mWorkingMemoryPointerList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryPointerList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryPointerList*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryPointerList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryPointerList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryPointerList,
                    _0RL_cast_mcdl_mWorkingMemoryPointerList_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryPointerList_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryPointerList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryPointerList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryEntry_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryEntry* _p = (cast::cdl::WorkingMemoryEntry*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryEntry_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryEntry* _p = new cast::cdl::WorkingMemoryEntry;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryEntry_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryEntry* _p = (cast::cdl::WorkingMemoryEntry*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntry& _s)
{
  cast::cdl::WorkingMemoryEntry* _p = new cast::cdl::WorkingMemoryEntry(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryEntry,
               _0RL_cast_mcdl_mWorkingMemoryEntry_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryEntry_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryEntry* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryEntry,
               _0RL_cast_mcdl_mWorkingMemoryEntry_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryEntry_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryEntry*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryEntry*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntry*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryEntry,
                    _0RL_cast_mcdl_mWorkingMemoryEntry_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryEntry_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryEntry_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryEntry*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryEntryList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryEntryList* _p = (cast::cdl::WorkingMemoryEntryList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryEntryList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryEntryList* _p = new cast::cdl::WorkingMemoryEntryList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryEntryList_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryEntryList* _p = (cast::cdl::WorkingMemoryEntryList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntryList& _s)
{
  cast::cdl::WorkingMemoryEntryList* _p = new cast::cdl::WorkingMemoryEntryList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryEntryList,
               _0RL_cast_mcdl_mWorkingMemoryEntryList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryEntryList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryEntryList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryEntryList,
               _0RL_cast_mcdl_mWorkingMemoryEntryList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryEntryList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryEntryList*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryEntryList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryEntryList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryEntryList,
                    _0RL_cast_mcdl_mWorkingMemoryEntryList_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryEntryList_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryEntryList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryEntryList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryAddressList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryAddressList* _p = (cast::cdl::WorkingMemoryAddressList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryAddressList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryAddressList* _p = new cast::cdl::WorkingMemoryAddressList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryAddressList_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryAddressList* _p = (cast::cdl::WorkingMemoryAddressList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddressList& _s)
{
  cast::cdl::WorkingMemoryAddressList* _p = new cast::cdl::WorkingMemoryAddressList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryAddressList,
               _0RL_cast_mcdl_mWorkingMemoryAddressList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryAddressList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryAddressList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryAddressList,
               _0RL_cast_mcdl_mWorkingMemoryAddressList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryAddressList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryAddressList*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryAddressList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryAddressList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryAddressList,
                    _0RL_cast_mcdl_mWorkingMemoryAddressList_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryAddressList_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryAddressList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryAddressList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryChange_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryChange* _p = (cast::cdl::WorkingMemoryChange*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryChange_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryChange* _p = new cast::cdl::WorkingMemoryChange;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryChange_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryChange* _p = (cast::cdl::WorkingMemoryChange*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChange& _s)
{
  cast::cdl::WorkingMemoryChange* _p = new cast::cdl::WorkingMemoryChange(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChange,
               _0RL_cast_mcdl_mWorkingMemoryChange_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChange_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChange* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChange,
               _0RL_cast_mcdl_mWorkingMemoryChange_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChange_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChange*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryChange*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChange*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryChange,
                    _0RL_cast_mcdl_mWorkingMemoryChange_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChange_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChange_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryChange*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryChangeFilter_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryChangeFilter* _p = (cast::cdl::WorkingMemoryChangeFilter*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryChangeFilter_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryChangeFilter* _p = new cast::cdl::WorkingMemoryChangeFilter;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryChangeFilter_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryChangeFilter* _p = (cast::cdl::WorkingMemoryChangeFilter*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeFilter& _s)
{
  cast::cdl::WorkingMemoryChangeFilter* _p = new cast::cdl::WorkingMemoryChangeFilter(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter,
               _0RL_cast_mcdl_mWorkingMemoryChangeFilter_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChangeFilter_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeFilter* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter,
               _0RL_cast_mcdl_mWorkingMemoryChangeFilter_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChangeFilter_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeFilter*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryChangeFilter*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeFilter*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryChangeFilter,
                    _0RL_cast_mcdl_mWorkingMemoryChangeFilter_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChangeFilter_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChangeFilter_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryChangeFilter*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mWorkingMemoryChangeList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::WorkingMemoryChangeList* _p = (cast::cdl::WorkingMemoryChangeList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mWorkingMemoryChangeList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::WorkingMemoryChangeList* _p = new cast::cdl::WorkingMemoryChangeList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mWorkingMemoryChangeList_destructor_fn(void* _v)
{
  cast::cdl::WorkingMemoryChangeList* _p = (cast::cdl::WorkingMemoryChangeList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeList& _s)
{
  cast::cdl::WorkingMemoryChangeList* _p = new cast::cdl::WorkingMemoryChangeList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChangeList,
               _0RL_cast_mcdl_mWorkingMemoryChangeList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChangeList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mWorkingMemoryChangeList,
               _0RL_cast_mcdl_mWorkingMemoryChangeList_marshal_fn,
               _0RL_cast_mcdl_mWorkingMemoryChangeList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::WorkingMemoryChangeList*& _sp)
{
  return _a >>= (const cast::cdl::WorkingMemoryChangeList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::WorkingMemoryChangeList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mWorkingMemoryChangeList,
                    _0RL_cast_mcdl_mWorkingMemoryChangeList_unmarshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChangeList_marshal_fn,
                    _0RL_cast_mcdl_mWorkingMemoryChangeList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::WorkingMemoryChangeList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskNameList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskNameList* _p = (cast::cdl::TaskNameList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskNameList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskNameList* _p = new cast::cdl::TaskNameList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskNameList_destructor_fn(void* _v)
{
  cast::cdl::TaskNameList* _p = (cast::cdl::TaskNameList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskNameList& _s)
{
  cast::cdl::TaskNameList* _p = new cast::cdl::TaskNameList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskNameList,
               _0RL_cast_mcdl_mTaskNameList_marshal_fn,
               _0RL_cast_mcdl_mTaskNameList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskNameList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskNameList,
               _0RL_cast_mcdl_mTaskNameList_marshal_fn,
               _0RL_cast_mcdl_mTaskNameList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskNameList*& _sp)
{
  return _a >>= (const cast::cdl::TaskNameList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskNameList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskNameList,
                    _0RL_cast_mcdl_mTaskNameList_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskNameList_marshal_fn,
                    _0RL_cast_mcdl_mTaskNameList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskNameList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskTagList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskTagList* _p = (cast::cdl::TaskTagList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskTagList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskTagList* _p = new cast::cdl::TaskTagList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskTagList_destructor_fn(void* _v)
{
  cast::cdl::TaskTagList* _p = (cast::cdl::TaskTagList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskTagList& _s)
{
  cast::cdl::TaskTagList* _p = new cast::cdl::TaskTagList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskTagList,
               _0RL_cast_mcdl_mTaskTagList_marshal_fn,
               _0RL_cast_mcdl_mTaskTagList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskTagList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskTagList,
               _0RL_cast_mcdl_mTaskTagList_marshal_fn,
               _0RL_cast_mcdl_mTaskTagList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskTagList*& _sp)
{
  return _a >>= (const cast::cdl::TaskTagList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskTagList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskTagList,
                    _0RL_cast_mcdl_mTaskTagList_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskTagList_marshal_fn,
                    _0RL_cast_mcdl_mTaskTagList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskTagList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskDescription_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskDescription* _p = (cast::cdl::TaskDescription*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskDescription* _p = new cast::cdl::TaskDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskDescription_destructor_fn(void* _v)
{
  cast::cdl::TaskDescription* _p = (cast::cdl::TaskDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskDescription& _s)
{
  cast::cdl::TaskDescription* _p = new cast::cdl::TaskDescription(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskDescription,
               _0RL_cast_mcdl_mTaskDescription_marshal_fn,
               _0RL_cast_mcdl_mTaskDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskDescription* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskDescription,
               _0RL_cast_mcdl_mTaskDescription_marshal_fn,
               _0RL_cast_mcdl_mTaskDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskDescription*& _sp)
{
  return _a >>= (const cast::cdl::TaskDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskDescription,
                    _0RL_cast_mcdl_mTaskDescription_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskDescription_marshal_fn,
                    _0RL_cast_mcdl_mTaskDescription_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskDescriptionList_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskDescriptionList* _p = (cast::cdl::TaskDescriptionList*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskDescriptionList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskDescriptionList* _p = new cast::cdl::TaskDescriptionList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskDescriptionList_destructor_fn(void* _v)
{
  cast::cdl::TaskDescriptionList* _p = (cast::cdl::TaskDescriptionList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskDescriptionList& _s)
{
  cast::cdl::TaskDescriptionList* _p = new cast::cdl::TaskDescriptionList(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskDescriptionList,
               _0RL_cast_mcdl_mTaskDescriptionList_marshal_fn,
               _0RL_cast_mcdl_mTaskDescriptionList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskDescriptionList* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskDescriptionList,
               _0RL_cast_mcdl_mTaskDescriptionList_marshal_fn,
               _0RL_cast_mcdl_mTaskDescriptionList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskDescriptionList*& _sp)
{
  return _a >>= (const cast::cdl::TaskDescriptionList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskDescriptionList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskDescriptionList,
                    _0RL_cast_mcdl_mTaskDescriptionList_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskDescriptionList_marshal_fn,
                    _0RL_cast_mcdl_mTaskDescriptionList_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskDescriptionList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mInformationProcessingTask_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::InformationProcessingTask* _p = (cast::cdl::InformationProcessingTask*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mInformationProcessingTask_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::InformationProcessingTask* _p = new cast::cdl::InformationProcessingTask;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mInformationProcessingTask_destructor_fn(void* _v)
{
  cast::cdl::InformationProcessingTask* _p = (cast::cdl::InformationProcessingTask*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::InformationProcessingTask& _s)
{
  cast::cdl::InformationProcessingTask* _p = new cast::cdl::InformationProcessingTask(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mInformationProcessingTask,
               _0RL_cast_mcdl_mInformationProcessingTask_marshal_fn,
               _0RL_cast_mcdl_mInformationProcessingTask_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::InformationProcessingTask* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mInformationProcessingTask,
               _0RL_cast_mcdl_mInformationProcessingTask_marshal_fn,
               _0RL_cast_mcdl_mInformationProcessingTask_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::InformationProcessingTask*& _sp)
{
  return _a >>= (const cast::cdl::InformationProcessingTask*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::InformationProcessingTask*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mInformationProcessingTask,
                    _0RL_cast_mcdl_mInformationProcessingTask_unmarshal_fn,
                    _0RL_cast_mcdl_mInformationProcessingTask_marshal_fn,
                    _0RL_cast_mcdl_mInformationProcessingTask_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::InformationProcessingTask*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskGoal_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskGoal* _p = (cast::cdl::TaskGoal*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskGoal_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskGoal* _p = new cast::cdl::TaskGoal;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskGoal_destructor_fn(void* _v)
{
  cast::cdl::TaskGoal* _p = (cast::cdl::TaskGoal*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskGoal& _s)
{
  cast::cdl::TaskGoal* _p = new cast::cdl::TaskGoal(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskGoal,
               _0RL_cast_mcdl_mTaskGoal_marshal_fn,
               _0RL_cast_mcdl_mTaskGoal_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskGoal* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskGoal,
               _0RL_cast_mcdl_mTaskGoal_marshal_fn,
               _0RL_cast_mcdl_mTaskGoal_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskGoal*& _sp)
{
  return _a >>= (const cast::cdl::TaskGoal*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskGoal*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskGoal,
                    _0RL_cast_mcdl_mTaskGoal_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskGoal_marshal_fn,
                    _0RL_cast_mcdl_mTaskGoal_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskGoal*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskManagementDecision_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskManagementDecision* _p = (cast::cdl::TaskManagementDecision*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskManagementDecision_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskManagementDecision* _p = (cast::cdl::TaskManagementDecision*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TaskManagementDecision _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskManagementDecision,
               _0RL_cast_mcdl_mTaskManagementDecision_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskManagementDecision& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mTaskManagementDecision,
                       _0RL_cast_mcdl_mTaskManagementDecision_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mTaskManagementResult_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskManagementResult* _p = (cast::cdl::TaskManagementResult*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskManagementResult_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskManagementResult* _p = new cast::cdl::TaskManagementResult;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskManagementResult_destructor_fn(void* _v)
{
  cast::cdl::TaskManagementResult* _p = (cast::cdl::TaskManagementResult*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskManagementResult& _s)
{
  cast::cdl::TaskManagementResult* _p = new cast::cdl::TaskManagementResult(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskManagementResult,
               _0RL_cast_mcdl_mTaskManagementResult_marshal_fn,
               _0RL_cast_mcdl_mTaskManagementResult_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskManagementResult* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskManagementResult,
               _0RL_cast_mcdl_mTaskManagementResult_marshal_fn,
               _0RL_cast_mcdl_mTaskManagementResult_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskManagementResult*& _sp)
{
  return _a >>= (const cast::cdl::TaskManagementResult*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskManagementResult*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskManagementResult,
                    _0RL_cast_mcdl_mTaskManagementResult_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskManagementResult_marshal_fn,
                    _0RL_cast_mcdl_mTaskManagementResult_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskManagementResult*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTaskOutcome_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskOutcome* _p = (cast::cdl::TaskOutcome*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskOutcome_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskOutcome* _p = (cast::cdl::TaskOutcome*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TaskOutcome _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskOutcome,
               _0RL_cast_mcdl_mTaskOutcome_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskOutcome& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mTaskOutcome,
                       _0RL_cast_mcdl_mTaskOutcome_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mTaskResult_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TaskResult* _p = (cast::cdl::TaskResult*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTaskResult_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TaskResult* _p = new cast::cdl::TaskResult;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mTaskResult_destructor_fn(void* _v)
{
  cast::cdl::TaskResult* _p = (cast::cdl::TaskResult*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::TaskResult& _s)
{
  cast::cdl::TaskResult* _p = new cast::cdl::TaskResult(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskResult,
               _0RL_cast_mcdl_mTaskResult_marshal_fn,
               _0RL_cast_mcdl_mTaskResult_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::TaskResult* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTaskResult,
               _0RL_cast_mcdl_mTaskResult_marshal_fn,
               _0RL_cast_mcdl_mTaskResult_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TaskResult*& _sp)
{
  return _a >>= (const cast::cdl::TaskResult*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::TaskResult*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mTaskResult,
                    _0RL_cast_mcdl_mTaskResult_unmarshal_fn,
                    _0RL_cast_mcdl_mTaskResult_marshal_fn,
                    _0RL_cast_mcdl_mTaskResult_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::TaskResult*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mtesting_mCASTTestStruct_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::testing::CASTTestStruct* _p = (cast::cdl::testing::CASTTestStruct*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mtesting_mCASTTestStruct_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::testing::CASTTestStruct* _p = new cast::cdl::testing::CASTTestStruct;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mtesting_mCASTTestStruct_destructor_fn(void* _v)
{
  cast::cdl::testing::CASTTestStruct* _p = (cast::cdl::testing::CASTTestStruct*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::testing::CASTTestStruct& _s)
{
  cast::cdl::testing::CASTTestStruct* _p = new cast::cdl::testing::CASTTestStruct(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mtesting_mCASTTestStruct,
               _0RL_cast_mcdl_mtesting_mCASTTestStruct_marshal_fn,
               _0RL_cast_mcdl_mtesting_mCASTTestStruct_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::testing::CASTTestStruct* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mtesting_mCASTTestStruct,
               _0RL_cast_mcdl_mtesting_mCASTTestStruct_marshal_fn,
               _0RL_cast_mcdl_mtesting_mCASTTestStruct_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::testing::CASTTestStruct*& _sp)
{
  return _a >>= (const cast::cdl::testing::CASTTestStruct*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::testing::CASTTestStruct*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mtesting_mCASTTestStruct,
                    _0RL_cast_mcdl_mtesting_mCASTTestStruct_unmarshal_fn,
                    _0RL_cast_mcdl_mtesting_mCASTTestStruct_marshal_fn,
                    _0RL_cast_mcdl_mtesting_mCASTTestStruct_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::testing::CASTTestStruct*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mtesting_mTestDummyStruct_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::testing::TestDummyStruct* _p = (cast::cdl::testing::TestDummyStruct*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mtesting_mTestDummyStruct_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::testing::TestDummyStruct* _p = new cast::cdl::testing::TestDummyStruct;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mtesting_mTestDummyStruct_destructor_fn(void* _v)
{
  cast::cdl::testing::TestDummyStruct* _p = (cast::cdl::testing::TestDummyStruct*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::testing::TestDummyStruct& _s)
{
  cast::cdl::testing::TestDummyStruct* _p = new cast::cdl::testing::TestDummyStruct(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mtesting_mTestDummyStruct,
               _0RL_cast_mcdl_mtesting_mTestDummyStruct_marshal_fn,
               _0RL_cast_mcdl_mtesting_mTestDummyStruct_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::testing::TestDummyStruct* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mtesting_mTestDummyStruct,
               _0RL_cast_mcdl_mtesting_mTestDummyStruct_marshal_fn,
               _0RL_cast_mcdl_mtesting_mTestDummyStruct_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::testing::TestDummyStruct*& _sp)
{
  return _a >>= (const cast::cdl::testing::TestDummyStruct*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::testing::TestDummyStruct*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mtesting_mTestDummyStruct,
                    _0RL_cast_mcdl_mtesting_mTestDummyStruct_unmarshal_fn,
                    _0RL_cast_mcdl_mtesting_mTestDummyStruct_marshal_fn,
                    _0RL_cast_mcdl_mtesting_mTestDummyStruct_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::testing::TestDummyStruct*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mui_mOutputType_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ui::OutputType* _p = (cast::cdl::ui::OutputType*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mui_mOutputType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ui::OutputType* _p = (cast::cdl::ui::OutputType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ui::OutputType _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mOutputType,
               _0RL_cast_mcdl_mui_mOutputType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::OutputType& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mui_mOutputType,
                       _0RL_cast_mcdl_mui_mOutputType_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mui_mTextOutput_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ui::TextOutput* _p = (cast::cdl::ui::TextOutput*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mui_mTextOutput_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ui::TextOutput* _p = new cast::cdl::ui::TextOutput;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mui_mTextOutput_destructor_fn(void* _v)
{
  cast::cdl::ui::TextOutput* _p = (cast::cdl::ui::TextOutput*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::TextOutput& _s)
{
  cast::cdl::ui::TextOutput* _p = new cast::cdl::ui::TextOutput(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mTextOutput,
               _0RL_cast_mcdl_mui_mTextOutput_marshal_fn,
               _0RL_cast_mcdl_mui_mTextOutput_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::ui::TextOutput* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mTextOutput,
               _0RL_cast_mcdl_mui_mTextOutput_marshal_fn,
               _0RL_cast_mcdl_mui_mTextOutput_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::TextOutput*& _sp)
{
  return _a >>= (const cast::cdl::ui::TextOutput*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::TextOutput*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mui_mTextOutput,
                    _0RL_cast_mcdl_mui_mTextOutput_unmarshal_fn,
                    _0RL_cast_mcdl_mui_mTextOutput_marshal_fn,
                    _0RL_cast_mcdl_mui_mTextOutput_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::ui::TextOutput*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mui_mComponentEventType_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ui::ComponentEventType* _p = (cast::cdl::ui::ComponentEventType*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mui_mComponentEventType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ui::ComponentEventType* _p = (cast::cdl::ui::ComponentEventType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentEventType _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mComponentEventType,
               _0RL_cast_mcdl_mui_mComponentEventType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentEventType& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mui_mComponentEventType,
                       _0RL_cast_mcdl_mui_mComponentEventType_unmarshal_fn,
                       &_s);
}

static void _0RL_cast_mcdl_mui_mComponentEvent_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ui::ComponentEvent* _p = (cast::cdl::ui::ComponentEvent*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mui_mComponentEvent_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ui::ComponentEvent* _p = new cast::cdl::ui::ComponentEvent;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mui_mComponentEvent_destructor_fn(void* _v)
{
  cast::cdl::ui::ComponentEvent* _p = (cast::cdl::ui::ComponentEvent*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::ComponentEvent& _s)
{
  cast::cdl::ui::ComponentEvent* _p = new cast::cdl::ui::ComponentEvent(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mComponentEvent,
               _0RL_cast_mcdl_mui_mComponentEvent_marshal_fn,
               _0RL_cast_mcdl_mui_mComponentEvent_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentEvent* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mComponentEvent,
               _0RL_cast_mcdl_mui_mComponentEvent_marshal_fn,
               _0RL_cast_mcdl_mui_mComponentEvent_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentEvent*& _sp)
{
  return _a >>= (const cast::cdl::ui::ComponentEvent*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::ComponentEvent*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mui_mComponentEvent,
                    _0RL_cast_mcdl_mui_mComponentEvent_unmarshal_fn,
                    _0RL_cast_mcdl_mui_mComponentEvent_marshal_fn,
                    _0RL_cast_mcdl_mui_mComponentEvent_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::ui::ComponentEvent*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mui_mComponentStatus_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::ui::ComponentStatus* _p = (cast::cdl::ui::ComponentStatus*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mui_mComponentStatus_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::ui::ComponentStatus* _p = new cast::cdl::ui::ComponentStatus;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mui_mComponentStatus_destructor_fn(void* _v)
{
  cast::cdl::ui::ComponentStatus* _p = (cast::cdl::ui::ComponentStatus*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::ui::ComponentStatus& _s)
{
  cast::cdl::ui::ComponentStatus* _p = new cast::cdl::ui::ComponentStatus(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mComponentStatus,
               _0RL_cast_mcdl_mui_mComponentStatus_marshal_fn,
               _0RL_cast_mcdl_mui_mComponentStatus_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::ui::ComponentStatus* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mui_mComponentStatus,
               _0RL_cast_mcdl_mui_mComponentStatus_marshal_fn,
               _0RL_cast_mcdl_mui_mComponentStatus_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::ui::ComponentStatus*& _sp)
{
  return _a >>= (const cast::cdl::ui::ComponentStatus*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::ui::ComponentStatus*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mui_mComponentStatus,
                    _0RL_cast_mcdl_mui_mComponentStatus_unmarshal_fn,
                    _0RL_cast_mcdl_mui_mComponentStatus_marshal_fn,
                    _0RL_cast_mcdl_mui_mComponentStatus_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::ui::ComponentStatus*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mTriBool_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::TriBool* _p = (cast::cdl::TriBool*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mTriBool_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::TriBool* _p = (cast::cdl::TriBool*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, cast::cdl::TriBool _s)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mTriBool,
               _0RL_cast_mcdl_mTriBool_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::TriBool& _s)
{
  return _a.PR_extract(_0RL_tc_cast_mcdl_mTriBool,
                       _0RL_cast_mcdl_mTriBool_unmarshal_fn,
                       &_s);
}

