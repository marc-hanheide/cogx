// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "guitypes.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mRGBColor[] = {
  {"m_r", CORBA::TypeCode::PR_long_tc()},
  {"m_g", CORBA::TypeCode::PR_long_tc()},
  {"m_b", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mRGBColor
#  undef _0RL_tc_cast_mcdl_mguitypes_mRGBColor
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mRGBColor = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/RGBColor:1.0", "RGBColor", _0RL_structmember_cast_mcdl_mguitypes_mRGBColor, 3, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_RGBColor = _0RL_tc_cast_mcdl_mguitypes_mRGBColor;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_RGBColor = _0RL_tc_cast_mcdl_mguitypes_mRGBColor;
#endif


static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mRGBImage[] = {
  {"m_width", CORBA::TypeCode::PR_long_tc()},
  {"m_height", CORBA::TypeCode::PR_long_tc()},
  {"m_rgbBuffer", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_octet_tc(), &_0RL_tcTrack)},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mRGBImage
#  undef _0RL_tc_cast_mcdl_mguitypes_mRGBImage
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mRGBImage = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/RGBImage:1.0", "RGBImage", _0RL_structmember_cast_mcdl_mguitypes_mRGBImage, 4, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_RGBImage = _0RL_tc_cast_mcdl_mguitypes_mRGBImage;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_RGBImage = _0RL_tc_cast_mcdl_mguitypes_mRGBImage;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mText2D[] = {
  {"m_x", CORBA::TypeCode::PR_double_tc()},
  {"m_y", CORBA::TypeCode::PR_double_tc()},
  {"m_text", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mText2D
#  undef _0RL_tc_cast_mcdl_mguitypes_mText2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mText2D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Text2D:1.0", "Text2D", _0RL_structmember_cast_mcdl_mguitypes_mText2D, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Text2D = _0RL_tc_cast_mcdl_mguitypes_mText2D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Text2D = _0RL_tc_cast_mcdl_mguitypes_mText2D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mPoint2D[] = {
  {"m_x", CORBA::TypeCode::PR_double_tc()},
  {"m_y", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mPoint2D
#  undef _0RL_tc_cast_mcdl_mguitypes_mPoint2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mPoint2D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Point2D:1.0", "Point2D", _0RL_structmember_cast_mcdl_mguitypes_mPoint2D, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Point2D = _0RL_tc_cast_mcdl_mguitypes_mPoint2D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Point2D = _0RL_tc_cast_mcdl_mguitypes_mPoint2D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mLine2D[] = {
  {"m_x1", CORBA::TypeCode::PR_double_tc()},
  {"m_y1", CORBA::TypeCode::PR_double_tc()},
  {"m_x2", CORBA::TypeCode::PR_double_tc()},
  {"m_y2", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mLine2D
#  undef _0RL_tc_cast_mcdl_mguitypes_mLine2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mLine2D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Line2D:1.0", "Line2D", _0RL_structmember_cast_mcdl_mguitypes_mLine2D, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Line2D = _0RL_tc_cast_mcdl_mguitypes_mLine2D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Line2D = _0RL_tc_cast_mcdl_mguitypes_mLine2D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mRect2D[] = {
  {"m_xmin", CORBA::TypeCode::PR_double_tc()},
  {"m_ymin", CORBA::TypeCode::PR_double_tc()},
  {"m_xmax", CORBA::TypeCode::PR_double_tc()},
  {"m_ymax", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mRect2D
#  undef _0RL_tc_cast_mcdl_mguitypes_mRect2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mRect2D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Rect2D:1.0", "Rect2D", _0RL_structmember_cast_mcdl_mguitypes_mRect2D, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Rect2D = _0RL_tc_cast_mcdl_mguitypes_mRect2D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Rect2D = _0RL_tc_cast_mcdl_mguitypes_mRect2D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mPolygon2D[] = {
  {"m_x", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)},
  {"m_y", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_double_tc(), &_0RL_tcTrack)},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mPolygon2D
#  undef _0RL_tc_cast_mcdl_mguitypes_mPolygon2D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mPolygon2D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Polygon2D:1.0", "Polygon2D", _0RL_structmember_cast_mcdl_mguitypes_mPolygon2D, 4, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Polygon2D = _0RL_tc_cast_mcdl_mguitypes_mPolygon2D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Polygon2D = _0RL_tc_cast_mcdl_mguitypes_mPolygon2D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mText3D[] = {
  {"m_x", CORBA::TypeCode::PR_double_tc()},
  {"m_y", CORBA::TypeCode::PR_double_tc()},
  {"m_z", CORBA::TypeCode::PR_double_tc()},
  {"m_text", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mText3D
#  undef _0RL_tc_cast_mcdl_mguitypes_mText3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mText3D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Text3D:1.0", "Text3D", _0RL_structmember_cast_mcdl_mguitypes_mText3D, 6, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Text3D = _0RL_tc_cast_mcdl_mguitypes_mText3D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Text3D = _0RL_tc_cast_mcdl_mguitypes_mText3D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mPoint3D[] = {
  {"m_x", CORBA::TypeCode::PR_double_tc()},
  {"m_y", CORBA::TypeCode::PR_double_tc()},
  {"m_z", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mPoint3D
#  undef _0RL_tc_cast_mcdl_mguitypes_mPoint3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mPoint3D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Point3D:1.0", "Point3D", _0RL_structmember_cast_mcdl_mguitypes_mPoint3D, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Point3D = _0RL_tc_cast_mcdl_mguitypes_mPoint3D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Point3D = _0RL_tc_cast_mcdl_mguitypes_mPoint3D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mLine3D[] = {
  {"m_x1", CORBA::TypeCode::PR_double_tc()},
  {"m_y1", CORBA::TypeCode::PR_double_tc()},
  {"m_z1", CORBA::TypeCode::PR_double_tc()},
  {"m_x2", CORBA::TypeCode::PR_double_tc()},
  {"m_y2", CORBA::TypeCode::PR_double_tc()},
  {"m_z2", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mLine3D
#  undef _0RL_tc_cast_mcdl_mguitypes_mLine3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mLine3D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Line3D:1.0", "Line3D", _0RL_structmember_cast_mcdl_mguitypes_mLine3D, 8, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Line3D = _0RL_tc_cast_mcdl_mguitypes_mLine3D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Line3D = _0RL_tc_cast_mcdl_mguitypes_mLine3D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mBox3D[] = {
  {"m_cx", CORBA::TypeCode::PR_double_tc()},
  {"m_cy", CORBA::TypeCode::PR_double_tc()},
  {"m_cz", CORBA::TypeCode::PR_double_tc()},
  {"m_sx", CORBA::TypeCode::PR_double_tc()},
  {"m_sy", CORBA::TypeCode::PR_double_tc()},
  {"m_sz", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mBox3D
#  undef _0RL_tc_cast_mcdl_mguitypes_mBox3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mBox3D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Box3D:1.0", "Box3D", _0RL_structmember_cast_mcdl_mguitypes_mBox3D, 8, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Box3D = _0RL_tc_cast_mcdl_mguitypes_mBox3D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Box3D = _0RL_tc_cast_mcdl_mguitypes_mBox3D;
#endif



static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mFrame3D[] = {
  {"m_px", CORBA::TypeCode::PR_double_tc()},
  {"m_py", CORBA::TypeCode::PR_double_tc()},
  {"m_pz", CORBA::TypeCode::PR_double_tc()},
  {"m_rx", CORBA::TypeCode::PR_double_tc()},
  {"m_ry", CORBA::TypeCode::PR_double_tc()},
  {"m_rz", CORBA::TypeCode::PR_double_tc()},
  {"m_color", _0RL_tc_cast_mcdl_mguitypes_mRGBColor},
  {"m_flags", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mFrame3D
#  undef _0RL_tc_cast_mcdl_mguitypes_mFrame3D
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mFrame3D = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/Frame3D:1.0", "Frame3D", _0RL_structmember_cast_mcdl_mguitypes_mFrame3D, 8, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_Frame3D = _0RL_tc_cast_mcdl_mguitypes_mFrame3D;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_Frame3D = _0RL_tc_cast_mcdl_mguitypes_mFrame3D;
#endif























static CORBA::PR_structMember _0RL_structmember_cast_mcdl_mguitypes_mDrawBatch[] = {
  {"m_compID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_image", _0RL_tc_cast_mcdl_mguitypes_mRGBImage},
  {"m_text2Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mText2D, &_0RL_tcTrack)},
  {"m_point2Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mPoint2D, &_0RL_tcTrack)},
  {"m_line2Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mLine2D, &_0RL_tcTrack)},
  {"m_rect2Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mRect2D, &_0RL_tcTrack)},
  {"m_poly2Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mPolygon2D, &_0RL_tcTrack)},
  {"m_text3Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mText3D, &_0RL_tcTrack)},
  {"m_point3Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mPoint3D, &_0RL_tcTrack)},
  {"m_line3Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mLine3D, &_0RL_tcTrack)},
  {"m_box3Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mBox3D, &_0RL_tcTrack)},
  {"m_frame3Ds", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_cast_mcdl_mguitypes_mFrame3D, &_0RL_tcTrack)},
  {"m_texts", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack)}
};

#ifdef _0RL_tc_cast_mcdl_mguitypes_mDrawBatch
#  undef _0RL_tc_cast_mcdl_mguitypes_mDrawBatch
#endif
static CORBA::TypeCode_ptr _0RL_tc_cast_mcdl_mguitypes_mDrawBatch = CORBA::TypeCode::PR_struct_tc("IDL:cast/cdl/guitypes/DrawBatch:1.0", "DrawBatch", _0RL_structmember_cast_mcdl_mguitypes_mDrawBatch, 13, &_0RL_tcTrack);






















#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace cast { namespace cdl { namespace guitypes { 
  const ::CORBA::TypeCode_ptr _tc_DrawBatch = _0RL_tc_cast_mcdl_mguitypes_mDrawBatch;
} } } 
#else
const ::CORBA::TypeCode_ptr cast::cdl::guitypes::_tc_DrawBatch = _0RL_tc_cast_mcdl_mguitypes_mDrawBatch;
#endif


static void _0RL_cast_mcdl_mguitypes_mRGBColor_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::RGBColor* _p = (cast::cdl::guitypes::RGBColor*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mRGBColor_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::RGBColor* _p = new cast::cdl::guitypes::RGBColor;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mRGBColor_destructor_fn(void* _v)
{
  cast::cdl::guitypes::RGBColor* _p = (cast::cdl::guitypes::RGBColor*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::RGBColor& _s)
{
  cast::cdl::guitypes::RGBColor* _p = new cast::cdl::guitypes::RGBColor(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRGBColor,
               _0RL_cast_mcdl_mguitypes_mRGBColor_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRGBColor_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::RGBColor* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRGBColor,
               _0RL_cast_mcdl_mguitypes_mRGBColor_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRGBColor_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::RGBColor*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::RGBColor*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::RGBColor*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mRGBColor,
                    _0RL_cast_mcdl_mguitypes_mRGBColor_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRGBColor_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRGBColor_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::RGBColor*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mRGBImage_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::RGBImage* _p = (cast::cdl::guitypes::RGBImage*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mRGBImage_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::RGBImage* _p = new cast::cdl::guitypes::RGBImage;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mRGBImage_destructor_fn(void* _v)
{
  cast::cdl::guitypes::RGBImage* _p = (cast::cdl::guitypes::RGBImage*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::RGBImage& _s)
{
  cast::cdl::guitypes::RGBImage* _p = new cast::cdl::guitypes::RGBImage(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRGBImage,
               _0RL_cast_mcdl_mguitypes_mRGBImage_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRGBImage_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::RGBImage* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRGBImage,
               _0RL_cast_mcdl_mguitypes_mRGBImage_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRGBImage_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::RGBImage*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::RGBImage*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::RGBImage*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mRGBImage,
                    _0RL_cast_mcdl_mguitypes_mRGBImage_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRGBImage_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRGBImage_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::RGBImage*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mText2D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Text2D* _p = (cast::cdl::guitypes::Text2D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mText2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Text2D* _p = new cast::cdl::guitypes::Text2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mText2D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Text2D* _p = (cast::cdl::guitypes::Text2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Text2D& _s)
{
  cast::cdl::guitypes::Text2D* _p = new cast::cdl::guitypes::Text2D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mText2D,
               _0RL_cast_mcdl_mguitypes_mText2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mText2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Text2D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mText2D,
               _0RL_cast_mcdl_mguitypes_mText2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mText2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Text2D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Text2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Text2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mText2D,
                    _0RL_cast_mcdl_mguitypes_mText2D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mText2D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mText2D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Text2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mPoint2D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Point2D* _p = (cast::cdl::guitypes::Point2D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mPoint2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Point2D* _p = new cast::cdl::guitypes::Point2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mPoint2D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Point2D* _p = (cast::cdl::guitypes::Point2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Point2D& _s)
{
  cast::cdl::guitypes::Point2D* _p = new cast::cdl::guitypes::Point2D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPoint2D,
               _0RL_cast_mcdl_mguitypes_mPoint2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPoint2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Point2D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPoint2D,
               _0RL_cast_mcdl_mguitypes_mPoint2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPoint2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Point2D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Point2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Point2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mPoint2D,
                    _0RL_cast_mcdl_mguitypes_mPoint2D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPoint2D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPoint2D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Point2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mLine2D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Line2D* _p = (cast::cdl::guitypes::Line2D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mLine2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Line2D* _p = new cast::cdl::guitypes::Line2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mLine2D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Line2D* _p = (cast::cdl::guitypes::Line2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Line2D& _s)
{
  cast::cdl::guitypes::Line2D* _p = new cast::cdl::guitypes::Line2D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mLine2D,
               _0RL_cast_mcdl_mguitypes_mLine2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mLine2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Line2D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mLine2D,
               _0RL_cast_mcdl_mguitypes_mLine2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mLine2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Line2D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Line2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Line2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mLine2D,
                    _0RL_cast_mcdl_mguitypes_mLine2D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mLine2D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mLine2D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Line2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mRect2D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Rect2D* _p = (cast::cdl::guitypes::Rect2D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mRect2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Rect2D* _p = new cast::cdl::guitypes::Rect2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mRect2D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Rect2D* _p = (cast::cdl::guitypes::Rect2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Rect2D& _s)
{
  cast::cdl::guitypes::Rect2D* _p = new cast::cdl::guitypes::Rect2D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRect2D,
               _0RL_cast_mcdl_mguitypes_mRect2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRect2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Rect2D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mRect2D,
               _0RL_cast_mcdl_mguitypes_mRect2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mRect2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Rect2D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Rect2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Rect2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mRect2D,
                    _0RL_cast_mcdl_mguitypes_mRect2D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRect2D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mRect2D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Rect2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mPolygon2D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Polygon2D* _p = (cast::cdl::guitypes::Polygon2D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mPolygon2D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Polygon2D* _p = new cast::cdl::guitypes::Polygon2D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mPolygon2D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Polygon2D* _p = (cast::cdl::guitypes::Polygon2D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Polygon2D& _s)
{
  cast::cdl::guitypes::Polygon2D* _p = new cast::cdl::guitypes::Polygon2D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPolygon2D,
               _0RL_cast_mcdl_mguitypes_mPolygon2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPolygon2D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Polygon2D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPolygon2D,
               _0RL_cast_mcdl_mguitypes_mPolygon2D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPolygon2D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Polygon2D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Polygon2D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Polygon2D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mPolygon2D,
                    _0RL_cast_mcdl_mguitypes_mPolygon2D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPolygon2D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPolygon2D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Polygon2D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mText3D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Text3D* _p = (cast::cdl::guitypes::Text3D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mText3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Text3D* _p = new cast::cdl::guitypes::Text3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mText3D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Text3D* _p = (cast::cdl::guitypes::Text3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Text3D& _s)
{
  cast::cdl::guitypes::Text3D* _p = new cast::cdl::guitypes::Text3D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mText3D,
               _0RL_cast_mcdl_mguitypes_mText3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mText3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Text3D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mText3D,
               _0RL_cast_mcdl_mguitypes_mText3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mText3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Text3D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Text3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Text3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mText3D,
                    _0RL_cast_mcdl_mguitypes_mText3D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mText3D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mText3D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Text3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mPoint3D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Point3D* _p = (cast::cdl::guitypes::Point3D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mPoint3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Point3D* _p = new cast::cdl::guitypes::Point3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mPoint3D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Point3D* _p = (cast::cdl::guitypes::Point3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Point3D& _s)
{
  cast::cdl::guitypes::Point3D* _p = new cast::cdl::guitypes::Point3D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPoint3D,
               _0RL_cast_mcdl_mguitypes_mPoint3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPoint3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Point3D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mPoint3D,
               _0RL_cast_mcdl_mguitypes_mPoint3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mPoint3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Point3D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Point3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Point3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mPoint3D,
                    _0RL_cast_mcdl_mguitypes_mPoint3D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPoint3D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mPoint3D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Point3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mLine3D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Line3D* _p = (cast::cdl::guitypes::Line3D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mLine3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Line3D* _p = new cast::cdl::guitypes::Line3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mLine3D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Line3D* _p = (cast::cdl::guitypes::Line3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Line3D& _s)
{
  cast::cdl::guitypes::Line3D* _p = new cast::cdl::guitypes::Line3D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mLine3D,
               _0RL_cast_mcdl_mguitypes_mLine3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mLine3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Line3D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mLine3D,
               _0RL_cast_mcdl_mguitypes_mLine3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mLine3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Line3D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Line3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Line3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mLine3D,
                    _0RL_cast_mcdl_mguitypes_mLine3D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mLine3D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mLine3D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Line3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mBox3D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Box3D* _p = (cast::cdl::guitypes::Box3D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mBox3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Box3D* _p = new cast::cdl::guitypes::Box3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mBox3D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Box3D* _p = (cast::cdl::guitypes::Box3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Box3D& _s)
{
  cast::cdl::guitypes::Box3D* _p = new cast::cdl::guitypes::Box3D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mBox3D,
               _0RL_cast_mcdl_mguitypes_mBox3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mBox3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Box3D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mBox3D,
               _0RL_cast_mcdl_mguitypes_mBox3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mBox3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Box3D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Box3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Box3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mBox3D,
                    _0RL_cast_mcdl_mguitypes_mBox3D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mBox3D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mBox3D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Box3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mFrame3D_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::Frame3D* _p = (cast::cdl::guitypes::Frame3D*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mFrame3D_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::Frame3D* _p = new cast::cdl::guitypes::Frame3D;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mFrame3D_destructor_fn(void* _v)
{
  cast::cdl::guitypes::Frame3D* _p = (cast::cdl::guitypes::Frame3D*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::Frame3D& _s)
{
  cast::cdl::guitypes::Frame3D* _p = new cast::cdl::guitypes::Frame3D(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mFrame3D,
               _0RL_cast_mcdl_mguitypes_mFrame3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mFrame3D_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::Frame3D* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mFrame3D,
               _0RL_cast_mcdl_mguitypes_mFrame3D_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mFrame3D_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::Frame3D*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::Frame3D*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::Frame3D*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mFrame3D,
                    _0RL_cast_mcdl_mguitypes_mFrame3D_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mFrame3D_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mFrame3D_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::Frame3D*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_cast_mcdl_mguitypes_mDrawBatch_marshal_fn(cdrStream& _s, void* _v)
{
  cast::cdl::guitypes::DrawBatch* _p = (cast::cdl::guitypes::DrawBatch*)_v;
  *_p >>= _s;
}
static void _0RL_cast_mcdl_mguitypes_mDrawBatch_unmarshal_fn(cdrStream& _s, void*& _v)
{
  cast::cdl::guitypes::DrawBatch* _p = new cast::cdl::guitypes::DrawBatch;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_cast_mcdl_mguitypes_mDrawBatch_destructor_fn(void* _v)
{
  cast::cdl::guitypes::DrawBatch* _p = (cast::cdl::guitypes::DrawBatch*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const cast::cdl::guitypes::DrawBatch& _s)
{
  cast::cdl::guitypes::DrawBatch* _p = new cast::cdl::guitypes::DrawBatch(_s);
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mDrawBatch,
               _0RL_cast_mcdl_mguitypes_mDrawBatch_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mDrawBatch_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, cast::cdl::guitypes::DrawBatch* _sp)
{
  _a.PR_insert(_0RL_tc_cast_mcdl_mguitypes_mDrawBatch,
               _0RL_cast_mcdl_mguitypes_mDrawBatch_marshal_fn,
               _0RL_cast_mcdl_mguitypes_mDrawBatch_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, cast::cdl::guitypes::DrawBatch*& _sp)
{
  return _a >>= (const cast::cdl::guitypes::DrawBatch*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const cast::cdl::guitypes::DrawBatch*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_cast_mcdl_mguitypes_mDrawBatch,
                    _0RL_cast_mcdl_mguitypes_mDrawBatch_unmarshal_fn,
                    _0RL_cast_mcdl_mguitypes_mDrawBatch_marshal_fn,
                    _0RL_cast_mcdl_mguitypes_mDrawBatch_destructor_fn,
                    _v)) {
    _sp = (const cast::cdl::guitypes::DrawBatch*)_v;
    return 1;
  }
  return 0;
}

