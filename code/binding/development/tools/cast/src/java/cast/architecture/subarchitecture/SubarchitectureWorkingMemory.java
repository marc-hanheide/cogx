/*
 * CAST - The CoSy Architecture Schema Toolkit Copyright (C) 2006-2007
 * Nick Hawes This library is free software; you can redistribute it
 * and/or modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either version
 * 2.1 of the License, or (at your option) any later version. This
 * library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details. You should have
 * received a copy of the GNU Lesser General Public License along with
 * this library; if not, write to the Free Software Foundation, Inc., 51
 * Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package cast.architecture.subarchitecture;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.Properties;
import java.util.Queue;
import java.util.concurrent.ConcurrentHashMap;

import org.omg.CORBA.Any;
import org.omg.CORBA.ORB;

import balt.corba.data.RemoteDataTranslator;
import balt.corba.data.translation.FrameworkDataTranslatorException;
import balt.core.connectors.FrameworkConnectionException;
import balt.core.connectors.pull.primitive.interfaces.BoolPullInterface.BoolPullReceiver;
import balt.core.connectors.pull.primitive.interfaces.IntPullInterface.IntPullReceiver;
import balt.core.data.FrameworkQuery;
import cast.architecture.abstr.WorkingMemoryChangeFilterMap;
import cast.architecture.subarchitecture.SubarchitectureWorkingMemoryProtocol.WorkingMemoryPullQuery;
import cast.architecture.subarchitecture.SubarchitectureWorkingMemoryProtocol.WorkingMemoryPullQuery.WorkingMemoryQueryType;
import cast.cdl.IGNORE_SA_KEY;
import cast.cdl.WM_IDS_KEY;
import cast.cdl.WorkingMemoryAddress;
import cast.cdl.WorkingMemoryChange;
import cast.cdl.WorkingMemoryChangeFilter;
import cast.cdl.WorkingMemoryEntry;
import cast.cdl.WorkingMemoryLockRequest;
import cast.cdl.WorkingMemoryOperation;
import cast.cdl.WorkingMemoryPermissions;
import cast.cdl.XARCH_CONNECTION_PREFIX;
import cast.cdl.ui.ComponentEventType;
import cast.configuration.ArchitectureConfiguration;
import cast.core.CASTUtils;
import cast.core.components.CASTProcessingComponent;
import cast.core.data.CASTWMPermissionMap;
import cast.core.data.CASTWorkingMemory;
import cast.core.data.CASTWorkingMemoryEntry;
import cast.core.data.CASTWorkingMemoryInterface;
import cast.core.data.CASTWorkingMemoryItem;
import cast.core.interfaces.CWMELPullInterface.CWMELPullReceiver;
import cast.core.interfaces.CWMEPushInterface.CWMEPushReceiver;
import cast.core.interfaces.PermissionsPullInterface.PermissionsPullConnectorOut;
import cast.core.interfaces.PermissionsPullInterface.PermissionsPullReceiver;
import cast.core.interfaces.PermissionsPullInterface.PermissionsPullSender;
import cast.core.interfaces.WMCFPushInterface.WMCFPushConnectorOut;
import cast.core.interfaces.WMCFPushInterface.WMCFPushReceiver;
import cast.core.interfaces.WMCFPushInterface.WMCFPushSender;
import cast.core.interfaces.WMCPushInterface.WMCPushConnectorOut;
import cast.core.interfaces.WMCPushInterface.WMCPushReceiver;
import cast.core.interfaces.WMCPushInterface.WMCPushSender;
import cast.core.interfaces.WMELPullInterface.WMELPullConnectorOut;
import cast.core.interfaces.WMELPullInterface.WMELPullReceiver;
import cast.core.interfaces.WMELPullInterface.WMELPullSender;
import cast.core.interfaces.WMEPushInterface.WMEPushConnectorOut;
import cast.core.interfaces.WMEPushInterface.WMEPushReceiver;
import cast.core.interfaces.WMEPushInterface.WMEPushSender;

/**
 * Class to act as working memory for a sub-architecture. There are a lot issues
 * about the functionality that this implementation should support. Access to
 * working memory can be achieved by a number of mechanisms <br/> 1. Type
 * access. Each entry is given a type string by the originating class with
 * describes the information contained within the entry, e.g. speech string or
 * SIFT feature vector <br/> 2. WM Index. Direct random access is available via
 * numerical indices, much like an array. Indices are generated by the working
 * memory itself when new entries are added.<br/> 3. Unique ID. Each memory
 * item is given a unique ID by the originating process. This is used so that
 * the originating class has an easy way of referencing data it's created. We
 * will start with string ids for human-readability, but this may change to ints
 * for size.
 * 
 * @author nah
 */
public class SubarchitectureWorkingMemory extends CASTProcessingComponent
		implements
			WMEPushReceiver,
			CWMEPushReceiver,
			WMEPushSender,
			WMELPullSender,
			WMELPullReceiver,
			CWMELPullReceiver,
			WMCPushSender,
			WMCPushReceiver,
			WMCFPushSender,
			WMCFPushReceiver,
			IntPullReceiver,
			BoolPullReceiver,
			PermissionsPullReceiver,
			PermissionsPullSender {

	private final WorkingMemoryChangeFilterMap<String> m_componentFilters;

	private final WorkingMemoryChangeFilterMap<String> m_wmFilters;

	private final ArrayList<WMCPushConnectorOut> m_wmChangeBroadcast;

	protected final CASTWorkingMemoryInterface m_workingMemory;

	private final HashMap<String, WMCPushConnectorOut> m_xarchChangeConnections;

	// connections to other working memories, indexed by
	// sub-architecture ID
	private final Hashtable<String, WMELPullConnectorOut> m_xarchWMPullConnections;

	// connections to other working memories, indexed by
	// sub-architecture ID
	private final Hashtable<String, WMEPushConnectorOut> m_xarchWMPushConnections;

	private final HashSet<String> m_ignoreList;

	/**
	 * Determine whether to send local notifications to other subarchitectures.
	 */
	private boolean m_sendXarchChangeNotifications;

	/**
	 * Flag used in testing, whether changes are filtered before passing on to
	 * components.
	 */
	private final boolean m_wmChangeFiltering = true;

	/**
	 * Flag used in testing, whether change filters are shared with other wms.
	 */
	private final boolean m_wmDistributedFiltering = true;

	/**
	 * Stores connector
	 */
	private WMCFPushConnectorOut m_xarchWMCFPushConnector;

	/**
	 * Construct new object with a unique id. Name should be created with
	 * createName.
	 * 
	 * @param _id
	 * @see #createID(String)
	 */
	public SubarchitectureWorkingMemory(String _id) {
		super(_id);
		m_wmChangeBroadcast = new ArrayList<WMCPushConnectorOut>();
		m_workingMemory = new CASTWorkingMemory();
		m_xarchWMPullConnections = new Hashtable<String, WMELPullConnectorOut>();
		m_xarchWMPushConnections = new Hashtable<String, WMEPushConnectorOut>();
		m_xarchChangeConnections = new HashMap<String, WMCPushConnectorOut>();
		m_componentFilters = new WorkingMemoryChangeFilterMap<String>();
		m_wmFilters = new WorkingMemoryChangeFilterMap<String>();
		m_ignoreList = new HashSet<String>();
		m_wmIDs = new HashSet<String>();
		m_permissions = new CASTWMPermissionMap();
		m_xarchLockConnections = new ConcurrentHashMap<String, PermissionsPullConnectorOut>();

		// determines whether this wm should broadcast to other
		// sub-architectures
		setSendXarchChangeNotifications(false);

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see cast.core.components.CASTProcessingComponent#configure(java.util.Properties)
	 */
	@Override
	public void configure(Properties _config) {
		super.configure(_config);

		String ignore = _config.getProperty(IGNORE_SA_KEY.value);
		if (ignore != null) {
			String[] ignoreList = ignore.split(",");
			for (String ignoreMe : ignoreList) {
				if (ignoreMe.length() > 0) {
					ignoreChangesFromSubarchitecture(ignoreMe);
				}
			}
		}

		// System.out.println(_config);
		// build lists of component and wm ids
		buildIDLists(_config);

	}

	private final HashSet<String> m_wmIDs;

	private void buildIDLists(Properties _props) {
		assert (_props != null);
		String wmIDs = _props.getProperty(WM_IDS_KEY.value);
		assert (wmIDs != null);
		String[] ids = wmIDs.split(",");
		for (String id : ids) {
			if (id.length() > 0) {
				m_wmIDs.add(id);
			}
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see balt.core.connectors.pull.primitive.interfaces.BoolPullInterface.BoolPullReceiver#receivePullQueryBool(balt.core.data.FrameworkQuery)
	 */
	public boolean receivePullQueryBool(FrameworkQuery _query) {
		// println("exist query received");

		// assume query is just id!
		String id = _query.getQuery();
		boolean exists = m_workingMemory.contains(id);
		debug("SubarchitectureWorkingMemory.receivePullQueryBool() "
				+ _query.getQuery() + ": " + exists);
		return exists;
	}

	/**
	 * Receive a pull query for a sequence of working memory entries. The input
	 * parameter is parsed, then the resulting query object is acted upon.
	 * 
	 * @param _query
	 *            A framework query object.
	 * @return The requested list of working memory entries.
	 * @see caat.framework.interfaces.WMELPullInterface.WMELPullReceiver#receivePullQueryWME(framework.core.data.FrameworkQuery)
	 */
	public CASTWorkingMemoryEntry<?>[] receivePullQueryCWMEL(
			FrameworkQuery _query) {

		// println("SubarchitectureWorkingMemory.receivePullQueryWME():
		// " + _query);

		// println("is running");

		// query must be in correct format
		try {
			// wait for thread

			WorkingMemoryPullQuery queryObject = parseWorkingMemoryQuery(_query);

			// println("query object: " + queryObject);

			CASTWorkingMemoryEntry<?>[] cwmel = handleWorkingMemoryQuery(queryObject);

			// System.out.println("released: " + wmel.length);

			// if (m_bLogOutput) {
			// for (int i = 0; i < cwmel.length; i++) {
			// CAATWorkingMemoryEntry cwme = cwmel[i];
			// // just keep out spam for time being!
			// if (!cwme.getItem().getType().equals(
			// "Vision:ImageBufferState")) {
			// StringBuffer sb = new StringBuffer();
			//
			// sb.append("GET");
			// sb.append(" ");
			// sb.append(NativeProcessLauncher
			// .toString(ProcessLauncher. ALTTime()));
			// sb.append(" ");
			// sb.append(_query.getSource());
			// sb.append(" ");
			// sb.append(cwme.getItem().getType());
			// sb.append(" ");
			// sb.append(cwme.getAddress().m_id);
			// log(sb.toString());
			// }
			// }
			// }

			return cwmel;

		}
		catch (Throwable t) {
			println(t);
			System.exit(0);
		}

		// println("something gone wrong, empty list");

		// if an exception has been thrown or process is stopped...
		// return empty list
		return new CASTWorkingMemoryEntry[0];

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see balt.core.connectors.pull.primitive.interfaces.IntPullInterface.IntPullReceiver#receivePullQueryInt(balt.core.data.FrameworkQuery)
	 */
	public int receivePullQueryInt(FrameworkQuery _query) {

		// println("count query received");

		// assume query is just id!
		String id = _query.getQuery();

		int updateCount = getOverwriteCount(id);

		return updateCount;
	}

	/**
	 * Receive a pull query for a sequence of working memory entries. The input
	 * parameter is parsed, then the resulting query object is acted upon.
	 * 
	 * @param _query
	 *            A framework query object.
	 * @return The requested list of working memory entries.
	 * @see caat.framework.interfaces.WMELPullInterface.WMELPullReceiver#receivePullQueryWME(framework.core.data.FrameworkQuery)
	 */
	public WorkingMemoryEntry[] receivePullQueryWMEL(FrameworkQuery _query) {

		// println("SubarchitectureWorkingMemory.receivePullQueryWME():
		// " + _query);

		// println("is running");

		// query must be in correct format
		try {

			// println("got it");
			WorkingMemoryPullQuery queryObject = parseWorkingMemoryQuery(_query);

			// println("query object: " + queryObject);

			CASTWorkingMemoryEntry<?>[] cwmel = handleWorkingMemoryQuery(queryObject);

			WorkingMemoryEntry[] wmel = new WorkingMemoryEntry[cwmel.length];
			// System.out.println("query done: " + wmel.length);

			for (int i = 0; i < wmel.length; i++) {
				wmel[i] = new WorkingMemoryEntry(cwmel[i].getOperation(),
						cwmel[i].getAddress(), cwmel[i].getItem().getType(),
						cwmel[i].getItem().getVersion(), cwmel[i].getItem()
								.toAny());

				// System.out.println(wmel[i].m_data.type());
			}

			// System.out.println("released: " + wmel.length);

			// if (m_bLogOutput) {
			// for (int i = 0; i < cwmel.length; i++) {
			// CAATWorkingMemoryEntry cwme = cwmel[i];
			// // just keep out spam for time being!
			// if (!cwme.getItem().getType().equals(
			// "Vision:ImageBufferState")) {
			// StringBuffer sb = new StringBuffer();
			//
			// sb.append("GET");
			// sb.append(" ");
			// sb.append(NativeProcessLauncher
			// .toString(ProcessLauncher.getBALTTime()));
			// sb.append(" ");
			// sb.append(_query.getSource());
			// sb.append(" ");
			// sb.append(cwme.getItem().getType());
			// sb.append(" ");
			// sb.append(cwme.getAddress().m_id);
			// log(sb.toString());
			// }
			// }
			// }

			return wmel;

		}
		catch (Throwable t) {
			println(t);
			System.exit(0);
		}

		// println("something gone wrong, empty list");

		// if an exception has been thrown or process is stopped...
		// return empty list
		return new WorkingMemoryEntry[0];

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see caat.core.interfaces.CWMEPushInterface.CWMEPushReceiver#receivePushData(java.lang.String,
	 *      caat.core.data.CAATWorkingMemoryEntry)
	 */
	@SuppressWarnings("unchecked")
	public void receivePushData(String _src, CASTWorkingMemoryEntry _data) {

		debug(_data);
		debug(CASTUtils.toString(_data.getAddress()));
		try {
			performOperation(_src, _data);
		}
		catch (SubarchitectureProcessException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Used to receive change data from other working memories. Based on various
	 * configuration options this data may be pushed on to connected components.
	 * 
	 * @param _src
	 *            The source component of the change information.
	 * @param _data
	 *            The change data.
	 * @see #isForwardingXarchChangeNotifications()
	 */
	public void receivePushData(String _src, WorkingMemoryChange _data) {

		if (m_bDebugOutput) {
			debug("Receiving xarch change data");
			debug(_data.m_type);
		}

		lockProcess();
		// if the filters require external changes, allow them to be
		// forwarded
		if (!m_componentFilters.localFiltersOnly()) {

			// println("can forward");

			assert (m_wmChangeBroadcast != null);

			// if we're allowed to filter here
			if (m_wmChangeFiltering) {
				if (isAllowedChange(_data)) {
					for (WMCPushConnectorOut out : m_wmChangeBroadcast) {
						// out.push(getProcessIdentifier(), filteredList);
						out.push(getProcessIdentifier(), _data);
					}
				}
			}
			else {
				for (WMCPushConnectorOut out : m_wmChangeBroadcast) {
					out.push(getProcessIdentifier(), _data);

				}
			}
		}
		unlockProcess();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see caat.core.interfaces.WMCFPushInterface.WMCFPushReceiver#receivePushData(java.lang.String,
	 *      caat.corba.autogen.CAAT.WorkingMemoryChangeFilter)
	 */
	public void receivePushData(String _src, WorkingMemoryChangeFilter _data) {

		// this should never happen
		assert (_src != null && _data != null);
		assert (_data.m_filterChange != WorkingMemoryOperation.OVERWRITE);

		// ignore our own filters
		if (!_src.equals(getProcessIdentifier())) {

			debug("SubarchitectureWorkingMemory.receivePushData(): " + _src
					+ CASTUtils.toString(_data));

			lockProcess();

			if (isWorkingMemoryID(_src)) {
				processWorkingMemoryFilter(_src, _data);
			}
			else {
				processComponentFilter(_src, _data);
			}

			unlockProcess();
		}
	}

	private void processWorkingMemoryFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (_data.m_filterChange == WorkingMemoryOperation.ADD) {
			addWMChangeFilter(_src, _data);
		}
		else {
			deleteWMChangeFilter(_src, _data);
		}
	}

	private void processComponentFilter(String _src,
			WorkingMemoryChangeFilter _data) {

		if (_data.m_filterChange == WorkingMemoryOperation.ADD) {
			addComponentChangeFilter(_src, _data);
		}
		else {
			deleteComponentChangeFilter(_src, _data);
		}

		// if we're sharing our filters
		if (m_wmDistributedFiltering) {

			debug("fowarding filter");
			sendFilter(_data);
		}
	}

	private final boolean isWorkingMemoryID(String _src) {
		return m_wmIDs.contains(_src);
	}

	/**
	 * Push the input filter to all other wms.
	 * 
	 * @param _data
	 */
	private final void sendFilter(WorkingMemoryChangeFilter _data) {
		assert (_data != null);
		if (m_xarchWMCFPushConnector != null) {
			// System.out.println("SubarchitectureWorkingMemory.sendFilter()");
			m_xarchWMCFPushConnector.push(getProcessIdentifier(), _data);

			unlockProcess();
			// flushing could lead to deadlocks if we're locked!
			m_xarchWMCFPushConnector.flush();
			lockProcess();
			// System.out.println("SubarchitectureWorkingMemory.sendFilter():
			// DONE");
		}
	}

	/**
	 * Receive data to be added, overwritten or deleted from the working memory.
	 * 
	 * @param _src
	 *            The source component for the data.
	 * @param _data
	 *            The data to be added, overwritten or deleted.
	 * @see #performOperation(String, WorkingMemoryEntry)
	 * @see WorkingMemoryEntry#m_operation
	 * @see caat.framework.interfaces.WMEPushInterface.WMEPushReceiver#receivePushData(java.lang.String,
	 *      caat.corba.autogen.SubArchitecture.WorkingMemoryEntry)
	 */
	public void receivePushData(String _src, WorkingMemoryEntry _data) {
		// println("received: " + _data.m_ontEntry);
		// if (m_status == ProcessStatus.RUN) {

		// no longer use separate thread

		// Runnable moThread = new MemoryOperationThread(this, _src,
		// _data);
		// new Thread(moThread).start();

		// log("receiving remote push");

		CASTWorkingMemoryItem<Any> wmi = new CASTWorkingMemoryItem<Any>(
				_data.m_type, _data.m_version, _data.m_data);

		// use a default version number first
		CASTWorkingMemoryEntry<Any> wme = new CASTWorkingMemoryEntry<Any>(_src,
				_data.m_operation, _data.m_address, wmi);

		try {
			performOperation(_src, wme);
		}
		catch (SubarchitectureProcessException e) {
			e.printStackTrace();
		}
		// }
	}

	/**
	 * Empty run method. Does nothing.
	 * 
	 * @see framework.core.processes.FrameworkProcess#run()
	 */
	@Override
	public void runComponent() {
		// while (m_status == ProcessStatus.RUN) {
		//
		// try {
		// m_semaphore.acquire();
		//
		// println(m_workingMemory.toString());
		//
		// m_semaphore.release();
		// Thread.sleep(10000);
		// }
		// catch (InterruptedException e) {
		// e.printStackTrace();
		// }
		// }

	}

	/**
	 * Set the pull connector used to obtain working memory entries from other
	 * working memories. Connections are only established if _connectionID is
	 * prefixed with ArchitectureConfiguration.XARCH_PREFIX. This method can be
	 * called multiple times (i.e. once for each connected working memory).
	 * 
	 * @param _connectionID
	 *            The ID of the connector.
	 * @param _senderAdaptor
	 *            A connector to use.
	 * @see cast.core.interfaces.WMELPullInterface.WMELPullSender#setPullConnector(java.lang.String,
	 *      cast.core.interfaces.WMELPullInterface.WMELPullConnectorOut)
	 * @see ArchitectureConfiguration#XARCH_PREFIX
	 */
	public void setPullConnector(String _connectionID,
			WMELPullConnectorOut _senderAdaptor) {
		// System.out.println("setPullConnector: "+_connectionID);

		// establish connections across working memories
		if (_connectionID.startsWith(ArchitectureConfiguration.XARCH_PREFIX)) {

			String subarch = subarchitectureFromID(_connectionID
					.substring(ArchitectureConfiguration.XARCH_PREFIX.length() + 1));

			m_xarchWMPullConnections.put(subarch, _senderAdaptor);
		}

	}

	/**
	 * Adds a push connector to use for broadcasting change information. Xarch
	 * connectors must have ids prefixed with
	 * ArchitectureConfiguration.XARCH_PREFIX. Global connectors must have ids
	 * prefixed with ArchitectureConfiguration.GLOBAL_PREFIX. Otherwise the
	 * connector is stored in a single variable, not a collection, for local
	 * change broadcast.
	 * 
	 * @param _connectionID
	 *            The id of the connection object.
	 * @param _out
	 *            The connection object.
	 * @see ArchitectureConfiguration#XARCH_PREFIX
	 * @see ArchitectureConfiguration#GLOBAL_PREFIX
	 * @see caat.framework.interfaces.WMCPushInterface.WMCPushSender#setPushConnector(java.lang.String,
	 *      caat.framework.interfaces.WMCPushInterface.WMCPushConnectorOut)
	 */
	public void setPushConnector(String _connectionID, WMCPushConnectorOut _out) {

		// protect method just in case

		// println("cid: " + _connectionID);
		lockProcess();
		// if it is a connection elsewhere in the architecture
		if (_connectionID.startsWith(ArchitectureConfiguration.XARCH_PREFIX)) {

			// println("cid: " + _connectionID);
			// take off XARCH: prefix and :wmchanges postfix
			// TODO all this substringing is uuugly, fix up a better way in
			// general
			String wmName = _connectionID.substring(
					XARCH_CONNECTION_PREFIX.value.length() + 1, (_connectionID
							.length() - ":wmchanges".length()));
			m_xarchChangeConnections.put(wmName, _out);
		}
		else {
			m_wmChangeBroadcast.add(_out);
		}

		unlockProcess();

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see caat.core.interfaces.WMEPushInterface.WMEPushSender#setPushConnector(java.lang.String,
	 *      caat.core.interfaces.WMEPushInterface.WMEPushConnectorOut)
	 */
	public void setPushConnector(String _connectionID, WMEPushConnectorOut _out) {
		// println("setPushConnector: "+_connectionID);

		// establish connections across working memories
		assert (_connectionID
				.startsWith(ArchitectureConfiguration.XARCH_PREFIX));

		String subarch = subarchitectureFromID(_connectionID
				.substring(ArchitectureConfiguration.XARCH_PREFIX.length() + 1));

		m_xarchWMPushConnections.put(subarch, _out);

	}

	public void setPushConnector(String _connectionID, WMCFPushConnectorOut _out) {
		assert (_connectionID
				.startsWith(ArchitectureConfiguration.XARCH_PREFIX));
		assert m_xarchWMCFPushConnector == null : "xarch filter connector already set";
		m_xarchWMCFPushConnector = _out;
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void addComponentChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.addComponentChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}

		m_componentFilters.put(_data, _src);

		if (m_bDebugOutput) {
			debug("new filters length: " + m_componentFilters.size());
			debug("only local: " + m_componentFilters.localFiltersOnly());
		}
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void addWMChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.addWMChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}

		m_wmFilters.put(_data, _src);

		if (m_bDebugOutput) {
			debug("new filters length: " + m_wmFilters.size());
			debug("only local: " + m_wmFilters.localFiltersOnly());
		}
	}

	// protected void logMemoryChange(WorkingMemoryOperation _op) {
	// synchronized (m_componentStatus) {
	// switch (_op.value()) {
	// case WorkingMemoryOperation._ADD:
	// m_componentStatus.m_changeQueue++;
	// m_componentStatus.m_totalAdds++;
	// break;
	// case WorkingMemoryOperation._OVERWRITE:
	// m_componentStatus.m_totalOverwrites++;
	// break;
	// case WorkingMemoryOperation._DELETE:
	// m_componentStatus.m_changeQueue--;
	// m_componentStatus.m_totalDeletes++;
	// break;
	// default:
	// break;
	// }
	// }
	// }

	private final CASTWMPermissionMap m_permissions;

	private final ConcurrentHashMap<String, PermissionsPullConnectorOut> m_xarchLockConnections;

	/**
	 * Add some data to working memory. If the given id already exists in the
	 * working memory then the data isn't added and false is returned.
	 * 
	 * @param _id
	 *            The id to use for the data.
	 * @param _ontEntry
	 *            The ontological type to use for the data.
	 * @param _data
	 *            The data itself.
	 * @return True if the data is added successfully, else false.
	 */
	protected boolean addToWorkingMemory(String _id,
			CASTWorkingMemoryItem<?> _data) {
		boolean result = m_workingMemory.add(_id, _data);
		if (result) {
			m_permissions.add(_id);
		}
		return result;
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void deleteComponentChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.deleteComponentChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}
		m_componentFilters.remove(_data);
		if (m_bDebugOutput) {
			debug("new filters length: " + m_componentFilters.size());
			debug("only local: " + m_componentFilters.localFiltersOnly());
		}
	}

	/**
	 * @param _src
	 * @param _data
	 */
	protected void deleteWMChangeFilter(String _src,
			WorkingMemoryChangeFilter _data) {
		if (m_bDebugOutput) {
			debug("SubarchitectureWorkingMemory.deleteWMChangeFilter()");
			debug(_src);
			debug(CASTUtils.toString(_data));
		}
		m_wmFilters.remove(_data);
		if (m_bDebugOutput) {
			debug("new filters length: " + m_wmFilters.size());
			debug("only local: " + m_wmFilters.localFiltersOnly());
		}
	}

	/**
	 * Delete the specified entry from working memory. If the given id does not
	 * exist in the working memory then nothing happens and null is returned.
	 * 
	 * @param _id
	 *            The id of the entry to delete.
	 * @return The item that is deleted, or null if nothing is deleted.
	 */
	protected CASTWorkingMemoryItem<?> deleteFromWorkingMemory(String _id,
			String _component) {

		System.out
				.println("SubarchitectureWorkingMemory.deleteFromWorkingMemory()");
		boolean isLocked = false;

		if (m_permissions.isLocked(_id)) {

			WorkingMemoryPermissions permissions = m_permissions
					.getPermissions(_id);

			// if the item is delete locked
			if (!CASTUtils.deleteAllowed(permissions)) {
				// we're going to assume that client checking is up to scratch
				assert (m_permissions.isLockHolder(_id, _component));
			}
			else {
				// could just be an overwrite lock, in which case it doesn't
				// matter who is the lock holder
			}

			isLocked = true;
		}

		CASTWorkingMemoryItem<?> result = m_workingMemory.remove(_id);

		if (isLocked) {
			debug("unlocking on deletion: " + _id);
			m_permissions.unlock(_id, _component);
		}

		try {
			unlockProcess();
			m_permissions.remove(_id);
			lockProcess();
		}
		catch (InterruptedException e) {
			e.printStackTrace();
		}

		System.out
				.println("SubarchitectureWorkingMemory.deleteFromWorkingMemory() DONE");

		return result;
	}

	/**
	 * Method for getting an object from wm locally.
	 * 
	 * @param <T>
	 * @param _id
	 * @param _cls
	 * @return
	 * @throws SubarchitectureProcessException
	 */
	protected <T> T getItem(String _id, Class<T> _cls)
			throws SubarchitectureProcessException {
		T item = null;
		CASTWorkingMemoryItem<?> wmi = m_workingMemory.get(_id);
		if (wmi != null) {
			// if it's a local java object, cast to correct type
			if (wmi.isLocal()) {
				item = _cls.cast(wmi.getData());
			}
			else {
				// if it's not local the the data will be an any
				Any anyObj = (Any) wmi.getData();
				try {
					item = RemoteDataTranslator.translateFromAny(anyObj, _cls);
				}
				catch (FrameworkDataTranslatorException e) {
					throw new SubarchitectureProcessException(
							"translation failure", e);
				}
			}
		}
		return item;
	}

	/**
	 * Method for getting objects from wm locally.
	 * 
	 * @param <T>
	 * @param _type
	 * @param _cls
	 * @return
	 * @throws SubarchitectureProcessException
	 */
	protected <T> ArrayList<T> getItems(String _type, Class<T> _cls)
			throws SubarchitectureProcessException {
		ArrayList<String> ids = m_workingMemory.getIDsByType(_type, 0);
		ArrayList<T> items = new ArrayList<T>(ids.size());

		for (String id : ids) {
			items.add(getItem(id, _cls));
		}

		return items;
	}

	protected <T> ArrayList<T> getItems(WorkingMemoryAddress[] _wmal,
			Class<T> _cls) throws SubarchitectureProcessException {
		ArrayList<T> items = new ArrayList<T>(_wmal.length);

		for (WorkingMemoryAddress wma : _wmal) {
			items.add(getItem(wma.m_id, _cls));
		}

		return items;
	}

	/**
	 * Handle a working memory query intended for this working memory.
	 * 
	 * @param queryObject
	 *            The object representation of the query.
	 * @return The requested working memory entries.
	 * @throws SubarchitectureProcessException
	 *             The exception is thrown if the request object is malformed.
	 */
	protected CASTWorkingMemoryEntry<?>[] handleLocalWorkingMemoryQuery(
			WorkingMemoryPullQuery _queryObject)
			throws SubarchitectureProcessException {

		lockProcess();

		CASTWorkingMemoryEntry<?>[] wmel = null;

		if (_queryObject.getType() == WorkingMemoryQueryType.ID) {

			String query = (String) _queryObject.getQueryObject();

			logReadEvent(_queryObject.getSourceID(),
					_queryObject.getSourceSA(), query);
			CASTWorkingMemoryEntry<?> wme = getEntryByID(query, _queryObject
					.getSourceID());
			if (wme == null) {
				wmel = new CASTWorkingMemoryEntry[0];
			}
			else {
				wmel = new CASTWorkingMemoryEntry[]{wme};
			}
		}
		else if (_queryObject.getType() == WorkingMemoryQueryType.EXISTS) {

			// println("not doing anything for exists");
			String queryID = (String) _queryObject.getQueryObject();
			boolean exists = false;

			if (m_workingMemory.contains(queryID)) {
				// println("exists TRUE: " + queryID);
				exists = true;
			}
			else {
				// println("exists FALSE: " + queryID);
			}

			CASTWorkingMemoryItem<Boolean> pItem = new CASTWorkingMemoryItem<Boolean>(
					"bool", new Boolean(exists));

			wmel = new CASTWorkingMemoryEntry[1];

			WorkingMemoryAddress wma = new WorkingMemoryAddress(queryID,
					m_subarchitectureID);
			wmel[0] = new CASTWorkingMemoryEntry<Boolean>(
					getProcessIdentifier(), WorkingMemoryOperation.GET, wma,
					pItem);

		}
		else if (_queryObject.getType() == WorkingMemoryQueryType.OVERWRITE_COUNT) {

			// println("checking overwrite count");
			String queryID = (String) _queryObject.getQueryObject();

			int updateCount = getOverwriteCount(queryID);

			CASTWorkingMemoryItem<Integer> pItem = new CASTWorkingMemoryItem<Integer>(
					"int", new Integer(updateCount));

			wmel = new CASTWorkingMemoryEntry[1];

			WorkingMemoryAddress wma = new WorkingMemoryAddress(queryID,
					m_subarchitectureID);
			wmel[0] = new CASTWorkingMemoryEntry<Integer>(
					getProcessIdentifier(), WorkingMemoryOperation.GET, wma,
					pItem);

		}
		else if (_queryObject.getType() == WorkingMemoryQueryType.ID_ARRAY) {
			// String[] query = (String[]) _queryObject.getQueryObject();
			//
			// logReadEvent(_queryObject.getSourceID(),
			// _queryObject.getSourceSA(), query.toString());
			//
			// wmel = getEntriesByIDs(query);

			throw new RuntimeException("id array query no longer supported");

		}
		else if (_queryObject.getType() == WorkingMemoryQueryType.TYPE) {
			String query = (String) _queryObject.getQueryObject();

			logReadEvent(_queryObject.getSourceID(),
					_queryObject.getSourceSA(), query, _queryObject.getCount());

			wmel = getEntriesByType(query, _queryObject.getSourceID(),
					_queryObject.getCount());
		}
		else {
			throw new SubarchitectureProcessException(
					"Unknown wm query object: "
							+ _queryObject.getQueryObject().getClass());
		}

		unlockProcess();

		return wmel;
	}

	private void readBlock(String _id, String _component) {

		WorkingMemoryPermissions perms = m_permissions.getPermissions(_id);

		while (m_permissions.isLocked(_id)
				&& !m_permissions.isLockHolder(_id, _component)
				&& !CASTUtils.readAllowed(perms)) {
			debug("blocking read by " + _component + " because " + _id
					+ " is locked by " + m_permissions.getLockHolder(_id));
			// block
			try {

				// unlock before we block to allow other things to
				// happen
				unlockProcess();
				m_permissions.lock(_id, _component,
						WorkingMemoryPermissions.LOCKED_ODR);
				// relock to finish the operation
				lockProcess();

				// then unlock
				m_permissions.unlock(_id, _component);
			}
			catch (InterruptedException e) {
				println(e);
			}

			// now check if entry still exists as it could've been deleted
			// while we block... so we don't even hold a lock
			if (!m_workingMemory.contains(_id)) {
				debug("deletion during readBlock, returning");
				return;
			}

			perms = m_permissions.getPermissions(_id);

		}
	}

	/**
	 * Handle a working memory query generated by an attached component. This
	 * determines whether it is a request for a local or remote working memory,
	 * and calls either handleLocalWorkingMemoryQuery or
	 * handleGlobalWorkingMemoryQuery accordingly.
	 * 
	 * @param queryObject
	 *            An object representing a query.
	 * @return The requested working memory entries.
	 * @throws SubarchitectureProcessException
	 *             Exception occurs if communication fails or if the request is
	 *             malformed.
	 */
	protected CASTWorkingMemoryEntry<?>[] handleWorkingMemoryQuery(
			WorkingMemoryPullQuery queryObject)
			throws SubarchitectureProcessException {

		// System.out.println("comparing: " +
		// queryObject.getSubarchitectureID() + " and " +
		// m_subarchitectureID);

		// if the query is for this subarch, get from wm
		if (queryObject.getSubarchitectureID().equals(m_subarchitectureID)) {
			return handleLocalWorkingMemoryQuery(queryObject);
		}
		// else handle a pull to other wms
		else {
			return handleXarchWorkingMemoryQuery(queryObject);
		}

	}

	/**
	 * Handle a working memory query intended for another working memory. This
	 * method forwards the query on to that working memory if it is connected to
	 * it.
	 * 
	 * @param queryObject
	 *            The object representation of the query.
	 * @return The requested working memory entries.
	 * @throws SubarchitectureProcessException
	 *             The exception is thrown if the request object specifies an
	 *             unknown subarchitecture, or if a comms error occurs.
	 */
	protected CASTWorkingMemoryEntry<?>[] handleXarchWorkingMemoryQuery(
			WorkingMemoryPullQuery queryObject)
			throws SubarchitectureProcessException {

		// TODO -- remove extra copy operations that this introduces

		if (m_xarchWMPullConnections.containsKey(queryObject
				.getSubarchitectureID())) {

			String query = SubarchitectureWorkingMemoryProtocol
					.createQuery(queryObject);

			WMELPullConnectorOut out = m_xarchWMPullConnections.get(queryObject
					.getSubarchitectureID());

			WorkingMemoryEntry[] wmel;
			try {
				wmel = out.pull(new FrameworkQuery(getProcessIdentifier(),
						query));
			}
			catch (FrameworkConnectionException e) {
				throw new SubarchitectureProcessException(
						"Pull failiure to different subarch", e);
			}

			CASTWorkingMemoryEntry<?>[] cwmel = new CASTWorkingMemoryEntry<?>[wmel.length];
			WorkingMemoryEntry wme;

			for (int i = 0; i < cwmel.length; i++) {
				wme = wmel[i];

				cwmel[i] = new CASTWorkingMemoryEntry<Any>(
						getProcessIdentifier(), wme.m_operation, wme.m_address,
						new CASTWorkingMemoryItem<Any>(wme.m_type,
								wme.m_version, wme.m_data));

				// System.out.println("converting local?: " +
				// cwmel[i].getItem().isLocal() );

			}
			return cwmel;

		}
		else {
			throw new SubarchitectureProcessException(
					"Unknown subarchitecture for query: "
							+ queryObject.getSubarchitectureID());
		}
	}

	/**
	 * Determines whether the wm is allowed to forward this change to the
	 * attached reader processes.
	 * 
	 * @param _change
	 * @return true if the change is not from an ignored sa and passes all the
	 *         filters
	 */
	protected boolean isAllowedChange(WorkingMemoryChange _change) {
		return (!m_ignoreList.contains(_change.m_address.m_subarchitecture))
				&& m_componentFilters.allowsChange(_change);
	}

	/**
	 * Determines whether to forward change notifications to other
	 * subarchitecture working memories (i.e. its peers).
	 * 
	 * @return Returns the sendXarchChangeNotifications.
	 */
	protected boolean isSendingXarchChangeNotifications() {
		return m_sendXarchChangeNotifications;
	}

	/**
	 * Overwrite some data to working memory. If the given id does not exist in
	 * the working memory then the data isn't written and false is returned.
	 * 
	 * @param _id
	 *            The id to use for the data.
	 * @param _ontEntry
	 *            The ontological type to use for the data.
	 * @param _data
	 *            The data itself.
	 * @return True if the data is overwritten successfully, else false.
	 */
	protected boolean overwriteWorkingMemory(String _id,
			CASTWorkingMemoryItem<?> _data, String _component) {

		// sanity check locking elsewhere
		if (m_permissions.isLocked(_id)) {
			WorkingMemoryPermissions permissions = m_permissions
					.getPermissions(_id);

			// if the item is delete locked
			if (!CASTUtils.overwriteAllowed(permissions)) {
				// we're going to assume that client checking is up to scratch
				assert (m_permissions.isLockHolder(_id, _component));
			}
			else {
				// this is never going to happen as all locks are overwrite
				// locks
			}
		}

		boolean result = m_workingMemory.overwrite(_id, _data);

		// if (result) {
		// logMemoryChange(WorkingMemoryOperation.OVERWRITE);
		// }

		return result;

	}

	/**
	 * Convert a pull query string into a query object.
	 * 
	 * @param _query
	 *            The query received via a pull.
	 * @return The query object built from the input
	 * @throws SubarchitectureProcessException
	 *             Exception thrown if the input query is malformed.
	 * @see SubarchitectureWorkingMemoryProtocol#parseQuery(String)
	 */
	protected WorkingMemoryPullQuery parseWorkingMemoryQuery(
			FrameworkQuery _query) throws SubarchitectureProcessException {
		WorkingMemoryPullQuery queryObject = SubarchitectureWorkingMemoryProtocol
				.parseQuery(_query.getQuery());
		return queryObject;
	}

	/**
	 * Print memory contents using component println method.
	 * 
	 * @see #println(Object)
	 */
	protected void printMemoryContents() {
		println(m_workingMemory.toString());
	}

	/**
	 * Determines whether to forward change notifications to other
	 * subarchitecture working memories (i.e. its peers).
	 * 
	 * @param sendXarchChangeNotifications
	 *            The sendXarchChangeNotifications to set.
	 */
	protected void setSendXarchChangeNotifications(
			boolean sendXarchChangeNotifications) {
		m_sendXarchChangeNotifications = sendXarchChangeNotifications;
	}

	/**
	 * Get an array of working memory entries from the stored working memory. If
	 * an id is missing then there is nothing returned for that id.
	 * 
	 * @param _query
	 *            The entry ids.
	 * @return An array of entries that match the given ids.
	 */
	private CASTWorkingMemoryEntry<?>[] getEntriesByIDs(String[] _query,
			String _component) {
		ArrayList<CASTWorkingMemoryEntry<?>> entries = new ArrayList<CASTWorkingMemoryEntry<?>>(
				_query.length);
		CASTWorkingMemoryEntry<?> wme;
		for (int i = 0; i < _query.length; i++) {
			wme = getEntryByID(_query[i], _component);
			if (wme != null) {
				entries.add(wme);
			}
		}
		CASTWorkingMemoryEntry<?>[] wmel = new CASTWorkingMemoryEntry[entries
				.size()];
		entries.toArray(wmel);
		return wmel;
	}

	/**
	 * Get an array of working memory entries that have a given ontological
	 * type.
	 * 
	 * @param _query
	 *            The ontological type to get.
	 * @param _count
	 *            The number of entries to return.
	 * @return An array of entries that match the given ontological type.
	 */
	private CASTWorkingMemoryEntry<?>[] getEntriesByType(String _query,
			String _component, int _count) {

		ArrayList<String> ids = m_workingMemory.getIDsByType(_query, _count);
		CASTWorkingMemoryEntry<?>[] wmel = new CASTWorkingMemoryEntry[ids
				.size()];
		for (int i = 0; i < ids.size(); i++) {
			wmel[i] = getEntryByID(ids.get(i), _component);
		}
		return wmel;

	}

	// /**
	// * Sets the ontology for this component. Also sets the ontology of
	// * the wm storage object.
	// *
	// * @param _ontology
	// * The ontology to use.
	// * @see CAATWorkingMemoryInterface#setOntology(CAATOntology)
	// */
	// @Override
	// public void setOntology(CAATOntology _ontology) {
	// super.setOntology(_ontology);
	// m_workingMemory.setOntology(_ontology);
	// }

	/**
	 * Get a single entry by its ID.
	 * 
	 * @param _id
	 *            The ID of the entry to get.
	 * @return The required entry, or null if the ID does not exist.
	 */
	@SuppressWarnings("unchecked")
	private CASTWorkingMemoryEntry<?> getEntryByID(String _id, String _component) {

		// System.out
		// .println("SubarchitectureWorkingMemory.getEntryByID(): "
		// + _query);

		if (m_workingMemory.contains(_id)) {
			// block if necessary
			readBlock(_id, _component);
			CASTWorkingMemoryItem<?> item = m_workingMemory.get(_id);
			return new CASTWorkingMemoryEntry(getProcessIdentifier(),
					WorkingMemoryOperation.GET, new WorkingMemoryAddress(_id,
							m_subarchitectureID), item);
		}
		else {
			return null;
		}
	}

	private int getOverwriteCount(String _id) {
		int updateCount = -1;
		// sanity check first
		if (m_workingMemory.hasContained(_id)) {
			updateCount = m_workingMemory.getOverwriteCount(_id);
		}
		return updateCount;
	}

	/**
	 * @param _id
	 * @param _type
	 */
	private void logMemoryAdd(String _srcID, String _srcSA, String _id,
			String _type) {
		logEvent(ComponentEventType.ADD, _srcID, _srcSA, _type, _id);
	}

	/**
	 * @param _id
	 * @param _type
	 */
	private void logMemoryDelete(String _srcID, String _srcSA, String _id,
			String _type) {
		logEvent(ComponentEventType.DELETE, _srcID, _type, "", _id);
	}

	/**
	 * @param _id
	 * @param _type
	 */
	private void logMemoryOverwrite(String _srcID, String _srcSA, String _id,
			String _type) {
		logEvent(ComponentEventType.OVERWRITE, _srcID, _srcSA, _type, _id);
	}

	/**
	 * @param _id
	 * @param _type
	 */
	private void logMemorySize(int _currentSize) {
		synchronized (m_componentStatus) {
			m_componentStatus.m_totalChangeEventsFiltered = Math.max(
					m_componentStatus.m_changeQueue, _currentSize);
			m_componentStatus.m_changeQueue = _currentSize;
		}
	}

	private void logReadEvent(String _srcID, String _srcSA, String _id) {
		logEvent(ComponentEventType.GET, _srcID, _srcSA, "", _id);
	}

	private void logReadEvent(String _srcID, String _srcSA, String _type,
			int _count) {
		logEvent(ComponentEventType.GET, _srcID, _srcSA, _type, "");
	}

	/**
	 * @param _src
	 * @param _data
	 */
	private void performLocalOperation(String _src,
			CASTWorkingMemoryEntry<?> _data) {

		// println("queue length: " + m_semaphore.getQueueLength());
		// only lock on local access
		lockProcess();

		boolean result = false;
		String changeType = null;

		if (_data.getOperation() == WorkingMemoryOperation.ADD) {
			// debug("performOperation: ADD");

			logMemoryAdd(_src, m_subarchitectureID, _data.getAddress().m_id,
					_data.getItem().getType());

			// update memory with new facts
			result = addToWorkingMemory(_data.getAddress().m_id, _data
					.getItem());
			changeType = _data.getItem().getType();
		}
		else if (_data.getOperation() == WorkingMemoryOperation.OVERWRITE) {

			// debug("performOperation: OVERWRITE");

			logMemoryOverwrite(_src, m_subarchitectureID,
					_data.getAddress().m_id, _data.getItem().getType());

			// update memory with new facts
			result = overwriteWorkingMemory(_data.getAddress().m_id, _data
					.getItem(), _src);
			changeType = _data.getItem().getType();
		}
		else if (_data.getOperation() == WorkingMemoryOperation.DELETE) {

			debug("performOperation: DELETE");

			// update memory with new facts
			CASTWorkingMemoryItem<?> item = deleteFromWorkingMemory(_data
					.getAddress().m_id, _src);
			if (item == null) {
				result = false;
			}
			else {
				// set type of deleted item
				changeType = item.getType();
				result = true;
			}

			// println("deleted?: " + result);
			logMemoryDelete(_src, m_subarchitectureID, _data.getAddress().m_id,
					changeType);
		}

		// debug("performOperation: result = " + result);

		logMemorySize(m_workingMemory.size());


		if (result) {
			// signal that the working memory has changed
			signalChange(_data.getOperation(), _src, _data.getAddress().m_id,
					changeType);
		}
		unlockProcess();

	}

	/**
	 * Perform a working memory operation as described by _data.
	 * 
	 * @param _src
	 *            The component requesting the operation.
	 * @param _data
	 *            The data describing the operation.
	 * @throws SubarchitectureProcessException
	 */
	private void performOperation(String _src, CASTWorkingMemoryEntry<?> _data)
			throws SubarchitectureProcessException {

		debug("SubarchitectureWorkingMemory.performOperation()");
		debug(CASTUtils.toString(_data.getAddress()));

		// if it's for this subarchitecture
		if (_data.getAddress().m_subarchitecture.equals(m_subarchitectureID)) {
			performLocalOperation(_src, _data);
		}
		else {
			debug("performing global push for: "
					+ _data.getAddress().m_subarchitecture);
			performXarchOperation(_src, _data);
		}

	}

	/**
	 * @param _src
	 * @param _data
	 * @throws SubarchitectureProcessException
	 */
	private void performXarchOperation(String _src,
			CASTWorkingMemoryEntry<?> _data)
			throws SubarchitectureProcessException {

		String subarchitectureID = _data.getAddress().m_subarchitecture;

		if (m_xarchWMPushConnections.containsKey(subarchitectureID)) {
			WMEPushConnectorOut out = m_xarchWMPushConnections
					.get(subarchitectureID);

			WorkingMemoryEntry wme;
			try {
				if (_data.getOperation() != WorkingMemoryOperation.DELETE) {
					wme = new WorkingMemoryEntry(_data.getOperation(), _data
							.getAddress(), _data.getItem().getType(), _data
							.getItem().getVersion(), _data.getItem().toAny());
				}
				else {
					// if it's a delete operation, no type and empty any
					wme = new WorkingMemoryEntry(_data.getOperation(), _data
							.getAddress(), "", 0, ORB.init().create_any());
				}

				out.push(_src, wme);
				// and flush, just in case previous calls were sync
				out.flush();

			}
			catch (FrameworkDataTranslatorException e) {
				e.printStackTrace();
			}

		}
		else {
			throw new SubarchitectureProcessException(
					"Unknown subarchitecture for operation: "
							+ subarchitectureID + ". Send by: "
							+ _data.getSrc());
		}

	}

	/**
	 * Signal that an operation has occurred to all connected components.
	 * 
	 * @param _op
	 *            The operation type to signal.
	 * @param _src
	 *            The component that caused the operation.
	 * @param _id
	 *            The id of the entry that was the subject of the operation.
	 * @param _type
	 *            The ontological type of the entry that was the subject of the
	 *            operation.
	 */
	private void signalChange(WorkingMemoryOperation _op, String _src,
			String _id, String _type) {

		WorkingMemoryChange wmc = new WorkingMemoryChange(_op, _src,
				new WorkingMemoryAddress(_id, m_subarchitectureID), _type);

		// signal change locally
		if (m_wmChangeBroadcast != null) {
			debug("local change broadcast!!!");
			// if (isAllowedChange(wmc)) {
			for (WMCPushConnectorOut out : m_wmChangeBroadcast) {
				out.push(getProcessIdentifier().toString(), wmc);
			}
			// }
		}

		debug("is forwarding: " + isSendingXarchChangeNotifications());

		// signal change across sub-architectures
		if (isSendingXarchChangeNotifications()) {

			// for (int l = 0; l < wmcl.length; l++) {
			// log(wmcl[l].m_type);
			// }
			for (String wmID : m_xarchChangeConnections.keySet()) {

				if (isAllowedChange(wmID, wmc)) {
					WMCPushConnectorOut out = m_xarchChangeConnections
							.get(wmID);
					// println("xarch change broadcast!!!");
					out.push(getProcessIdentifier().toString(), wmc);
				}
			}

			debug("done forwarding");
		}

		// m_signalTimer.stopInterval();
		// if (m_signalTimer.getCount() % 500 == 0) {
		// println(m_signalTimer.averageIntervalDuration());
		// }

	}

	/**
	 * Determine whether the given change should be sent to the given subarch
	 * wm.
	 * 
	 * @param _wmID
	 * @param _wmc
	 * @return
	 */
	protected boolean isAllowedChange(String _wmID, WorkingMemoryChange _wmc) {
		Queue<String> receivers = new LinkedList<String>();
		// get all receivers for this change
		m_wmFilters.get(_wmc, receivers);
		// if the given id is a recevier, then go ahead
		return receivers.contains(_wmID);
	}

	/**
	 * Add a subarchitecture which should be ignored for changes
	 * 
	 * @param _subarch
	 */
	void ignoreChangesFromSubarchitecture(String _subarch) {

		log("ignoring changes from: " + _subarch);
		m_ignoreList.add(_subarch);
	}

	/**
	 * Create an ID for a working memory component given a subarchitecture name.
	 * 
	 * @param _subarch
	 *            The name of the subarchitecture which contains the working
	 *            memory component.
	 * @return The new id for the component.
	 */
	public static String createID(String _subarch) {
		return _subarch + ":wm";
	}

	/**
	 * Extract a subarchitecture name from an ID for a working memory component.
	 * Assumes that the id was created with the createID method.
	 * 
	 * @param _id
	 *            The id of the working memory component.
	 * @return The name of subarchitecture which contains it.
	 * @see #createID(String)
	 */
	public static String subarchitectureFromID(String _id) {
		return _id.substring(0, _id.indexOf(':'));
	}

	public WorkingMemoryPermissions receivePullQueryPermissions(
			FrameworkQuery _query) {

		String[] tokens = _query.getQuery().split("\\\\");
		assert (tokens.length == 3);
		String subarch = tokens[1];

		try {
			if (subarch.equals(m_subarchitectureID)) {
				lockProcess();
				String id = tokens[0];
				WorkingMemoryLockRequest request = WorkingMemoryLockRequest
						.from_int(Integer.parseInt(tokens[2]));
				WorkingMemoryPermissions perms = handleLocalPermissionsQuery(
						id, request, _query.getSource().toString());
				unlockProcess();
				return perms;
			}
			else {
				PermissionsPullConnectorOut lockConnector = m_xarchLockConnections
						.get(subarch);
				assert (lockConnector != null);
				debug("forwarding permissions pull across subarch: " + _query);
				return lockConnector.pull(_query);
			}
		}
		catch (Exception e) {
			println(e);
			System.exit(1);
		}

		// will never happen
		throw new RuntimeException("Error handling permission query");

	}

	private WorkingMemoryPermissions handleLocalPermissionsQuery(String _id,
			WorkingMemoryLockRequest _request, String _component)
			throws SubarchitectureProcessException {

		try {

			debug("handleLocalPermissionsQuery: "
					+ CASTUtils.toString(_request));

			// sanity check up front
			if (!m_permissions.contains(_id)) {
				return WorkingMemoryPermissions.DOES_NOT_EXIST;
			}

			// if it's a lock
			if (_request.value() < 3) {
				WorkingMemoryPermissions permissions = CASTUtils
						.toPermissions(_request);
				unlockProcess();
				m_permissions.lock(_id, _component, permissions);
				lockProcess();

				// now check that it still exists, because it could've been
				// deleted before the lock was released
				if (!m_workingMemory.contains(_id)) {
					debug("entry " + _id + " deleted while " + _component
							+ "  waiting for lock");
					m_permissions.unlock(_id, _component);
					permissions = WorkingMemoryPermissions.DOES_NOT_EXIST;
				}
				else {
					assert (m_permissions.isLockHolder(_id, _component));
					assert (m_permissions.getPermissions(_id) == permissions);
					debug(_component + " locked: ok");
				}
				return permissions;
			}
			// it's a try-lock
			else if (_request.value() < 6) {
				WorkingMemoryPermissions permissions = CASTUtils
						.toPermissions(_request);
				if (m_permissions.tryLock(_id, _component, permissions)) {
					debug("locked: " + _id);
					return permissions;
				}
				else {
					return WorkingMemoryPermissions.ALREADY_LOCKED;
				}
				// it's a status request
			}
			else if (_request == WorkingMemoryLockRequest.REQUEST_STATUS) {
				return m_permissions.getPermissions(_id);
			}
			// it's an unlock
			else if (_request == WorkingMemoryLockRequest.REQUEST_UNLOCK) {
				m_permissions.unlock(_id, _component);
				return WorkingMemoryPermissions.UNLOCKED;
			}

		}
		catch (InterruptedException e) {
			throw new SubarchitectureProcessException(
					"Error handling permission request", e);
		}

		throw new SubarchitectureProcessException("Invalid permission request");

	}

	public void setPullConnector(String _connectionID,
			PermissionsPullConnectorOut _senderAdaptor) {
		// establish connections across working memories
		if (_connectionID.startsWith(ArchitectureConfiguration.XARCH_PREFIX)) {

			String subarch = subarchitectureFromID(_connectionID
					.substring(ArchitectureConfiguration.XARCH_PREFIX.length() + 1));

			m_xarchLockConnections.put(subarch, _senderAdaptor);
		}
	}

}