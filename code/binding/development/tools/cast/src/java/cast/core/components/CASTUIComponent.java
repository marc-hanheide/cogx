/*
 * CAST - The CoSy Architecture Schema Toolkit
 *
 * Copyright (C) 2006-2007 Nick Hawes
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

/**
 * 
 */
package cast.core.components;

import java.util.Properties;

import balt.core.data.FrameworkQuery;
import cast.cdl.DEBUG_EVENTS_KEY;
import cast.cdl.SUBARCH_ID_KEY;
import cast.cdl.ui.*;
import cast.ui.UIUtils;
import cast.ui.architecture.interfaces.ArchUIComponent;
import cast.ui.architecture.interfaces.TextOutputPushInterface.TextOutputPushConnectorOut;

/**
 * Class that defines the interactions between a component and the architecture
 * UI.
 * 
 * @author nah
 */
public abstract class CASTUIComponent extends CASTComponent implements
		ArchUIComponent {

	// private ComponentEventPushConnectorOut
	// m_componentEventPushConnector;

	private TextOutputPushConnectorOut m_textOutputConnector;

	protected ComponentStatus m_componentStatus;

	/**
	 * Controls whether the events generated by this component are logged as
	 * text.
	 */
	private boolean m_bDebugEvents;

	/**
	 * @param _id
	 */
	public CASTUIComponent(String _id) {
		super(_id);
		m_textOutputConnector = null;
		m_componentStatus = UIUtils.newComponentStatus();
		m_componentStatus.m_component = _id;
		m_bDebugEvents = false;
		UIUtils.init();
	}

	private final boolean hasUIConnection() {
		return m_textOutputConnector != null;
	}

	private final void textToUI(String _s, OutputType _type) {
		synchronized (m_textOutputConnector) {
			m_textOutputConnector.push(getProcessIdentifier().toString(),
					new TextOutput(_type, _s));
		}
	}

    @Override
    public void debug(Object _o) {

		if (hasUIConnection()) {
			textToUI(_o.toString(), OutputType.DEBUG);
		} else {
			super.debug(_o);
		}
	}

    @Override
    public void log(Object _o) {

		if (hasUIConnection()) {
			textToUI(_o.toString(), OutputType.LOG);
		} else {
			super.log(_o);
		}
	}

	protected void println(Throwable e) {
		String msg = e.getLocalizedMessage();
		if (msg != null) {
			println(msg);
		}
		else {
			println("Thrown: " + e.getClass());
		}
		
		StackTraceElement[] trace = e.getStackTrace();
		for (int i = 0; i < trace.length; i++) {
			println("\tat " + trace[i]);
		}

		Throwable cause = e.getCause();
		if (cause != null) {
			println("***** CAUSED BY *****");
			println(cause);
		}

	}

	@Override
	protected void println(Object _o) {

		if (hasUIConnection()) {
			textToUI(_o.toString(), OutputType.PRINT);
		} else {
			super.println(_o);
		}
	}

	@Override
	public void configure(Properties _config) {
		super.configure(_config);

		if (_config.containsKey(DEBUG_EVENTS_KEY.value)) {
			m_bDebugEvents = true;
		}

		// println("CAATComponent.configure(): " + _config);
		m_componentStatus.m_subarchitecture = _config
				.getProperty(SUBARCH_ID_KEY.value);

		if (m_componentStatus.m_subarchitecture == null) {
			m_componentStatus.m_subarchitecture = "no subarchitecture";
		}

		m_componentStatus.m_log = m_bLogOutput;
		m_componentStatus.m_debug = m_bDebugOutput;
	}

	public ComponentStatus receivePullQueryComponentStatus(FrameworkQuery _query) {
		synchronized (m_componentStatus) {
			m_componentStatus.m_locked = (m_semaphore.availablePermits() == 0);
			m_componentStatus.m_sleeping = this.m_asleep;
			return m_componentStatus;
		}
	}

	// public void setPushConnector(String _connectionID,
	// ComponentEventPushConnectorOut _out) {
	// m_componentEventPushConnector = _out;
	//
	// }

	public void setPushConnector(String _connectionID,
			TextOutputPushConnectorOut _out) {
		m_textOutputConnector = _out;
	}

	protected String toString(ComponentEventType _event) {
		switch (_event.value()) {
		case ComponentEventType._GET:
			return "GET";
		case ComponentEventType._ADD:
			return "ADD";
		case ComponentEventType._OVERWRITE:
			return "OVERWRITE";
		case ComponentEventType._DELETE:
			return "DELETE";
		case ComponentEventType._START:
			return "START";
		case ComponentEventType._END:
			return "END";
		case ComponentEventType._PROPOSED:
			return "PROPOSED";
		}
		return "unknown event type";

	}

	private void updateStatus(ComponentEventType _event) {
		switch (_event.value()) {
		case ComponentEventType._ADD:
			m_componentStatus.m_totalAdds++;
			break;
		case ComponentEventType._OVERWRITE:
			m_componentStatus.m_totalOverwrites++;
			break;
		case ComponentEventType._DELETE:
			m_componentStatus.m_totalDeletes++;
			break;
		case ComponentEventType._GET:
			m_componentStatus.m_totalReads++;
			break;
		case ComponentEventType._PROPOSED:
			m_componentStatus.m_totalProposals++;
			break;
		case ComponentEventType._START:
			m_componentStatus.m_totalStarts++;
			break;
		case ComponentEventType._END:
			m_componentStatus.m_totalEnds++;
			break;
		default:
			break;
		}
	}

	protected void logEvent(ComponentEventType _event, String _componentID,
			String _target, String _dataType, String _dataID) {

		// increase count for particular event
		updateStatus(_event);

		if (m_bDebugEvents || m_bDebugOutput) {
			// send this to debug output
			StringBuffer sb = new StringBuffer();
			sb.append(toString(_event));
			sb.append(" compID: ");
			sb.append(_componentID);
			sb.append(" target: ");
			sb.append(_target);
			sb.append(" datatype: ");
			sb.append(_dataType);
			sb.append(" dataID: ");
			sb.append(_dataID);
			debug(sb.toString());
		}
	}

}
