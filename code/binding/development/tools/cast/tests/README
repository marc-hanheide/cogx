Testing CAST Instantiations
---------------------------

The CAST testing process is based around the simple idea of a test
being a single run of a specified cast file. The system described by
the file should contain at least one dedicated test component that
exits the system on the completion of the test, returning a known
integer value indicating that the test has been passed or
failed. Tests are run by the CASTTestHarness application which
configures and starts the process, inspects the exit status, and
reports the result to the tester.

The input to the CASTTestHarness application is a xml (sorry, it was
quick and easy!) file containing a list of tests. The format of the
file can be seen in tools/cast/tests/cast.xml. A test looks like:

<test>
    <!-- name of the test -->
    <name>single write java</name>

    <!-- cast file to run -->
    <file>tools/cast/config/single-write-java.cast</file>

    <!-- description of the test -->
    <description>Tests a single component writing to working memory then
      re-reading the written struct. All in Java.</description>

    <!-- optional, time to run test before failing. default is 60000,
    0 = no timeout--> 
    <timeout>20000</timeout>

    <!-- optional, whether to print output from cast test. default is
	 false = no output -->
    <output>false</output> 

    <!-- optional, the exit value to treat as a pass. default is
	 CASTTest.TEST_PASS ... use with caution-->
    <!--    <pass>0</pass>  -->
</test>

To run the example CAST tests you can do the following...

java -ea -classpath output/classes/ cast.testing.CASTTestHarness -h
localhost -f tools/cast/tests/cast.xml

(remember to set up your environment for normal CAST operation
(e.g. library path), otherwise the tests will all fail)

... and you will hopefully get a result like...

test file: tools/cast/tests/cast.xml
single write java: passed
single write c++: passed
read write java: passed
read write c++: passed
result: 4/4, 0 not runnable

(NB: there are probably still a few problems with the underlying
tests, so this may not be recreated perfectly on your machine!)


To write a test, all you need to do is to make sure your cast file
terminates with an exit call (System.exit(val) in Java or ::exit(val)
in C++) and provide cast::cdl::testing::CAST_TEST_PASS or
cast::cdl::testing::CAST_TEST_FAIL as the exit value. 

Tests can be created in this way using your own code, or you can use
some existing templates to create tests.


Using The Test Classes 
---------------------- 

To support the creation and reuse of test code, I've just added
AbstractTester and AbstractTest classes to both C++ and
Java. AbstractTester is a component that can run tests, where these
tests are defined as AbstractTest objects. The basic idea is that an
AbstractTest object defines a unit of functionality that can be
tested, and the AbstractTester allows one or more of these units to be
tested without creating a component specifically for that purpose.

AbstractTester is a PrivilegedManagedProcess so it can read and write
anywhere in the system. In Java the AbstractTest class is created as a
nested class within AbstractTester, so it therefore has access to all
of AbstractTester's CAST methods. In C++ this is not so easy (or
possible at all really), so the AbstractTest currently makes certain
methods for AbstractTester visible via implementation and friendship
(which is all a bit ugly... suggestions appreciated). You can look at
the code for examples, including the BasicTester class which provides
the simple CAST tests run in the harness test above.

To use the AbstractTester do the following. First subclass it to
create your own class. Then create a number of AbstractTest subclasses
within that class. The important aspect of an AbstractTest is that it
calls testComplete(bool _passed) when the test has either been passed
(_passed = true) or failed (_passed = false). This informs the
AbstractTester that the test is over and the result of the
test. Instances of AbstractTest subclasses are registered the
AbstractTester using the registerTest method. This associates a test
object with a unique string. To run the tests via a cast file (i.e. to
be used as input to the test harness) include your AbstractTester
subclass in the CAST file (along with WMs, TMs and other components as
required), and specify the tests to be run via the --test config
option. E.g.

CPP GD test1 BasicTester  --test single-write,copy --log

... will run two test, one after the other. 

When all the tests are complete AbstractTester exits the system,
returning CAST_TEST_PASS if all the AbstractTests were passed,
otherwise CAST_TEST_FAIL.

This functionality is still somewhat experimental, so please use and
send me feedback, feature requests and bug reports via bugzilla.

I'm now going to continue developing test for basic CAST functionality
using these methods.
