// This file is generated by omniidl (C++ backend) - omniORB_4_1. Do not edit.

#include "FrameworkBasics.hh"

OMNI_USING_NAMESPACE(omni)

static const char* _0RL_dyn_library_version = omniORB_4_1_dyn;

static ::CORBA::TypeCode::_Tracker _0RL_tcTrack(__FILE__);

static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mFrameworkProcessID = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/FrameworkProcessID:1.0", "FrameworkProcessID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_FrameworkProcessID = _0RL_tc_FrameworkBasics_mFrameworkProcessID;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_FrameworkProcessID = _0RL_tc_FrameworkBasics_mFrameworkProcessID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mFrameworkConnectionID = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/FrameworkConnectionID:1.0", "FrameworkConnectionID", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_FrameworkConnectionID = _0RL_tc_FrameworkBasics_mFrameworkConnectionID;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_FrameworkConnectionID = _0RL_tc_FrameworkBasics_mFrameworkConnectionID;
#endif

static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mFrameworkConnectionDataType = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/FrameworkConnectionDataType:1.0", "FrameworkConnectionDataType", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_FrameworkConnectionDataType = _0RL_tc_FrameworkBasics_mFrameworkConnectionDataType;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_FrameworkConnectionDataType = _0RL_tc_FrameworkBasics_mFrameworkConnectionDataType;
#endif

static const char* _0RL_enumMember_FrameworkBasics_mFrameworkConnectionType[] = { "PUSH_CONNECTION", "PULL_CONNECTION" };
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mFrameworkConnectionType = CORBA::TypeCode::PR_enum_tc("IDL:FrameworkBasics/FrameworkConnectionType:1.0", "FrameworkConnectionType", _0RL_enumMember_FrameworkBasics_mFrameworkConnectionType, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_FrameworkConnectionType = _0RL_tc_FrameworkBasics_mFrameworkConnectionType;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_FrameworkConnectionType = _0RL_tc_FrameworkBasics_mFrameworkConnectionType;
#endif

static const char* _0RL_enumMember_FrameworkBasics_mProcessLanguage[] = { "CPP_PROCESS", "JAVA_PROCESS" };
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mProcessLanguage = CORBA::TypeCode::PR_enum_tc("IDL:FrameworkBasics/ProcessLanguage:1.0", "ProcessLanguage", _0RL_enumMember_FrameworkBasics_mProcessLanguage, 2, &_0RL_tcTrack);
#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_ProcessLanguage = _0RL_tc_FrameworkBasics_mProcessLanguage;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_ProcessLanguage = _0RL_tc_FrameworkBasics_mProcessLanguage;
#endif

static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mStringSeq = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/StringSeq:1.0", "StringSeq", CORBA::TypeCode::PR_sequence_tc(0, CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack), &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_StringSeq = _0RL_tc_FrameworkBasics_mStringSeq;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_StringSeq = _0RL_tc_FrameworkBasics_mStringSeq;
#endif

static CORBA::PR_structMember _0RL_structmember_FrameworkBasics_mProcessConfigurationMap[] = {
  {"m_keys", _0RL_tc_FrameworkBasics_mStringSeq},
  {"m_values", _0RL_tc_FrameworkBasics_mStringSeq}
};

#ifdef _0RL_tc_FrameworkBasics_mProcessConfigurationMap
#  undef _0RL_tc_FrameworkBasics_mProcessConfigurationMap
#endif
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mProcessConfigurationMap = CORBA::TypeCode::PR_struct_tc("IDL:FrameworkBasics/ProcessConfigurationMap:1.0", "ProcessConfigurationMap", _0RL_structmember_FrameworkBasics_mProcessConfigurationMap, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_ProcessConfigurationMap = _0RL_tc_FrameworkBasics_mProcessConfigurationMap;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_ProcessConfigurationMap = _0RL_tc_FrameworkBasics_mProcessConfigurationMap;
#endif



static CORBA::PR_structMember _0RL_structmember_FrameworkBasics_mProcessDescription[] = {
  {"m_processName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_className", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_language", _0RL_tc_FrameworkBasics_mProcessLanguage},
  {"m_hostName", CORBA::TypeCode::PR_string_tc(0, &_0RL_tcTrack)},
  {"m_configuration", _0RL_tc_FrameworkBasics_mProcessConfigurationMap}
};

#ifdef _0RL_tc_FrameworkBasics_mProcessDescription
#  undef _0RL_tc_FrameworkBasics_mProcessDescription
#endif
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mProcessDescription = CORBA::TypeCode::PR_struct_tc("IDL:FrameworkBasics/ProcessDescription:1.0", "ProcessDescription", _0RL_structmember_FrameworkBasics_mProcessDescription, 5, &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_ProcessDescription = _0RL_tc_FrameworkBasics_mProcessDescription;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_ProcessDescription = _0RL_tc_FrameworkBasics_mProcessDescription;
#endif










static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mDescriptionList = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/DescriptionList:1.0", "DescriptionList", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_FrameworkBasics_mProcessDescription, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_DescriptionList = _0RL_tc_FrameworkBasics_mDescriptionList;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_DescriptionList = _0RL_tc_FrameworkBasics_mDescriptionList;
#endif





static CORBA::PR_structMember _0RL_structmember_FrameworkBasics_mProcessConnection[] = {
  {"m_senders", _0RL_tc_FrameworkBasics_mDescriptionList},
  {"m_receivers", _0RL_tc_FrameworkBasics_mDescriptionList},
  {"m_connectionType", _0RL_tc_FrameworkBasics_mFrameworkConnectionType},
  {"m_dataType", _0RL_tc_FrameworkBasics_mFrameworkConnectionDataType},
  {"m_connectionID", _0RL_tc_FrameworkBasics_mFrameworkConnectionID}
};

#ifdef _0RL_tc_FrameworkBasics_mProcessConnection
#  undef _0RL_tc_FrameworkBasics_mProcessConnection
#endif
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mProcessConnection = CORBA::TypeCode::PR_struct_tc("IDL:FrameworkBasics/ProcessConnection:1.0", "ProcessConnection", _0RL_structmember_FrameworkBasics_mProcessConnection, 5, &_0RL_tcTrack);





#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_ProcessConnection = _0RL_tc_FrameworkBasics_mProcessConnection;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_ProcessConnection = _0RL_tc_FrameworkBasics_mProcessConnection;
#endif


static CORBA::PR_structMember _0RL_structmember_FrameworkBasics_mBALTTime[] = {
  {"m_s", CORBA::TypeCode::PR_long_tc()},
  {"m_us", CORBA::TypeCode::PR_long_tc()}
};

#ifdef _0RL_tc_FrameworkBasics_mBALTTime
#  undef _0RL_tc_FrameworkBasics_mBALTTime
#endif
static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mBALTTime = CORBA::TypeCode::PR_struct_tc("IDL:FrameworkBasics/BALTTime:1.0", "BALTTime", _0RL_structmember_FrameworkBasics_mBALTTime, 2, &_0RL_tcTrack);

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_BALTTime = _0RL_tc_FrameworkBasics_mBALTTime;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_BALTTime = _0RL_tc_FrameworkBasics_mBALTTime;
#endif






















static CORBA::TypeCode_ptr _0RL_tc_FrameworkBasics_mConnectionGraph = CORBA::TypeCode::PR_alias_tc("IDL:FrameworkBasics/ConnectionGraph:1.0", "ConnectionGraph", CORBA::TypeCode::PR_sequence_tc(0, _0RL_tc_FrameworkBasics_mProcessConnection, &_0RL_tcTrack), &_0RL_tcTrack);


#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_ConnectionGraph = _0RL_tc_FrameworkBasics_mConnectionGraph;
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_ConnectionGraph = _0RL_tc_FrameworkBasics_mConnectionGraph;
#endif

#if defined(HAS_Cplusplus_Namespace) && defined(_MSC_VER)
// MSVC++ does not give the constant external linkage otherwise.
namespace FrameworkBasics { 
  const ::CORBA::TypeCode_ptr _tc_FrameworkProcessManager = CORBA::TypeCode::PR_interface_tc("IDL:FrameworkBasics/FrameworkProcessManager:1.0", "FrameworkProcessManager", &_0RL_tcTrack);
} 
#else
const ::CORBA::TypeCode_ptr FrameworkBasics::_tc_FrameworkProcessManager = CORBA::TypeCode::PR_interface_tc("IDL:FrameworkBasics/FrameworkProcessManager:1.0", "FrameworkProcessManager", &_0RL_tcTrack);
#endif

static void _0RL_FrameworkBasics_mFrameworkConnectionType_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::FrameworkConnectionType* _p = (FrameworkBasics::FrameworkConnectionType*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mFrameworkConnectionType_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::FrameworkConnectionType* _p = (FrameworkBasics::FrameworkConnectionType*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, FrameworkBasics::FrameworkConnectionType _s)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mFrameworkConnectionType,
               _0RL_FrameworkBasics_mFrameworkConnectionType_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::FrameworkConnectionType& _s)
{
  return _a.PR_extract(_0RL_tc_FrameworkBasics_mFrameworkConnectionType,
                       _0RL_FrameworkBasics_mFrameworkConnectionType_unmarshal_fn,
                       &_s);
}

static void _0RL_FrameworkBasics_mProcessLanguage_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::ProcessLanguage* _p = (FrameworkBasics::ProcessLanguage*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mProcessLanguage_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::ProcessLanguage* _p = (FrameworkBasics::ProcessLanguage*)_v;
  *_p <<= _s;
}

void operator<<=(::CORBA::Any& _a, FrameworkBasics::ProcessLanguage _s)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessLanguage,
               _0RL_FrameworkBasics_mProcessLanguage_marshal_fn,
               &_s);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::ProcessLanguage& _s)
{
  return _a.PR_extract(_0RL_tc_FrameworkBasics_mProcessLanguage,
                       _0RL_FrameworkBasics_mProcessLanguage_unmarshal_fn,
                       &_s);
}

static void _0RL_FrameworkBasics_mStringSeq_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::StringSeq* _p = (FrameworkBasics::StringSeq*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mStringSeq_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::StringSeq* _p = new FrameworkBasics::StringSeq;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mStringSeq_destructor_fn(void* _v)
{
  FrameworkBasics::StringSeq* _p = (FrameworkBasics::StringSeq*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::StringSeq& _s)
{
  FrameworkBasics::StringSeq* _p = new FrameworkBasics::StringSeq(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mStringSeq,
               _0RL_FrameworkBasics_mStringSeq_marshal_fn,
               _0RL_FrameworkBasics_mStringSeq_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::StringSeq* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mStringSeq,
               _0RL_FrameworkBasics_mStringSeq_marshal_fn,
               _0RL_FrameworkBasics_mStringSeq_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::StringSeq*& _sp)
{
  return _a >>= (const FrameworkBasics::StringSeq*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::StringSeq*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mStringSeq,
                    _0RL_FrameworkBasics_mStringSeq_unmarshal_fn,
                    _0RL_FrameworkBasics_mStringSeq_marshal_fn,
                    _0RL_FrameworkBasics_mStringSeq_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::StringSeq*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mProcessConfigurationMap_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::ProcessConfigurationMap* _p = (FrameworkBasics::ProcessConfigurationMap*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mProcessConfigurationMap_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::ProcessConfigurationMap* _p = new FrameworkBasics::ProcessConfigurationMap;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mProcessConfigurationMap_destructor_fn(void* _v)
{
  FrameworkBasics::ProcessConfigurationMap* _p = (FrameworkBasics::ProcessConfigurationMap*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::ProcessConfigurationMap& _s)
{
  FrameworkBasics::ProcessConfigurationMap* _p = new FrameworkBasics::ProcessConfigurationMap(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessConfigurationMap,
               _0RL_FrameworkBasics_mProcessConfigurationMap_marshal_fn,
               _0RL_FrameworkBasics_mProcessConfigurationMap_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::ProcessConfigurationMap* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessConfigurationMap,
               _0RL_FrameworkBasics_mProcessConfigurationMap_marshal_fn,
               _0RL_FrameworkBasics_mProcessConfigurationMap_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::ProcessConfigurationMap*& _sp)
{
  return _a >>= (const FrameworkBasics::ProcessConfigurationMap*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::ProcessConfigurationMap*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mProcessConfigurationMap,
                    _0RL_FrameworkBasics_mProcessConfigurationMap_unmarshal_fn,
                    _0RL_FrameworkBasics_mProcessConfigurationMap_marshal_fn,
                    _0RL_FrameworkBasics_mProcessConfigurationMap_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::ProcessConfigurationMap*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mProcessDescription_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::ProcessDescription* _p = (FrameworkBasics::ProcessDescription*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mProcessDescription_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::ProcessDescription* _p = new FrameworkBasics::ProcessDescription;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mProcessDescription_destructor_fn(void* _v)
{
  FrameworkBasics::ProcessDescription* _p = (FrameworkBasics::ProcessDescription*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::ProcessDescription& _s)
{
  FrameworkBasics::ProcessDescription* _p = new FrameworkBasics::ProcessDescription(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessDescription,
               _0RL_FrameworkBasics_mProcessDescription_marshal_fn,
               _0RL_FrameworkBasics_mProcessDescription_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::ProcessDescription* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessDescription,
               _0RL_FrameworkBasics_mProcessDescription_marshal_fn,
               _0RL_FrameworkBasics_mProcessDescription_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::ProcessDescription*& _sp)
{
  return _a >>= (const FrameworkBasics::ProcessDescription*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::ProcessDescription*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mProcessDescription,
                    _0RL_FrameworkBasics_mProcessDescription_unmarshal_fn,
                    _0RL_FrameworkBasics_mProcessDescription_marshal_fn,
                    _0RL_FrameworkBasics_mProcessDescription_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::ProcessDescription*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mDescriptionList_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::DescriptionList* _p = (FrameworkBasics::DescriptionList*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mDescriptionList_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::DescriptionList* _p = new FrameworkBasics::DescriptionList;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mDescriptionList_destructor_fn(void* _v)
{
  FrameworkBasics::DescriptionList* _p = (FrameworkBasics::DescriptionList*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::DescriptionList& _s)
{
  FrameworkBasics::DescriptionList* _p = new FrameworkBasics::DescriptionList(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mDescriptionList,
               _0RL_FrameworkBasics_mDescriptionList_marshal_fn,
               _0RL_FrameworkBasics_mDescriptionList_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::DescriptionList* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mDescriptionList,
               _0RL_FrameworkBasics_mDescriptionList_marshal_fn,
               _0RL_FrameworkBasics_mDescriptionList_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::DescriptionList*& _sp)
{
  return _a >>= (const FrameworkBasics::DescriptionList*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::DescriptionList*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mDescriptionList,
                    _0RL_FrameworkBasics_mDescriptionList_unmarshal_fn,
                    _0RL_FrameworkBasics_mDescriptionList_marshal_fn,
                    _0RL_FrameworkBasics_mDescriptionList_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::DescriptionList*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mProcessConnection_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::ProcessConnection* _p = (FrameworkBasics::ProcessConnection*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mProcessConnection_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::ProcessConnection* _p = new FrameworkBasics::ProcessConnection;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mProcessConnection_destructor_fn(void* _v)
{
  FrameworkBasics::ProcessConnection* _p = (FrameworkBasics::ProcessConnection*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::ProcessConnection& _s)
{
  FrameworkBasics::ProcessConnection* _p = new FrameworkBasics::ProcessConnection(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessConnection,
               _0RL_FrameworkBasics_mProcessConnection_marshal_fn,
               _0RL_FrameworkBasics_mProcessConnection_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::ProcessConnection* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mProcessConnection,
               _0RL_FrameworkBasics_mProcessConnection_marshal_fn,
               _0RL_FrameworkBasics_mProcessConnection_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::ProcessConnection*& _sp)
{
  return _a >>= (const FrameworkBasics::ProcessConnection*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::ProcessConnection*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mProcessConnection,
                    _0RL_FrameworkBasics_mProcessConnection_unmarshal_fn,
                    _0RL_FrameworkBasics_mProcessConnection_marshal_fn,
                    _0RL_FrameworkBasics_mProcessConnection_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::ProcessConnection*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mBALTTime_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::BALTTime* _p = (FrameworkBasics::BALTTime*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mBALTTime_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::BALTTime* _p = new FrameworkBasics::BALTTime;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mBALTTime_destructor_fn(void* _v)
{
  FrameworkBasics::BALTTime* _p = (FrameworkBasics::BALTTime*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::BALTTime& _s)
{
  FrameworkBasics::BALTTime* _p = new FrameworkBasics::BALTTime(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mBALTTime,
               _0RL_FrameworkBasics_mBALTTime_marshal_fn,
               _0RL_FrameworkBasics_mBALTTime_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::BALTTime* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mBALTTime,
               _0RL_FrameworkBasics_mBALTTime_marshal_fn,
               _0RL_FrameworkBasics_mBALTTime_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::BALTTime*& _sp)
{
  return _a >>= (const FrameworkBasics::BALTTime*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::BALTTime*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mBALTTime,
                    _0RL_FrameworkBasics_mBALTTime_unmarshal_fn,
                    _0RL_FrameworkBasics_mBALTTime_marshal_fn,
                    _0RL_FrameworkBasics_mBALTTime_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::BALTTime*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mConnectionGraph_marshal_fn(cdrStream& _s, void* _v)
{
  FrameworkBasics::ConnectionGraph* _p = (FrameworkBasics::ConnectionGraph*)_v;
  *_p >>= _s;
}
static void _0RL_FrameworkBasics_mConnectionGraph_unmarshal_fn(cdrStream& _s, void*& _v)
{
  FrameworkBasics::ConnectionGraph* _p = new FrameworkBasics::ConnectionGraph;
  *_p <<= _s;
  _v = _p;
}
static void _0RL_FrameworkBasics_mConnectionGraph_destructor_fn(void* _v)
{
  FrameworkBasics::ConnectionGraph* _p = (FrameworkBasics::ConnectionGraph*)_v;
  delete _p;
}

void operator<<=(::CORBA::Any& _a, const FrameworkBasics::ConnectionGraph& _s)
{
  FrameworkBasics::ConnectionGraph* _p = new FrameworkBasics::ConnectionGraph(_s);
  _a.PR_insert(_0RL_tc_FrameworkBasics_mConnectionGraph,
               _0RL_FrameworkBasics_mConnectionGraph_marshal_fn,
               _0RL_FrameworkBasics_mConnectionGraph_destructor_fn,
               _p);
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::ConnectionGraph* _sp)
{
  _a.PR_insert(_0RL_tc_FrameworkBasics_mConnectionGraph,
               _0RL_FrameworkBasics_mConnectionGraph_marshal_fn,
               _0RL_FrameworkBasics_mConnectionGraph_destructor_fn,
               _sp);
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::ConnectionGraph*& _sp)
{
  return _a >>= (const FrameworkBasics::ConnectionGraph*&) _sp;
}
::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, const FrameworkBasics::ConnectionGraph*& _sp)
{
  void* _v;
  if (_a.PR_extract(_0RL_tc_FrameworkBasics_mConnectionGraph,
                    _0RL_FrameworkBasics_mConnectionGraph_unmarshal_fn,
                    _0RL_FrameworkBasics_mConnectionGraph_marshal_fn,
                    _0RL_FrameworkBasics_mConnectionGraph_destructor_fn,
                    _v)) {
    _sp = (const FrameworkBasics::ConnectionGraph*)_v;
    return 1;
  }
  return 0;
}

static void _0RL_FrameworkBasics_mFrameworkProcessManager_marshal_fn(cdrStream& _s, void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  omniObjRef::_marshal(_o, _s);
}
static void _0RL_FrameworkBasics_mFrameworkProcessManager_unmarshal_fn(cdrStream& _s, void*& _v)
{
  omniObjRef* _o = omniObjRef::_unMarshal(FrameworkBasics::FrameworkProcessManager::_PD_repoId, _s);
  _v = _o;
}
static void _0RL_FrameworkBasics_mFrameworkProcessManager_destructor_fn(void* _v)
{
  omniObjRef* _o = (omniObjRef*)_v;
  if (_o)
    omni::releaseObjRef(_o);
}

void operator<<=(::CORBA::Any& _a, FrameworkBasics::FrameworkProcessManager_ptr _o)
{
  FrameworkBasics::FrameworkProcessManager_ptr _no = FrameworkBasics::FrameworkProcessManager::_duplicate(_o);
  _a.PR_insert(FrameworkBasics::_tc_FrameworkProcessManager,
               _0RL_FrameworkBasics_mFrameworkProcessManager_marshal_fn,
               _0RL_FrameworkBasics_mFrameworkProcessManager_destructor_fn,
               _no->_PR_getobj());
}
void operator<<=(::CORBA::Any& _a, FrameworkBasics::FrameworkProcessManager_ptr* _op)
{
  _a.PR_insert(FrameworkBasics::_tc_FrameworkProcessManager,
               _0RL_FrameworkBasics_mFrameworkProcessManager_marshal_fn,
               _0RL_FrameworkBasics_mFrameworkProcessManager_destructor_fn,
               (*_op)->_PR_getobj());
  *_op = FrameworkBasics::FrameworkProcessManager::_nil();
}

::CORBA::Boolean operator>>=(const ::CORBA::Any& _a, FrameworkBasics::FrameworkProcessManager_ptr& _o)
{
  void* _v;
  if (_a.PR_extract(FrameworkBasics::_tc_FrameworkProcessManager,
                    _0RL_FrameworkBasics_mFrameworkProcessManager_unmarshal_fn,
                    _0RL_FrameworkBasics_mFrameworkProcessManager_marshal_fn,
                    _0RL_FrameworkBasics_mFrameworkProcessManager_destructor_fn,
                    _v)) {
    omniObjRef* _r = (omniObjRef*)_v;
    if (_r)
      _o = (FrameworkBasics::FrameworkProcessManager_ptr)_r->_ptrToObjRef(FrameworkBasics::FrameworkProcessManager::_PD_repoId);
    else
      _o = FrameworkBasics::FrameworkProcessManager::_nil();
    return 1;
  }
  return 0;
}

