THIS IS ALL A BIT OUT OF DATE, OUTPUT IS NOW FROM 4 CONNECTIONS RATHER
THAN JUST ONE.

Preamble...
-------------------------------

Before running the demos, you first need to enter some configuration
information into the file 

framework-0.5.0/build.xml

Look for the following lines...

<!--- EDIT THESE TO REFLECT YOUR SYSTEM -->
<property name="naming.host" value="dewey"/>
<property name="machine.A" value="dewey"/>
<property name="machine.B" value="louie"/>

The first line defines the hostname of the machine on which the CORBA
naming system is running. The naming service is necessary to allow the
various components to communicate. You must change the naming.host
line to be THE SAME ON EVERY MACHINE YOU PLAN TO USE. machine.A and
machine.B are the names of two machines on which the demonstrations
will run processes. If you only have one machine then you can set them
to be the same (although some of these demos will then be slightly
less exciting). You must ensure you have the framework installed on
both of these machines, and Java installed on the naming.host (as we
use the Java naming service).

Once you have done this, you must start the naming service. For the
framework we are using the Java CORBA naming server "tnameserv". Log
on to the machine denoted by the property naming.host above
(e.g. dewey), and run the following command:

$ tnameserv -ORBInitialPort 1050 &

This should produce something like this...

Initial Naming Context:
IOR:000000000000002b49444c3a6f6d672e6f72672f436f734e616d696e672f4e616d696e67436f6e746578744578743a312e300000000000010000000000000096000102000000000a3132372e302e302e3100041a00000045afabcb000000002043bd3ba100000001000000000000000200000008526f6f74504f41000000000d544e616d65536572766963650000000000000008000000010000000114000000000000020000000100000020000000000001000100000002050100010001002000010109000000010001010000000026000000020002
TransientNameServer: setting port for initial object references to:
1050

If tnameserv is not found, ensure that Java is installed and that
$JAVA_HOME/bin is in your path (see INSTALL file).

The following demos assume that you've already edited build.xml on
each machine, and have started tnameserv.


Demo 1: 2 local Java Processes 
-------------------------------

The first demo involves 2 Java processes running on the same
machine. Because they are both in the same language on the same
machine they are connected via a standard Java object. This reduces
the overhead of connectivity. To run the demo, first start a process
server on machine.A...

user@machine.A$ cd framework-0.5.0
user@machine.A$ ant ProcessServer

This should produce some output ending in the line...


     [java] Server ready and running....


Then, in a different console start the configuration client for this demo...

user@machine.A$ cd framework-0.5.0 
user@machine.A$ ant Demo1



The will generate a little bit of output, but then the server will
give a lot of output about what is going on. It should look a little
like the following... (my comments in backets)



Process Server: Creating framework processes...

(this step creates the processes on the appropriate machines)

Connection graph:
[[Java: Push Sender on dewey, local = true] push_to [Java: Push Receiver on dewey, local = true]]

(this shows what is going to be created, process 1 is called "Push
Sender on dewey" and it will push data to "Push Receiver on
dewey")

Process Server: Creating connection servers...  

(this step creates any connection objects necessary to connect the
processes, in this case 1 local push connector is created)


Process Server: Connecting framework processes...

(this step connects the processes up using the connection objects)


Process Server: Starting framework processes...

(this step starts each process running)

Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]

(this is what "Push Receiver on dewey" received by push. Data is
currently just a string, but it could be any objects support by C++,
Java and CORBA)


Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]
Push Receiver on dewey received: [FrameworkData source="Push Sender on dewey" data="data from Push Sender on dewey"]

Process Server: Stopping framework processes...

(after 5 seconds the client shuts down the framework processes)

waiting for Push Receiver on dewey thread... OK
waiting for Push Sender on dewey thread... OK

(this is just some debugging to demonstrate that the threads are
actually being terminated!)




Demo 2: 2 local C++ Processes 
-------------------------------

This second demo shows the same set up as Demo 1, but with 2 C++
processes being launched instead of 2 Java ones. Restart the process
server (although it should be OK not to unless you've changed any of
the code in the meantime), and run the configuration client for the
second demo...

user@machine.A$ ant Demo2

The output should be almost identical, except for the line...

Connection graph:
[[CPP: Push Sender on dewey, local = true] push_to [CPP: Push Receiver on dewey, local = true]]

... which changes to reflect the 2 processes are in C++.



Demo 3: 2 local Processes 1 Java, 1 C++
---------------------------------------

The framework can transparently mix Java and C++. This demo uses a C++
process to send the push, and a Java one to receive it. Restart the
server, and run the client using...

user@machine.A$ ant Demo3


Again only the previously mentioned line should change.

To communicate between processes in different languages a CORBA server
is started up and both processes are connected to it. This means that
the language translations are handled by someone else! At a later date
this could be rewritten with the Java Native Interface so that CORBA
is not required to communicate between processes in different
languages on the same machine.


**WARNING**: This sometimes gives a nasty looking error on shutdown. This
is due to some inconsistencies between how threads are shutdown in C++
and in Java. It will be fixed shortly.


Demo 4: 2 local Processes 1 Java, 1 C++
---------------------------------------


This swaps the language of sender and receiver. Java process pushing
to C++ process. Restart the server, and run the client using...

user@machine.A$ ant Demo4

Again only the previously mentioned line should change.



Demo 5: 2 distributed processes 1 Java, 1 C++
---------------------------------------------

Having demonstrated the functionality on a single machine, this
example shows how with a small amount of extra effort, the framework
supports processes communicating across a network. For this demo you
need to log on to machine.B from above and start a server in a
addition to the one on machine.A. You can then run the configuration
client from either machine. This demo is the same as demo 3 except
that the Java receiver process is on machine.B instead of machine.A.

To run the demo, to the following in different terminals...

user@machine.A$ cd framework-0.5.0
user@machine.A$ ant ProcessServer

user@machine.B$ cd framework-0.5.0
user@machine.B$ ant ProcessServer

user@machine.A$ ant Demo5

There are some small changes to the output this time...


Connection graph:
[[CPP: Push Sender on dewey, local = true] push_to [Java: Push Receiver on louie, local = false]]

The "local = " informaton above will look different on each machine,
as it knows whether the process is local to it or not.


Push Receiver on louie received [FrameworkData source="Push Sender on dewey" data="Push Sender on dewey"]

The above data now reflects that the sender and receiver are on
different hosts.


Demo 6: 2 distributed processes 1 Java, 1 C++
---------------------------------------------

As with demo 4 we now swap the languages of the sender and
receiver. Run with...

user@machine.A$ ant Demo6

Changed line in ouput...

[[Java: Push Sender on dewey, local = false] push_to [CPP: Push Receiver on louie, local = true]]



Demo 7 - 12: Previous demos repeated with pull instead of push
--------------------------------------------------------------

ant Demo7 : 2 Java pull processes

ant Demo8 : 2 C++ pull processes

ant Demo9 : Java process pulls from C++

ant Demo10 : C++ process pulls from Java

ant Demo11 : Java process on machine.A pulls from C++ process on
machine.B

ant Demo12 : C++ process on machine.A pulls from Java process on
machine.B
